<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imagi-world</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin: 20px 0;
            font-size: 2rem;
            text-align: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .controls {
            background: #16213e;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #numTrialsSlider {
            width: 100%;
            margin-top: 8px;
        }

        #numTrialsDisplay {
            display: block;
            margin-top: 8px;
            font-weight: 600;
            color: #e94560;
        }

        .label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .hint {
            display: block;
            margin-top: 4px;
            color: #aaa;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        input[type="range"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: 1px solid #1a4d7a;
            border-radius: 6px;
            font-size: 1rem;
            margin-left: 10px;
        }

        input[type="number"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .range-value {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #e94560;
        }

        .dual-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dual-control input[type="range"] {
            flex: 1;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #d63651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        #btnInstructions.completed::after {
            content: ' ‚úì';
            font-weight: 700;
            color: #2ecc71;
        }

        button.secondary {
            background: #0f3460;
        }

        button.secondary:hover:not(:disabled) {
            background: #1a4d7a;
        }

        button.danger {
            background: #c0392b;
        }

        button.danger:hover:not(:disabled) {
            background: #a93226;
        }

        button.success {
            background: #27ae60;
        }

        button.success:hover:not(:disabled) {
            background: #229954;
        }

        .game-area {
            background: #16213e;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            width: 100%;
        }

        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e94560;
        }

        .response-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .response-buttons button {
            flex: 1;
            padding: 20px;
            font-size: 1.2rem;
        }

        .match-btn {
            background: #2ecc71;
        }

        .match-btn:hover:not(:disabled) {
            background: #27ae60;
        }

        .no-match-btn {
            background: #e74c3c;
        }

        .no-match-btn:hover:not(:disabled) {
            background: #c0392b;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .feedback.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .feedback.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        #debug {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
        }

        #debug h3 {
            margin-bottom: 15px;
            color: #e94560;
        }

        .debug-premise {
            margin-bottom: 10px;
            padding: 8px;
            background: #16213e;
            border-radius: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .voice-info {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 10px;
        }

        .voice-info strong {
            color: #e94560;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .test-panel {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }


        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .test-result.pass {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .test-result.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .premise-display {
            font-size: 1.3rem;
            color: #aaa;
            margin: 20px 0;
            min-height: 60px;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .response-buttons {
                flex-direction: column;
            }
        }

        #dlgInstructions {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.88);
            backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 999;
        }

        #dlgInstructions[hidden] {
            display: none;
        }

        #dlgInstructions > header,
        #dlgInstructions > footer,
        #dlgInstructions > nav,
        #dlgInstructions > article {
            width: min(960px, 100%);
        }

        #dlgInstructions > header {
            background: #16213e;
            padding: 20px 60px 20px 24px;
            border-radius: 12px 12px 0 0;
            position: relative;
        }

        #instTitle {
            margin-bottom: 12px;
            font-size: 1.6rem;
        }

        #instClose {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            font-size: 1.4rem;
            line-height: 1;
            color: #e94560;
            cursor: pointer;
            padding: 4px 8px;
        }

        #instClose:hover {
            transform: none;
            color: #fff;
            background: transparent;
            box-shadow: none;
        }

        #instTabs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            background: #0f3460;
            padding: 16px;
        }

        #instTabs button {
            background: #16213e;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.95rem;
            border: 1px solid transparent;
        }

        #instTabs button.active {
            background: #e94560;
            border-color: #f08fa2;
        }

        #instTabs button.visited:not(.active) {
            border-color: #27ae60;
        }

        #instContent {
            background: #0a0e1a;
            padding: 24px;
            min-height: 280px;
            max-height: 360px;
            overflow-y: auto;
            outline: none;
        }

        #instContent h3 {
            margin-bottom: 12px;
            font-size: 1.3rem;
        }

        #instContent p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #walkthroughN2 .algo li {
            margin: 0.25rem 0;
        }

        #walkthroughN2 .anchors,
        #walkthroughN2 .returns {
            margin-left: 1rem;
        }

        #walkthroughN2 .trials > li {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border: 1px solid var(--border, #444);
            border-radius: 0.5rem;
            background: rgba(22, 33, 62, 0.6);
        }

        #walkthroughN2 .match {
            color: var(--ok, #2ecc71);
            font-weight: 600;
        }

        #walkthroughN2 .nomatch {
            color: var(--warn, #e67e22);
            font-weight: 600;
        }

        #walkthroughN2 .actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        #walkthroughN2 .brandline {
            margin-bottom: 0.5rem;
        }

        #instContent ul,
        #instContent ol {
            margin-left: 20px;
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #examplesFilters {
            margin: .5rem 0 1rem;
            display: flex;
            gap: .5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        #examplesFilters button.active {
            font-weight: 700;
            text-decoration: underline;
        }

        #examplesList > li {
            margin: 0 0 1rem 0;
            padding: .75rem;
            border: 1px solid var(--border, #ddd);
            border-radius: .5rem;
        }

        .exActions {
            display: flex;
            gap: .5rem;
            margin-top: .5rem;
        }

        #instFooter {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #16213e;
            padding: 16px 24px;
            border-radius: 0 0 12px 12px;
        }

        #instFooter .inline {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        #instFooter .spacer {
            flex: 1;
        }

        .inst-brand-tagline {
            font-size: 0.9rem;
            color: #f5c0d1;
            line-height: 1.5;
        }

        body.dialog-open {
            overflow: hidden;
        }

        .sandbox-panel {
            margin-top: 16px;
            padding: 16px;
            background: #111a33;
            border-radius: 8px;
        }

        .sandbox-panel h4 {
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .sandbox-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter {
            background: #16213e;
            padding: 10px;
            border-radius: 6px;
        }

        .sandbox-letter label {
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        .sandbox-letter input[type="text"] {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #1a4d7a;
            background: #0f3460;
            color: #fff;
        }

        .sandbox-atom-list {
            margin-bottom: 12px;
            font-family: 'Courier New', monospace;
        }

        .sandbox-journal {
            margin-top: 12px;
            max-height: 140px;
            overflow-y: auto;
            background: #0f0f24;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .sandbox-journal-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed rgba(233, 69, 96, 0.4);
        }

        @media (max-width: 780px) {
            #instTabs {
                grid-template-columns: repeat(2, 1fr);
            }

            #instFooter {
                flex-direction: column;
                align-items: stretch;
            }

            #instFooter .spacer {
                display: none;
            }

            .inst-footer-brand {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <h1>üåÄImagi-worldüåÄ</h1>

        <div class="controls">
            <div class="control-group">
                <label>N-Back Level: <span class="range-value" id="n-value">1</span></label>
                <input type="range" id="n-slider" min="1" max="5" value="1">
            </div>

            <div class="control-group">
                <label><span id="k-label">Atoms per Premise</span> (k): <span class="range-value" id="k-value">1</span></label>
                <input type="range" id="k-slider" min="1" max="4" value="1">
            </div>

            <div class="control-group">
                <label>Seconds per Trial: <span class="range-value" id="spt-value">8.0</span> s</label>
                <div class="dual-control">
                    <input type="range" id="spt-slider" min="2" max="20" step="0.5" value="8.0">
                    <input type="number" id="spt-number" min="2" max="20" step="0.5" value="8.0">
                </div>
            </div>

            <div class="control-group">
                <label for="numTrialsInput">Number of trials per session</label>
                <input id="numTrialsInput" type="number" min="1" max="10000" step="1" value="20" />
                <input id="numTrialsSlider" type="range" min="1" max="500" step="1" value="20" />
                <span id="numTrialsDisplay">Trials: 20</span>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="transitivity-toggle">
                <label for="transitivity-toggle" style="margin-bottom: 0;">Enable Advanced Transitivity</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="g-leap-toggle">
                <label for="g-leap-toggle" style="margin-bottom: 0;">Force Meta-Relational Trials (Level 6: g-Leap)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="compound-leap-toggle">
                <label for="compound-leap-toggle" style="margin-bottom: 0;">Force Compound Operator Trials (Level 7: Maximum g-Load)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="lock-seed-toggle">
                <label for="lock-seed-toggle" style="margin-bottom: 0;">Lock seed (reuse until unlocked)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="reset-seed-toggle">
                <label for="reset-seed-toggle" style="margin-bottom: 0;">Reset stats & logs on Restart</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="debug-toggle">
                <label for="debug-toggle" style="margin-bottom: 0;">Show Debug Panel</label>
            </div>

            <div class="control-group">
                <label class="inline" title="Let the session play without responses">
                    <input id="listenOnlyToggle" type="checkbox" />
                    Listen-Only (Auto-Advance)
                </label>
                <small id="listenOnlyHint" aria-live="polite" hidden>
                    Listening mode: scoring disabled; session will auto-advance to completion.
                </small>
            </div>

            <div style="margin-top: 20px;">
                <div class="button-group">
                    <button id="start-btn" class="success">Start</button>
                    <button id="restart-btn" class="success" disabled>Restart</button>
                    <button id="stop-btn" class="danger" disabled>Stop</button>
                    <button id="repeat-btn" class="secondary" disabled>Repeat Audio</button>
                    <button id="preview-btn" class="secondary">Voice Preview</button>
                    <button id="reset-voice-btn" class="secondary">Reset Voice</button>
                    <button id="btnInstructions" aria-haspopup="dialog" aria-controls="dlgInstructions">Instructions</button>
                </div>
                <div class="button-group">
                    <button id="test-btn" class="secondary">Run Tests</button>
                    <button id="export-btn" class="secondary">Download so far</button>
                </div>
            </div>

            <div class="voice-info" id="voice-info">Initializing voice...</div>
        </div>

        <div class="game-area">
            <div class="status" id="status">Preparing voice system...</div>
            <div class="premise-display" id="premise-display"></div>

            <div class="response-buttons">
                <button class="match-btn" id="match-btn" disabled>
                    MATCH<br><small>(Spacebar)</small>
                </button>
                <button class="no-match-btn" id="no-match-btn" disabled>
                    NO MATCH<br><small>(Enter)</small>
                </button>
            </div>

            <div class="feedback" id="feedback"></div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Trial</div>
                    <div class="stat-value" id="trial-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="accuracy">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Rolling Acc.</div>
                    <div class="stat-value" id="rolling-acc">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Omissions</div>
                    <div class="stat-value" id="omissions">0</div>
                </div>
            </div>
        </div>


        <div id="debug" hidden>
            <h3>Debug Panel - Last Premises</h3>
            <div id="debug-content"></div>
        </div>

        <div id="test-panel" class="test-panel" hidden>
            <h3>Test Results</h3>
            <div id="test-results"></div>
        </div>
    </main>

    <section id="dlgInstructions" role="dialog" aria-modal="true" aria-labelledby="instTitle" hidden>
        <header>
            <h2 id="instTitle">Imagi-World: Learn the Arc of Abstraction</h2>
            <p class="inst-brand-tagline"><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness.</p>
            <button id="instClose" aria-label="Close">‚úï</button>
        </header>

        <nav id="instTabs" aria-label="Tutorial Sections">
            <button data-tab="welcome" class="active">Welcome</button>
            <button data-tab="compass">Imagi-Compass</button>
            <button data-tab="anchor">Anchor &amp; Transform</button>
            <button data-tab="examples">Guided Examples</button>
            <button data-tab="practice">Sandbox Practice</button>
            <button data-tab="mastery">Mastery Path</button>
            <button data-tab="level6">Level 6: g-Leap</button>
            <button data-tab="level7">Level 7: Ultimate</button>
            <button data-tab="pitfalls">Pitfalls &amp; FAQ</button>
            <button data-tab="glossary">Glossary</button>
        </nav>

        <article id="instContent" tabindex="0" aria-live="polite"></article>

        <footer id="instFooter">
            <label class="inline">
                <input id="instReadAloud" type="checkbox" />
                Read this section aloud
            </label>
            <div class="spacer"></div>
            <button id="instPrev">‚Üê Previous</button>
            <button id="instNext">Next ‚Üí</button>
        </footer>
    </section>

    <script type="module">
        const RELATION_WORDS = { N: 'north of', S: 'south of', E: 'east of', W: 'west of' };
        const MATCH_AXES = ['N', 'S', 'E', 'W'];
        const ACCEPTANCE_ALPHA = 0.25;
        const ACCEPTANCE_BETA = 0.5;
        const FIRST_N_NOVELTY = 6;
        const HAMMING_WINDOW = 8;
        const NOVELTY_OVERRIDE_THRESHOLD = 30;
        const MAX_GENERATION_ATTEMPTS = 240;
        const conflictConfig = {
            foilRate: 0.35,
            foilTypesWeights: {
                ANCHOR_ONE: 0.20,
                PAIR_SWAP: 0.20,
                PARITY_OFF: 0.15,
                AXIS_ORTHO: 0.15,
                DERIVED_IN_ONE: 0.15,
                WINDOW_SHADOW: 0.15
            }
        };

        const NUM_TRIALS_KEY = 'numTrials';
        const LISTEN_ONLY_KEY = 'listenOnly';
        const numTrialsInput = document.getElementById('numTrialsInput');
        const numTrialsSlider = document.getElementById('numTrialsSlider');
        const numTrialsDisplay = document.getElementById('numTrialsDisplay');
        const listenOnlyToggle = document.getElementById('listenOnlyToggle');
        const listenOnlyHint = document.getElementById('listenOnlyHint');

        function loadListenOnly() {
            try {
                return localStorage.getItem(LISTEN_ONLY_KEY) === '1';
            } catch (err) {
                console.warn('Failed to load listen-only preference', err);
                return false;
            }
        }

        function persistListenOnly(on) {
            try {
                localStorage.setItem(LISTEN_ONLY_KEY, on ? '1' : '0');
            } catch (err) {
                console.warn('Failed to persist listen-only preference', err);
            }
            if (listenOnlyHint) {
                listenOnlyHint.hidden = !on;
            }
        }

        if (listenOnlyToggle) {
            const initListenOnly = loadListenOnly();
            listenOnlyToggle.checked = initListenOnly;
            persistListenOnly(initListenOnly);
            listenOnlyToggle.addEventListener('change', () => {
                persistListenOnly(listenOnlyToggle.checked);
            });
        }

        const TUTORIAL_SECTIONS = [
            {
                id: 'welcome',
                title: 'Welcome to Imagi-World',
                html: `
                    <h3>Welcome to Imagi-World</h3>
                    <p><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness.</p>
                    <p>Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the <strong>Arc of Abstraction</strong> using the <strong>Imagi-Compass</strong>. North means <strong>up-shift</strong> to higher-order concepts, South means <strong>down-shift</strong> to concrete instances, East means <strong>analogue</strong> (same role/sibling concept), West means <strong>opposite</strong> (counterpart/foil).</p>
                    <p>The spatial logic remains strict; your analogies ride on top. This union‚Äîformal clarity plus creative projection‚Äîis our brand and our method.</p>
                    <p><strong>Outcome:</strong> by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.</p>
                `,
                speech: 'Welcome to Imagi-World. Imagi-World trains maximized imagination across the Arc of Abstraction. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness. Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the Arc of Abstraction using the Imagi-Compass. North means up-shift to higher-order concepts. South means down-shift to concrete instances. East means analogue, the same role or a sibling concept. West means opposite, the counterpart or foil. The spatial logic remains strict, and your analogies ride on top. This union, formal clarity plus creative projection, is our brand and our method. Outcome: by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.'
            },
            {
                id: 'compass',
                title: 'The Imagi-Compass',
                html: `
                    <h3>The Imagi-Compass</h3>
                    <ul>
                        <li><strong>North (‚Üë Up-shift):</strong> move to meta, greater scale, more general, more intense. "Candle ‚Üí Fireworks"; "Task ‚Üí Project ‚Üí Program."</li>
                        <li><strong>South (‚Üì Down-shift):</strong> move to instance, component, concrete, less intense. "Theory ‚Üí Example"; "System ‚Üí Tool ‚Üí Part."</li>
                        <li><strong>East (‚Üí Analogue):</strong> parallel function or sibling concept. "Candle ‚Üí Lantern"; "Fact ‚Üí Case study"; "Parent ‚Üí Guardian."</li>
                        <li><strong>West (‚Üê Opposite):</strong> antonym/counter-role. "Fact ‚Üî Fiction"; "Order ‚Üî Chaos"; "Light ‚Üî Darkness."</li>
                    </ul>
                    <p><strong>Rule:</strong> your analogical mapping must be <strong>self-consistent</strong> within a session. Reframes are allowed but must be acknowledged.</p>
                `,
                speech: 'The Imagi-Compass. North, the up-shift, moves to meta, to greater scale, to more general or more intense territory. Candle to fireworks. Task to project to program. South, the down-shift, moves to instance, to component, to concrete or less intense forms. Theory to example. System to tool to part. East, the analogue, is the parallel function or sibling concept. Candle to lantern. Fact to case study. Parent to guardian. West, the opposite, is the antonym or counter-role. Fact to fiction. Order to chaos. Light to darkness. Rule: your analogical mapping must be self-consistent within a session. Reframes are allowed but must be acknowledged.'
            },
            {
                id: 'anchor',
                title: 'Step-by-Step: Anchor & Transform',
                html: `
                    <h3>Step-by-Step: Anchor &amp; Transform</h3>
                    <ol>
                        <li><strong>Anchor</strong> one letter from the current premise to a real concept from your stream of consciousness (write it or think it). Example: <code>X := "Fact"</code>.</li>
                        <li><strong>Transform</strong> per atom:
                            <ul>
                                <li><code>Y is north of X</code> ‚Üí <code>Y := Up-shift(X)</code> ‚Üí "Theory".</li>
                                <li><code>Z is west of X</code> ‚Üí <code>Z := Opposite(X)</code> ‚Üí "Fiction".</li>
                                <li><code>R is south of Y</code> ‚Üí <code>R := Down-shift(Y)</code> ‚Üí "Example".</li>
                                <li><code>H is east of R</code> ‚Üí <code>H := Analogue(R)</code> ‚Üí "Case study".</li>
                            </ul>
                        </li>
                        <li><strong>Check coherence</strong>: does each transformed concept match its relational cue? If yes, commit this mapping to your session notes.</li>
                        <li><strong>Never bleed analogies into scoring</strong>: logic is graded by the formal engine; analogies are your training mirror.</li>
                    </ol>
                    <p><strong>Mantra:</strong> <strong>Anchor ‚Üí Transform ‚Üí Cohere ‚Üí Commit.</strong></p>
                `,
                speech: 'Step-by-Step: Anchor and Transform. One: Anchor one letter from the current premise to a real concept from your stream of consciousness, write it or think it. Example: X equals Fact. Two: Transform per atom. Y is north of X, so Y equals the up-shift of X, Theory. Z is west of X, so Z equals the opposite of X, Fiction. R is south of Y, so R equals the down-shift of Y, Example. H is east of R, so H equals the analogue of R, Case study. Three: Check coherence. Does each transformed concept match its relational cue? If yes, commit this mapping to your session notes. Four: Never bleed analogies into scoring. Logic is graded by the formal engine; analogies are your training mirror. Mantra: Anchor, Transform, Cohere, Commit.'
            },
            {
                id: 'examples',
                title: 'Guided Examples',
                html: `
                    <h3>Guided Examples</h3>
                    <p>The worked library loads in a moment. Use it to study beginner-friendly mappings across every compass move.</p>
                `,
                speech: 'Guided Examples. Explore the library of thirty worked analogies. Use the filter buttons to focus on single atoms, dual heads, chains, or full quartets. Each entry shows the premise, anchors, compass moves, the resulting mapping, and a quick rationale. Tap Speak summary to hear one in the same training voice.'
            },
            {
                id: 'practice',
                title: 'Sandbox Practice (Not Scored)',
                html: `
                    <h3>Sandbox Practice (Not Scored)</h3>
                    <ul>
                        <li>This is a safe studio. Load the <strong>latest premise</strong> (button "Load current premise"), or spawn a <strong>fresh training premise</strong> (button "Spawn practice premise").</li>
                        <li>Enter concepts for the letters; click <strong>Apply Relation Operations</strong> to auto-suggest analogues/opposites/up/down (you may override).</li>
                        <li>Use <strong>Commit to Journal</strong> to save your mapping snapshots (they do not affect your game score).</li>
                        <li>Toggle <strong>Read this section aloud</strong> for gentle narration using the same single voice the game uses.</li>
                    </ul>
                    <p><strong>Tip:</strong> strive for <strong>one-sentence explanations</strong> that justify your choices: "I chose <em>Theory</em> above <em>Fact</em> because it generalizes observations into predictive structure."</p>
                `,
                speech: 'Sandbox Practice, not scored. This is a safe studio. Load the latest premise with the button Load current premise, or spawn a fresh training premise with the button Spawn practice premise. Enter concepts for the letters; click Apply Relation Operations to auto-suggest analogues, opposites, up, or down shifts. You may override anything. Use Commit to Journal to save your mapping snapshots. They do not affect your game score. Toggle Read this section aloud for gentle narration using the same single voice the game uses. Tip: strive for one-sentence explanations that justify your choices, such as, I chose Theory above Fact because it generalizes observations into predictive structure.'
            },
            {
                id: 'mastery',
                title: 'Mastery: From Symbols to Schemas',
                html: `
                    <h3>Mastery: From Symbols to Schemas</h3>
                    <ul>
                        <li><strong>Level 1 ‚Äî Single-atom fluency:</strong> 95% accuracy in naming valid up/down/analogue/opposite for any anchor within 3 seconds.</li>
                        <li><strong>Level 2 ‚Äî Two-atom coordination:</strong> keep consistency when a letter appears in two relations; reconcile tensions by compound mappings ("chaotic example").</li>
                        <li><strong>Level 3 ‚Äî Chain reasoning:</strong> three or more atoms spanning two axes; maintain semantic integrity across the chain.</li>
                        <li><strong>Level 4 ‚Äî Near-miss foils:</strong> detect when premises <strong>look</strong> similar but fail one criterion (anchoring parity, mapping, axis alignment, derivability). Explain <strong>why</strong> they're not matches in plain language.</li>
                        <li><strong>Level 5 ‚Äî Transfer:</strong> take a mapping that worked in one theme ("Learning &amp; Illumination") and remake it in a different theme ("Teams &amp; Leadership"), preserving relational roles: <code>Fact‚ÜíNovice Task</code>, <code>Theory‚ÜíBest Practice</code>, <code>Example‚ÜíCase Review</code>, <code>Case study‚ÜíPlaybook</code>, <code>Fiction‚ÜíMyth/Misconception</code>.</li>
                        <li><strong>Level 6 ‚Äî Meta-Relational Analogy (The 'g' Leap):</strong> This is the most advanced task, designed for peak fluid intelligence. You will see a new premise type: <code>"North to South as East to West."</code> This is a pure analogy of relations. The game engine is testing if the <em>relationship</em> between the first pair is the same as the <em>relationship</em> between the second pair. <br><strong>Your Task:</strong> Determine if the premise is True or False. An N-back match occurs if the N-back premise has the <em>same truth value</em> (i.e., True matches True, and False matches False). <br><strong>Example:</strong> <code>North to South as East to West</code> <br><strong>Deduction 1 (5th-Order):</strong> The relation <code>(North to South)</code> is <code>Up-shift</code> ‚Üí <code>Down-shift</code>. These are opposites. The hidden operator is <strong>West</strong>. <br><strong>Deduction 2 (5th-Order):</strong> The relation <code>(East to West)</code> is <code>Analogue</code> ‚Üí <code>Opposite</code>. These are also opposites. The hidden operator is <strong>West</strong>. <br><strong>Result:</strong> <code>West</code> equals <code>West</code>. The premise is <strong>True</strong>. <br><strong>Example 2:</strong> <code>North to East as South to West</code> <br><strong>Deduction 1:</strong> <code>(North to East)</code> is <code>Up-shift</code> ‚Üí <code>Analogue</code>. These are orthogonal. The relation is <strong>None</strong>. <br><strong>Deduction 2:</strong> <code>(South to West)</code> is <code>Down-shift</code> ‚Üí <code>Opposite</code>. These are also orthogonal. The relation is <strong>None</strong>. <br><strong>Result:</strong> <code>None</code> equals <code>None</code>. The premise is <strong>True</strong>. <br><strong>Example 3:</strong> <code>North to South as North to East</code> <br><strong>Result:</strong> <code>West</code> does not equal <code>None</code>. The premise is <strong>False</strong>.</li>
                        <li><strong>Advanced Strategy ‚Äî Semantic Anchoring (Mental Technique):</strong> This is <strong>not a separate game mode</strong>‚Äîit's a powerful mental strategy you can apply to any level. Instead of manipulating abstract letters, you <strong>mentally anchor them to concrete concepts</strong> from your lived experience. <br><strong>How It Works (Purely Mental):</strong> (1) System shows: <code>N is north of J</code>. (2) You mentally anchor: J := "Fact". (3) You mentally transform: North(J‚ÜíN) = up-shift "Fact" ‚Üí "Theory". (4) You mentally map: N := "Theory". (5) In your head, the premise becomes "Theory is the higher abstraction of Fact". <br><strong>The Key:</strong> The system <strong>never sees</strong> your semantic anchors. They exist purely in your working memory. <br><strong>Applying to Level 6:</strong> You can also anchor META premises mentally. System shows: <code>"North to South as East to West"</code>. You mentally imagine: "North to South" (opposite) = "Teacher to Student" relationship. "East to West" (opposite) = "Day to Night" relationship. Both are opposite relationships ‚Üí TRUE premise. <br><strong>Ultimate Challenge:</strong> Combine mental semantic anchoring with Level 6 META premises at high n-back (n=4 or 5). This requires: <strong>(1) Generating</strong> mental semantic anchors, <strong>(2) Evaluating</strong> truth values via operator logic, <strong>(3) Recalling</strong> your mental anchors from 4-5 trials ago, <strong>(4) Maintaining</strong> all of this in working memory simultaneously. This is the highest g-load task because YOUR imagination creates the semantic layer <strong>entirely in your head</strong>.</li>
                    </ul>
                    <p><strong>Mastery litmus:</strong> you can improvise <strong>new, coherent mappings</strong> at speed, across themes, while the logic engine remains satisfied‚Äîno contradictions, no shortcuts.</p>
                `,
                speech: 'Mastery: From Symbols to Schemas. Level one, single-atom fluency: ninety-five percent accuracy in naming valid up, down, analogue, or opposite moves for any anchor within three seconds. Level two, two-atom coordination: keep consistency when a letter appears in two relations; reconcile tensions by compound mappings such as Chaotic example. Level three, chain reasoning: three or more atoms spanning two axes; maintain semantic integrity across the chain. Level four, near-miss foils: detect when premises look similar but fail one criterion‚Äîanchoring parity, mapping, axis alignment, derivability. Explain why they are not matches in plain language. Level five, transfer: take a mapping that worked in one theme, Learning and Illumination, and remake it in a different theme, Teams and Leadership, preserving relational roles: Fact to Novice Task, Theory to Best Practice, Example to Case Review, Case study to Playbook, Fiction to Myth or Misconception. Level six, Meta-Relational Analogy, the g-Leap: This is peak fluid intelligence. You will see pure operator analogies like North to South as East to West. Your task: determine if the premise is true or false by deducing the hidden operator. Example: North to South is Up-shift to Down-shift, which are opposites, so the hidden operator is West. East to West is Analogue to Opposite, also opposites, so the hidden operator is West. West equals West, the premise is True. An n-back match occurs when both premises have the same truth value. Level seven, Generative Semantic Anchoring, the Ultimate g-Leap: This is the highest cognitive challenge. When you see a Level six premise, you will be prompted to generate your own semantic pairs from imagination. The system shows North to South as East to West. You input: What does North to South mean to you? You type Teacher to Student. You input: What does East to West mean to you? You type Day to Night. The system validates your pairs, stores them with the premise, and you must recall YOUR anchors across n-back trials. This maximizes g-load through generative creation, working memory for self-generated concepts, dual representation of operators plus personal semantics, validation of your semantics, and n-back matching while recalling your anchors. This is the highest g-load task because your imagination creates the semantic layer. Mastery litmus: you can improvise new, coherent mappings at speed, across themes, while the logic engine remains satisfied‚Äîno contradictions, no shortcuts.'
            },
            {
                id: 'pitfalls',
                title: 'Pitfalls & FAQ',
                html: `
                    <h3>Pitfalls &amp; FAQ</h3>
                    <dl>
                        <dt><strong>Q:</strong> Can I use the same word for East (analogue)?</dt>
                        <dd><strong>A:</strong> Prefer <strong>siblings</strong>, not duplicates. "Candle ‚Üí Lantern," not "Candle ‚Üí Candle."</dd>
                        <dt><strong>Q:</strong> My West choice feels too cartoonish.</dt>
                        <dd><strong>A:</strong> "Opposite" includes <strong>counter-role</strong> or <strong>antagonist</strong>, not just antonym. "Order ‚Üî Chaos," "Plan ‚Üî Improvisation."</dd>
                        <dt><strong>Q:</strong> What if my mapping breaks later?</dt>
                        <dd><strong>A:</strong> Use a <strong>Reframe</strong> action. Log it. Consistency matters more than stubbornness.</dd>
                        <dt><strong>Q:</strong> Do analogies change scoring?</dt>
                        <dd><strong>A:</strong> No. Scoring is formal. Analogies train your <strong>semantic agility</strong>.</dd>
                        <dt><strong>Q (Level 6):</strong> How do I know if a META premise is True or False?</dt>
                        <dd><strong>A:</strong> Deduce the hidden operator for each pair. Example: "North to South" = Up-shift‚ÜíDown-shift = <strong>Opposite (West)</strong>. "East to West" = Analogue‚ÜíOpposite = <strong>Opposite (West)</strong>. West = West ‚Üí <strong>True</strong>. If operators differ, it's False. If both are orthogonal (no relationship), it's True.</dd>
                        <dt><strong>Q (Level 6):</strong> What's an "orthogonal" relationship?</dt>
                        <dd><strong>A:</strong> No clear relationship exists. Example: North‚ÜíEast (Up-shift‚ÜíAnalogue) has no operator because they're perpendicular concepts. If <strong>both</strong> pairs are orthogonal, the premise is True (None = None).</dd>
                        <dt><strong>Q (Level 6):</strong> How does n-back matching work for META premises?</dt>
                        <dd><strong>A:</strong> Match on <strong>truth value</strong>, not operators. If n-back premise was True and current premise is True ‚Üí MATCH. If n-back was False and current is False ‚Üí MATCH. Different truth values ‚Üí NO MATCH.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> What if I can't think of a good semantic anchor?</dt>
                        <dd><strong>A:</strong> Use the directional concept as a guide. For North (Up-shift), think: mature‚Üíimmature, complex‚Üísimple, whole‚Üípart. For South (Down-shift), reverse it. For East (Analogue), think: siblings, parallel roles, same category. For West (Opposite), think: antonyms, counter-roles, complementary pairs.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Does it matter what semantic anchors I choose?</dt>
                        <dd><strong>A:</strong> Not to the system‚Äîit never sees them! Choose anchors that are <strong>vivid and memorable to YOU</strong>. The cognitive load comes from generating AND remembering YOUR specific mental anchors across n-back trials.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Should I use the same anchors throughout a session?</dt>
                        <dd><strong>A:</strong> It helps! If J := "Fact" in trial 1, keeping it as "Fact" throughout makes recall easier. But you can also challenge yourself by creating fresh anchors each trial.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Can I write down my semantic anchors?</dt>
                        <dd><strong>A:</strong> You can, but that defeats the purpose! The cognitive training comes from maintaining these anchors <strong>in working memory only</strong>. Writing them down is like using a calculator instead of doing mental math.</dd>
                    </dl>
                `,
                speech: 'Pitfalls and FAQ. Question: Can I use the same word for East, the analogue? Answer: Prefer siblings, not duplicates. Candle to Lantern, not Candle to Candle. Question: My West choice feels too cartoonish. Answer: Opposite includes counter-role or antagonist, not just antonym. Order to Chaos. Plan to Improvisation. Question: What if my mapping breaks later? Answer: Use a Reframe action. Log it. Consistency matters more than stubbornness. Question: Do analogies change scoring? Answer: No. Scoring is formal. Analogies train your semantic agility. Question, Level six: How do I know if a META premise is true or false? Answer: Deduce the hidden operator for each pair. Example: North to South equals Up-shift to Down-shift equals Opposite, West. East to West equals Analogue to Opposite equals Opposite, West. West equals West, so True. If operators differ, it is False. If both are orthogonal, no relationship, it is True. Question, Level six: What is an orthogonal relationship? Answer: No clear relationship exists. Example: North to East, Up-shift to Analogue, has no operator because they are perpendicular concepts. If both pairs are orthogonal, the premise is True, None equals None. Question, Level six: How does n-back matching work for META premises? Answer: Match on truth value, not operators. If n-back premise was True and current premise is True, MATCH. If n-back was False and current is False, MATCH. Different truth values, NO MATCH. Question, Level seven: What if I cannot think of a semantic pair? Answer: Use the concept hint shown in the modal. For North, Up-shift, think mature to immature, complex to simple. For South, reverse it. For East, think siblings, parallel roles. For West, think antonyms, counter-roles. Question, Level seven: Does it matter what semantic pairs I choose? Answer: Yes! They must match the operator concept. The system validates this. But within valid pairs, your choice is what matters. The cognitive load comes from generating and remembering your specific choices across n-back trials. Question, Level seven: Do I have to remember my semantic pairs from previous trials? Answer: Yes! That is the entire point. When evaluating n-back matches, you should recall what you anchored n trials ago. This generative working memory demand is what creates maximum g-load. Question, Level seven: Can I write down my semantic pairs? Answer: The system displays them with each premise, so you will see them. But for maximum training effect, try to recall them from memory first, then verify with the display.'
            },
            {
                id: 'glossary',
                title: 'Glossary',
                html: `
                    <h3>Glossary</h3>
                    <ul>
                        <li><strong>Arc of Abstraction:</strong> the mental continuum from concrete/particular to abstract/general.</li>
                        <li><strong>Up-shift / Down-shift:</strong> moves along the Arc (North/South).</li>
                        <li><strong>Analogue / Opposite:</strong> lateral moves preserving or inverting role (East/West).</li>
                        <li><strong>Anchor:</strong> your chosen seed concept for a letter.</li>
                        <li><strong>Compound mapping:</strong> a single letter carrying a composed phrase to satisfy multiple relations (e.g., "chaotic example").</li>
                        <li><strong>Reframe:</strong> deliberate change to an anchored concept, logged for consistency tracking.</li>
                        <li><strong>META_RELATIONAL premise (Level 6):</strong> a pure operator analogy comparing relationships between operators (e.g., "North to South as East to West"). No letters, only compass directions.</li>
                        <li><strong>Truth value:</strong> whether a META premise evaluates to True or False. True if both operator pairs deduce to the same relationship (or both orthogonal). False otherwise.</li>
                        <li><strong>Orthogonal relationship:</strong> when two operators have no clear relationship (neither same concept nor opposite). Example: Up-shift (North) to Analogue (East) = orthogonal.</li>
                        <li><strong>Deduced operator:</strong> the hidden relationship between two operators. North‚ÜíSouth (Up-shift‚ÜíDown-shift) deduces to West (Opposite).</li>
                        <li><strong>Semantic anchoring:</strong> a mental strategy where you anchor abstract letters to concrete concepts from your lived experience, then apply directional transformations. Example: J := "Fact", North(J‚ÜíN) = "Fact"‚Üí"Theory".</li>
                        <li><strong>Arc of Abstraction:</strong> the spectrum from concrete lived experience to abstract concepts. Semantic anchoring uses this arc to make abstract premises meaningful.</li>
                        <li><strong>Mental transformation:</strong> applying directional operators to your semantic anchors in your head. Example: South("Theory") = down-shift ‚Üí "Example".</li>
                    </ul>
                `,
                speech: 'Glossary. Arc of Abstraction: the mental continuum from concrete or particular to abstract or general. Up-shift and Down-shift: moves along the arc, north and south. Analogue and Opposite: lateral moves preserving or inverting role, east and west. Anchor: your chosen seed concept for a letter. Compound mapping: a single letter carrying a composed phrase to satisfy multiple relations, for example Chaotic example. Reframe: deliberate change to an anchored concept, logged for consistency tracking. META RELATIONAL premise, Level six: a pure operator analogy comparing relationships between operators, for example North to South as East to West. No letters, only compass directions. Truth value: whether a META premise evaluates to true or false. True if both operator pairs deduce to the same relationship, or both orthogonal. False otherwise. Orthogonal relationship: when two operators have no clear relationship, neither same concept nor opposite. Example: Up-shift North to Analogue East equals orthogonal. Deduced operator: the hidden relationship between two operators. North to South, Up-shift to Down-shift, deduces to West, Opposite. User semantics, Level seven: your own imagination-generated semantic pairs anchoring META operators to concrete concepts, for example North to South equals Teacher to Student. Generative anchoring: creating semantic pairs from imagination rather than selecting from provided options. Maximizes cognitive load. Semantic validation: checking that your generated semantic pair matches the operator concept, for example Teacher to Student must match North Up-shift concept.'
            },
            {
                id: 'level6',
                title: 'Level 6: Meta-Relational Analogy',
                html: `
                    <h3>Level 6: Meta-Relational Analogy (The 'g' Leap)</h3>
                    <p>This is <strong>peak fluid intelligence training</strong>. Level 6 introduces a completely new premise type: <strong>pure operator analogies</strong>.</p>

                    <h4>What You'll See</h4>
                    <p>Instead of letter-based premises like "A is north of B", you'll see:</p>
                    <p style="text-align: center; font-size: 1.2rem; color: #3498db; margin: 20px 0;"><code>"North to South as East to West"</code></p>
                    <p>No letters. Just operators. This is a <strong>6th-order relational statement</strong>‚Äîan analogy of relations.</p>

                    <h4>How to Evaluate</h4>
                    <ol>
                        <li><strong>Map operators to concepts:</strong>
                            <ul>
                                <li>North = Up-shift</li>
                                <li>South = Down-shift</li>
                                <li>East = Analogue</li>
                                <li>West = Opposite</li>
                            </ul>
                        </li>
                        <li><strong>Deduce the relationship for each pair:</strong>
                            <ul>
                                <li>"North to South" = Up-shift ‚Üí Down-shift = <strong>Opposite (West)</strong></li>
                                <li>"East to West" = Analogue ‚Üí Opposite = <strong>Opposite (West)</strong></li>
                            </ul>
                        </li>
                        <li><strong>Compare the deduced operators:</strong>
                            <ul>
                                <li>West = West ‚Üí Premise is <strong>TRUE</strong></li>
                            </ul>
                        </li>
                    </ol>

                    <h4>Deduction Rules</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 10px; border: 1px solid #555;">From ‚Üí To</th>
                            <th style="padding: 10px; border: 1px solid #555;">Deduced Operator</th>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Up-shift ‚Üí Down-shift (N‚ÜíS)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Down-shift ‚Üí Up-shift (S‚ÜíN)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Analogue ‚Üí Opposite (E‚ÜíW)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Opposite ‚Üí Analogue (W‚ÜíE)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Up-shift ‚Üí Up-shift (N‚ÜíN)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>East</strong> (Analogue)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Any same ‚Üí same</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>East</strong> (Analogue)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Up/Down ‚Üí Analogue/Opposite</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>None</strong> (Orthogonal)</td>
                        </tr>
                    </table>

                    <h4>N-Back Matching</h4>
                    <p>Matches are based on <strong>truth value</strong>, not operators:</p>
                    <ul>
                        <li><strong>MATCH:</strong> Both TRUE or both FALSE</li>
                        <li><strong>NO MATCH:</strong> One TRUE, one FALSE</li>
                    </ul>

                    <h4>Practice Examples</h4>
                    <p><strong>Example 1:</strong> <code>North to East as South to West</code></p>
                    <ul>
                        <li>N‚ÜíE: Up-shift ‚Üí Analogue = <strong>None</strong> (orthogonal)</li>
                        <li>S‚ÜíW: Down-shift ‚Üí Opposite = <strong>None</strong> (orthogonal)</li>
                        <li>None = None ‚Üí <strong>TRUE</strong></li>
                    </ul>

                    <p><strong>Example 2:</strong> <code>North to South as North to East</code></p>
                    <ul>
                        <li>N‚ÜíS: Up-shift ‚Üí Down-shift = <strong>West</strong></li>
                        <li>N‚ÜíE: Up-shift ‚Üí Analogue = <strong>None</strong></li>
                        <li>West ‚â† None ‚Üí <strong>FALSE</strong></li>
                    </ul>

                    <p><strong>Example 3:</strong> <code>East to East as West to West</code></p>
                    <ul>
                        <li>E‚ÜíE: Analogue ‚Üí Analogue = <strong>East</strong></li>
                        <li>W‚ÜíW: Opposite ‚Üí Opposite = <strong>East</strong></li>
                        <li>East = East ‚Üí <strong>TRUE</strong></li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Check the <strong>"Force Meta-Relational Trials (Level 6: g-Leap)"</strong> checkbox in the controls panel before starting a session.</p>
                `,
                speech: 'Level Six: Meta-Relational Analogy, The g-Leap. This is peak fluid intelligence training. Level six introduces a completely new premise type: pure operator analogies. What You Will See: Instead of letter-based premises like A is north of B, you will see North to South as East to West. No letters, just operators. This is a sixth-order relational statement, an analogy of relations. How to Evaluate: Step one, Map operators to concepts. North equals Up-shift. South equals Down-shift. East equals Analogue. West equals Opposite. Step two, Deduce the relationship for each pair. North to South equals Up-shift to Down-shift equals Opposite, West. East to West equals Analogue to Opposite equals Opposite, West. Step three, Compare the deduced operators. West equals West, so the premise is TRUE. Deduction Rules: Up-shift to Down-shift, North to South, deduces to West, Opposite. Down-shift to Up-shift, South to North, deduces to West, Opposite. Analogue to Opposite, East to West, deduces to West, Opposite. Opposite to Analogue, West to East, deduces to West, Opposite. Any same to same deduces to East, Analogue. Up or Down to Analogue or Opposite deduces to None, Orthogonal. N-Back Matching: Matches are based on truth value, not operators. MATCH when both TRUE or both FALSE. NO MATCH when one TRUE and one FALSE. How to Enable: Check the Force Meta-Relational Trials, Level six g-Leap, checkbox in the controls panel before starting a session.'
            },
            {
                id: 'level7',
                title: 'Level 7: Compound Operator Relational',
                html: `
                    <h3>Level 7: Compound Operator Relational (Maximum g-Load)</h3>
                    <p>This is the <strong>ultimate cognitive challenge</strong>‚Äîcombining abstract operator sequences, semantic anchoring, meta-relational reasoning, and working memory into a single unified task. Level 7 achieves <strong>7th-order reasoning</strong>.</p>

                    <h4>The Concept</h4>
                    <p>Level 7 premises look like this: <code>"north-west is north of south-east"</code></p>
                    <p>This combines:</p>
                    <ul>
                        <li><strong>Compound operators:</strong> "north-west" is a sequence of transformations (north, then west)</li>
                        <li><strong>Meta-relationships:</strong> The compound operators themselves are related by a meta-operator (north)</li>
                        <li><strong>Semantic anchoring:</strong> You mentally anchor and transform concepts through the sequences</li>
                        <li><strong>Abstract pairing:</strong> The two compound operators form a unified relational structure</li>
                    </ul>

                    <h4>How It Works (Purely Mental)</h4>
                    <p><strong>Example: "north-west is north of south-east"</strong></p>
                    <ol>
                        <li><strong>Pick a seed concept for left side:</strong> "Order"</li>
                        <li><strong>Apply north-west transformation:</strong>
                            <ul>
                                <li>North(Order) = up-shift ‚Üí "System" (generalization)</li>
                                <li>West(System) = opposite ‚Üí "Chaos" (counterpart)</li>
                                <li><strong>Result:</strong> north-west := "Chaos"</li>
                            </ul>
                        </li>
                        <li><strong>Pick a seed concept for right side:</strong> "Calm"</li>
                        <li><strong>Apply south-east transformation:</strong>
                            <ul>
                                <li>South(Calm) = down-shift ‚Üí "Stillness" (concrete instance)</li>
                                <li>East(Stillness) = analogue ‚Üí "Peace" (sibling concept)</li>
                                <li><strong>Result:</strong> south-east := "Peace"</li>
                            </ul>
                        </li>
                        <li><strong>Evaluate meta-relationship:</strong>
                            <ul>
                                <li>Is "Chaos" north of "Peace"?</li>
                                <li>Is Chaos a generalization of Peace?</li>
                                <li><strong>Your judgment:</strong> Perhaps... Chaos is a broader state that can contain peaceful moments?</li>
                            </ul>
                        </li>
                        <li><strong>Decide: MATCH or NO MATCH</strong> (based on your semantic model)</li>
                    </ol>

                    <h4>The 7th-Order Reasoning</h4>
                    <p>This achieves 7 layers of abstraction:</p>
                    <ol>
                        <li><strong>1st-order:</strong> Concrete concepts (Order, Calm, Chaos, Peace)</li>
                        <li><strong>2nd-order:</strong> Basic transformations (north = up-shift, west = opposite)</li>
                        <li><strong>3rd-order:</strong> Sequential composition (north-west = up-shift then opposite)</li>
                        <li><strong>4th-order:</strong> Compound transformations as entities (north-west becomes "Chaos")</li>
                        <li><strong>5th-order:</strong> Meta-relationships between entities (Chaos is north of Peace)</li>
                        <li><strong>6th-order:</strong> Abstract pairing (north-west and south-east form unified structure)</li>
                        <li><strong>7th-order:</strong> Self-generated semantic evaluation across n-back trials</li>
                    </ol>

                    <h4>k Parameter Controls Complexity</h4>
                    <p>The k slider controls <strong>number of compound atoms per premise</strong> (just like in atomic mode):</p>
                    <ul>
                        <li><strong>k=1:</strong> Single compound atom (e.g., "north-west is south of east-north")</li>
                        <li><strong>k=2:</strong> Two compound atoms (e.g., "north-west is south of east-north; north-west is east of south-west")</li>
                        <li><strong>k=3:</strong> Three compound atoms</li>
                        <li><strong>k=4:</strong> Four compound atoms</li>
                    </ul>
                    <p>Note: Compound operators are <strong>always 2 operators</strong> (like "north-west"). Higher k creates multi-atom premises where compound operators appear in multiple relationships.</p>

                    <h4>N-Back Matching</h4>
                    <p>Because there's no formal truth value (evaluation is semantic), matching works differently:</p>
                    <ul>
                        <li>You make a judgment: MATCH or NO MATCH (based on your mental model)</li>
                        <li>System tracks YOUR judgment</li>
                        <li>N trials later, you must <strong>recall YOUR previous judgment</strong></li>
                        <li>If current and n-back both MATCH ‚Üí correct response is MATCH</li>
                        <li>If both NO MATCH ‚Üí correct response is MATCH</li>
                        <li>If one MATCH and one NO MATCH ‚Üí correct response is NO MATCH</li>
                    </ul>

                    <h4>Why This is Maximum g-Load</h4>
                    <p>Level 7 combines ALL cognitive demands simultaneously:</p>
                    <ol>
                        <li><strong>Sequential transformation:</strong> Apply 2-4 operators in sequence</li>
                        <li><strong>Semantic anchoring:</strong> Generate mental concepts for seeds</li>
                        <li><strong>Working memory:</strong> Maintain transformation state across steps</li>
                        <li><strong>Meta-reasoning:</strong> Evaluate relationships between compound results</li>
                        <li><strong>Abstract pairing:</strong> Unified relational structure (not separate examples)</li>
                        <li><strong>Subjective judgment:</strong> No formal answer‚Äîtrust your mental model</li>
                        <li><strong>N-back recall:</strong> Remember YOUR judgments across trials</li>
                    </ol>

                    <h4>Tips for Success</h4>
                    <ul>
                        <li><strong>Visualize the transformations:</strong> Actually imagine each step (Order‚ÜíSystem‚ÜíChaos)</li>
                        <li><strong>Use vivid seeds:</strong> Pick concrete concepts you can mentally manipulate</li>
                        <li><strong>Trust your intuition:</strong> There's no "correct" answer‚Äîyour semantic model is what matters</li>
                        <li><strong>Be consistent:</strong> Use similar seed types to maintain coherence</li>
                        <li><strong>Track your pattern:</strong> Notice if you tend to say MATCH or NO MATCH more often</li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Check the <strong>"Force Compound Operator Trials (Level 7: Maximum g-Load)"</strong> checkbox in the controls panel before starting a session. This automatically disables Level 6 (they're mutually exclusive).</p>

                    <p><strong>Recommended settings for maximum challenge:</strong> n=5, k=4 (5-back with 4 compound atoms per premise)</p>
                `,
                speech: 'Level Seven: Compound Operator Relational, Maximum g-Load. This is the ultimate cognitive challenge, combining abstract operator sequences, semantic anchoring, meta-relational reasoning, and working memory into a single unified task. Level seven achieves seventh-order reasoning. The Concept: Level seven premises look like this: north-west is north of south-east. This combines compound operators like north-west which is a sequence of exactly two transformations, meta-relationships where compound operators are related by a meta-operator, semantic anchoring where you mentally anchor and transform concepts through sequences, and abstract pairing where the two compound operators form a unified relational structure. How It Works, Purely Mental: Example: north-west is north of south-east. Step one, Pick a seed concept for left side: Order. Step two, Apply north-west transformation: North of Order equals up-shift to System. West of System equals opposite to Chaos. Result: north-west equals Chaos. Step three, Pick a seed concept for right side: Calm. Step four, Apply south-east transformation: South of Calm equals down-shift to Stillness. East of Stillness equals analogue to Peace. Result: south-east equals Peace. Step five, Evaluate meta-relationship: Is Chaos north of Peace? Is Chaos a generalization of Peace? Your judgment decides. Step six, Decide: MATCH or NO MATCH based on your semantic model. Why This is Maximum g-Load: Level seven combines all cognitive demands simultaneously. Sequential transformation: apply two operators in sequence for each compound. Semantic anchoring: generate mental concepts for seeds. Working memory: maintain transformation state across steps. Meta-reasoning: evaluate relationships between compound results. Abstract pairing: unified relational structure, not separate examples. Subjective judgment: no formal answer, trust your mental model. N-back recall: remember your judgments across trials. How to Enable: Check the Force Compound Operator Trials, Level seven Maximum g-Load, checkbox in the controls panel before starting a session. Recommended settings for maximum challenge: n equals five, k equals four, five-back with four compound atoms per premise.'
            },
            {
                id: 'walkthrough-n2-10',
                title: 'n-Back-2: 10-Trial Walkthrough',
                html: '',
                render: (mount) => renderWalkthroughN2(mount),
                speech: walkthroughN2SpeechText()
            }
        ];

        let guidedExamplesRoot = null;

        function renderGuidedExamples() {
            const mount = document.getElementById('instContent');
            if (!mount) return;

            if (guidedExamplesRoot && mount.dataset.examplesLoaded === '1') {
                mount.innerHTML = '';
                mount.appendChild(guidedExamplesRoot);
                return;
            }

            const examples = getBeginnerExamples();
            const container = document.createElement('div');
            container.id = 'guidedExamples';

            const heading = document.createElement('h3');
            heading.textContent = 'Guided Examples';
            container.appendChild(heading);

            const intro = document.createElement('p');
            intro.textContent = 'Study thirty beginner-friendly mappings. Anchor each letter, follow the compass moves, and confirm the resulting mapping with the provided rationale.';
            container.appendChild(intro);

            const filters = document.createElement('div');
            filters.id = 'examplesFilters';
            filters.innerHTML = `
                <strong>Filter:</strong>
                <button data-f="all" class="active">All</button>
                <button data-f="single">Single-atom</button>
                <button data-f="double-same-head">Two-atom (same head)</button>
                <button data-f="double-dual-head">Two-atom (dual heads)</button>
                <button data-f="triple-chain">Three-atom chains</button>
                <button data-f="quad">Four-atom sets</button>
            `;
            container.appendChild(filters);

            const list = document.createElement('ol');
            list.id = 'examplesList';
            container.appendChild(list);

            function renderList(filter = 'all') {
                list.innerHTML = '';
                examples
                    .filter(ex => filter === 'all' ? true : ex.level === filter)
                    .forEach(ex => {
                        const li = document.createElement('li');
                        li.className = `ex ex-${ex.level}`;
                        li.innerHTML = `
                            <h4>Ex ${ex.id}. ${ex.theme}</h4>
                            <p><strong>Premise:</strong> ${ex.premise}</p>
                            <p><strong>Anchors:</strong> ${ex.anchors.map(([L, c]) => `${L} := "${c}"`).join('; ')}</p>
                            <p><strong>Transforms:</strong> ${ex.transforms.join(' ‚Ä¢ ')}</p>
                            <p><strong>Resulting mapping:</strong> ${ex.mapping.map(([L, c]) => `${L} ‚Üí "${c}"`).join('; ')}</p>
                            <p><em>Why it works:</em> ${ex.rationale}</p>
                            <div class="exActions">
                                <button data-speak="${ex.id}">Speak summary</button>
                                <button data-copy="${ex.id}">Copy to clipboard</button>
                            </div>
                        `;
                        list.appendChild(li);
                    });
            }

            renderList('all');

            container.addEventListener('click', (event) => {
                const button = event.target.closest('button');
                if (!button) return;
                const filter = button.dataset.f;
                if (filter) {
                    container.querySelectorAll('#examplesFilters button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    renderList(filter);
                    return;
                }
                if (button.dataset.speak) {
                    const id = parseInt(button.dataset.speak, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        speakOnce(summarizeExample(example));
                    }
                }
                if (button.dataset.copy) {
                    const id = parseInt(button.dataset.copy, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        const summary = summarizeExample(example);
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            navigator.clipboard.writeText(summary).catch(() => {
                                window.prompt('Copy this example summary:', summary);
                            });
                        } else {
                            window.prompt('Copy this example summary:', summary);
                        }
                    }
                }
            });

            function summarizeExample(ex) {
                const line1 = `Premise: ${ex.premise}`;
                const line2 = `Anchors: ${ex.anchors.map(([L, c]) => `${L} equals ${c}`).join('; ')}.`;
                const line3 = `Mapping: ${ex.mapping.map(([L, c]) => `${L} to ${c}`).join('; ')}.`;
                return `${line1} ${line2} ${line3}`;
            }

            mount.innerHTML = '';
            mount.appendChild(container);
            mount.dataset.examplesLoaded = '1';
            guidedExamplesRoot = container;
        }

        function getBeginnerExamples() {
            return [
                // --- Single-atom (10) ---
                { id:1, level:"single", theme:"Learning ‚Äî Up-shift",
                  premise:"N is north of J.",
                  anchors:[["J","Fact"]],
                  transforms:["North(J‚ÜíN): up-shift Fact ‚Üí Theory"],
                  mapping:[["J","Fact"],["N","Theory"]],
                  rationale:"North is higher abstraction; Theory stands above Fact."
                },
                { id:2, level:"single", theme:"Biology ‚Äî Down-shift",
                  premise:"B is south of A.",
                  anchors:[["A","Animal"]],
                  transforms:["South(A‚ÜíB): down-shift Animal ‚Üí Dog"],
                  mapping:[["A","Animal"],["B","Dog"]],
                  rationale:"South is more specific; Dog is an instance of Animal."
                },
                { id:3, level:"single", theme:"Illumination ‚Äî Analogue",
                  premise:"C is east of D.",
                  anchors:[["D","Candle"]],
                  transforms:["East(D‚ÜíC): analogue of Candle ‚Üí Lantern"],
                  mapping:[["D","Candle"],["C","Lantern"]],
                  rationale:"East is same-role/sibling; Lantern parallels Candle."
                },
                { id:4, level:"single", theme:"Order/Chaos ‚Äî Opposite",
                  premise:"E is west of F.",
                  anchors:[["F","Order"]],
                  transforms:["West(F‚ÜíE): opposite of Order ‚Üí Chaos"],
                  mapping:[["F","Order"],["E","Chaos"]],
                  rationale:"West is counterpart; Chaos opposes Order."
                },
                { id:5, level:"single", theme:"Technology ‚Äî Up-shift",
                  premise:"G is north of H.",
                  anchors:[["H","Program"]],
                  transforms:["North(H‚ÜíG): Program ‚Üí Platform"],
                  mapping:[["H","Program"],["G","Platform"]],
                  rationale:"Platform generalizes programs; higher on the Arc."
                },
                { id:6, level:"single", theme:"Music ‚Äî Down-shift",
                  premise:"I is south of K.",
                  anchors:[["K","Song"]],
                  transforms:["South(K‚ÜíI): Song ‚Üí Verse"],
                  mapping:[["K","Song"],["I","Verse"]],
                  rationale:"Verse is a component of a Song."
                },
                { id:7, level:"single", theme:"Navigation ‚Äî Analogue",
                  premise:"L is east of M.",
                  anchors:[["M","Map"]],
                  transforms:["East(M‚ÜíL): Map ‚Üí Chart"],
                  mapping:[["M","Map"],["L","Chart"]],
                  rationale:"Chart is a sibling format to Map."
                },
                { id:8, level:"single", theme:"Emotion ‚Äî Opposite",
                  premise:"P is west of O.",
                  anchors:[["O","Calm"]],
                  transforms:["West(O‚ÜíP): Calm ‚Üí Agitation"],
                  mapping:[["O","Calm"],["P","Agitation"]],
                  rationale:"Agitation is the counter-state of Calm."
                },
                { id:9, level:"single", theme:"Finance ‚Äî Up-shift",
                  premise:"Q is north of R.",
                  anchors:[["R","Expense"]],
                  transforms:["North(R‚ÜíQ): Expense ‚Üí Budget"],
                  mapping:[["R","Expense"],["Q","Budget"]],
                  rationale:"Budget organizes expenses; higher level."
                },
                { id:10, level:"single", theme:"Astronomy ‚Äî Down-shift",
                  premise:"T is south of S.",
                  anchors:[["S","Galaxy"]],
                  transforms:["South(S‚ÜíT): Galaxy ‚Üí Star"],
                  mapping:[["S","Galaxy"],["T","Star"]],
                  rationale:"A Star is a constituent of a Galaxy."
                },

                // --- Two-atom: same head (8) ---
                { id:11, level:"double-same-head", theme:"Theory & Order ‚Äî Compound",
                  premise:"Z is south of J; Z is west of P.",
                  anchors:[["J","Theory"],["P","Order"]],
                  transforms:["South(J‚ÜíZ): Theory ‚Üí Example","West(P‚ÜíZ): Order ‚Üí Chaos (compound: Chaotic example)"],
                  mapping:[["J","Theory"],["P","Order"],["Z","Chaotic example"]],
                  rationale:"Z must satisfy both; a 'Chaotic example' fits down-shift and opposition."
                },
                { id:12, level:"double-same-head", theme:"Writing ‚Äî Paragraph role",
                  premise:"A is north of B; A is east of C.",
                  anchors:[["B","Sentence"],["C","Section"]],
                  transforms:["North(B‚ÜíA): Sentence ‚Üí Paragraph","East(C‚ÜíA): Section ‚Üí Paragraph (sibling)"],
                  mapping:[["B","Sentence"],["C","Section"],["A","Paragraph"]],
                  rationale:"Paragraph stands above a Sentence and parallels a Section in function."
                },
                { id:13, level:"double-same-head", theme:"Physics ‚Äî Heat vs Cold",
                  premise:"D is south of C; D is west of E.",
                  anchors:[["C","Energy"],["E","Cold"]],
                  transforms:["South(C‚ÜíD): Energy ‚Üí Heat","West(E‚ÜíD): Cold ‚Üí Heat"],
                  mapping:[["C","Energy"],["E","Cold"],["D","Heat"]],
                  rationale:"Heat is a specific form of Energy and the counter to Cold."
                },
                { id:14, level:"double-same-head", theme:"Light ‚Äî Coherent mapping",
                  premise:"H is east of I; H is north of J.",
                  anchors:[["I","Lamp"],["J","Flame"]],
                  transforms:["East(I‚ÜíH): Lamp ‚Üí Lantern","North(J‚ÜíH): Flame ‚Üí Lantern (higher containment)"],
                  mapping:[["I","Lamp"],["J","Flame"],["H","Lantern"]],
                  rationale:"Lantern is a sibling of Lamp, and stands above Flame as container/assembly."
                },
                { id:15, level:"double-same-head", theme:"Ethics ‚Äî Lying as behavior",
                  premise:"K is west of L; K is south of M.",
                  anchors:[["L","Truth"],["M","Behavior"]],
                  transforms:["West(L‚ÜíK): Truth ‚Üí Lie","South(M‚ÜíK): Behavior ‚Üí Lie"],
                  mapping:[["L","Truth"],["M","Behavior"],["K","Lie"]],
                  rationale:"A Lie opposes Truth and is a specific Behavior."
                },
                { id:16, level:"double-same-head", theme:"Literature ‚Äî Forms",
                  premise:"N is east of O; N is south of P.",
                  anchors:[["O","Novel"],["P","Literature"]],
                  transforms:["East(O‚ÜíN): Novel ‚Üí Short story","South(P‚ÜíN): Literature ‚Üí Short story"],
                  mapping:[["O","Novel"],["P","Literature"],["N","Short story"]],
                  rationale:"Short story is a sibling to Novel and a specific of Literature."
                },
                { id:17, level:"double-same-head", theme:"Civics ‚Äî Regulation vs Anarchy",
                  premise:"Q is north of R; Q is west of S.",
                  anchors:[["R","Procedure"],["S","Anarchy"]],
                  transforms:["North(R‚ÜíQ): Procedure ‚Üí Policy","West(S‚ÜíQ): Anarchy ‚Üí Policy"],
                  mapping:[["R","Procedure"],["S","Anarchy"],["Q","Policy"]],
                  rationale:"Policy sits above Procedure and opposes Anarchy's absence of rules."
                },
                { id:18, level:"double-same-head", theme:"Roles ‚Äî Medicine",
                  premise:"T is east of U; T is west of V.",
                  anchors:[["U","Doctor"],["V","Patient"]],
                  transforms:["East(U‚ÜíT): Doctor ‚Üí Physician","West(V‚ÜíT): Patient ‚Üí Physician (counter-role)"],
                  mapping:[["U","Doctor"],["V","Patient"],["T","Physician"]],
                  rationale:"Physician is a synonym/analogue of Doctor and the counter-role to Patient."
                },

                // --- Two-atom: dual heads (6) ---
                { id:19, level:"double-dual-head", theme:"Data & Tools",
                  premise:"W is north of X; Y is east of Z.",
                  anchors:[["X","Data"],["Z","Hammer"]],
                  transforms:["North(X‚ÜíW): Data ‚Üí Information","East(Z‚ÜíY): Hammer ‚Üí Tool"],
                  mapping:[["X","Data"],["W","Information"],["Z","Hammer"],["Y","Tool"]],
                  rationale:"Information abstracts Data; Tool parallels Hammer."
                },
                { id:20, level:"double-dual-head", theme:"Order & Nature",
                  premise:"A is west of B; C is south of D.",
                  anchors:[["B","Order"],["D","Tree"]],
                  transforms:["West(B‚ÜíA): Order ‚Üí Chaos","South(D‚ÜíC): Tree ‚Üí Branch"],
                  mapping:[["B","Order"],["A","Chaos"],["D","Tree"],["C","Branch"]],
                  rationale:"Chaos opposes Order; Branch is part of Tree."
                },
                { id:21, level:"double-dual-head", theme:"Transport & Cities",
                  premise:"E is east of F; G is north of H.",
                  anchors:[["F","Ship"],["H","Town"]],
                  transforms:["East(F‚ÜíE): Ship ‚Üí Boat (sibling craft)","North(H‚ÜíG): Town ‚Üí City"],
                  mapping:[["F","Ship"],["E","Boat"],["H","Town"],["G","City"]],
                  rationale:"Boat parallels Ship; City stands above Town."
                },
                { id:22, level:"double-dual-head", theme:"Light & Art",
                  premise:"I is west of J; K is east of L.",
                  anchors:[["J","Light"],["L","Poem"]],
                  transforms:["West(J‚ÜíI): Light ‚Üí Darkness","East(L‚ÜíK): Poem ‚Üí Song (sibling artform)"],
                  mapping:[["J","Light"],["I","Darkness"],["L","Poem"],["K","Song"]],
                  rationale:"Darkness is the counter-state to Light; Song parallels Poem."
                },
                { id:23, level:"double-dual-head", theme:"Systems & Life",
                  premise:"M is south of N; O is west of P.",
                  anchors:[["N","System"],["P","Life"]],
                  transforms:["South(N‚ÜíM): System ‚Üí Module","West(P‚ÜíO): Life ‚Üí Death"],
                  mapping:[["N","System"],["M","Module"],["P","Life"],["O","Death"]],
                  rationale:"Module is a part of a System; Death opposes Life."
                },
                { id:24, level:"double-dual-head", theme:"Food & Geography",
                  premise:"Q is east of R; S is south of T.",
                  anchors:[["R","Breakfast"],["T","Continent"]],
                  transforms:["East(R‚ÜíQ): Breakfast ‚Üí Brunch (analogue)","South(T‚ÜíS): Continent ‚Üí Country"],
                  mapping:[["R","Breakfast"],["Q","Brunch"],["T","Continent"],["S","Country"]],
                  rationale:"Brunch parallels Breakfast; Country is within a Continent."
                },

                // --- Three-atom chains (4) ---
                { id:25, level:"triple-chain", theme:"Logic ‚Äî Counterexample path",
                  premise:"A is south of B; C is east of A; D is west of C.",
                  anchors:[["B","Theory"]],
                  transforms:["South(B‚ÜíA): Theory ‚Üí Example","East(A‚ÜíC): Example ‚Üí Case study","West(C‚ÜíD): Case study ‚Üí Counterexample"],
                  mapping:[["B","Theory"],["A","Example"],["C","Case study"],["D","Counterexample"]],
                  rationale:"A down; C lateral sibling; D as foil to C‚Äîconsistent chain."
                },
                { id:26, level:"triple-chain", theme:"Projects ‚Äî Work breakdown",
                  premise:"E is north of F; G is south of E; H is east of G.",
                  anchors:[["F","Task"]],
                  transforms:["North(F‚ÜíE): Task ‚Üí Project","South(E‚ÜíG): Project ‚Üí Subtask","East(G‚ÜíH): Subtask ‚Üí Work item"],
                  mapping:[["F","Task"],["E","Project"],["G","Subtask"],["H","Work item"]],
                  rationale:"Up then down then sideways within the same work hierarchy."
                },
                { id:27, level:"triple-chain", theme:"Deception ‚Äî Roles",
                  premise:"I is west of J; K is north of I; L is east of K.",
                  anchors:[["J","Truth"]],
                  transforms:["West(J‚ÜíI): Truth ‚Üí Lie","North(I‚ÜíK): Lie ‚Üí Deception strategy","East(K‚ÜíL): Deception strategy ‚Üí Ruse"],
                  mapping:[["J","Truth"],["I","Lie"],["K","Deception strategy"],["L","Ruse"]],
                  rationale:"Counter-role, then abstraction, then sibling tactic."
                },
                { id:28, level:"triple-chain", theme:"Design ‚Äî Deliverables",
                  premise:"M is east of N; O is north of M; P is south of O.",
                  anchors:[["N","Sketch"]],
                  transforms:["East(N‚ÜíM): Sketch ‚Üí Outline","North(M‚ÜíO): Outline ‚Üí Design","South(O‚ÜíP): Design ‚Üí Wireframe"],
                  mapping:[["N","Sketch"],["M","Outline"],["O","Design"],["P","Wireframe"]],
                  rationale:"Analogue within drafting, then up to Design, then down to a specific artifact."
                },

                // --- Four-atom (2) ---
                { id:29, level:"quad", theme:"Learning ‚Äî Full weave",
                  premise:"H is east of R; Y is north of X; R is south of Y; Z is west of X.",
                  anchors:[["X","Fact"]],
                  transforms:[
                    "North(X‚ÜíY): Fact ‚Üí Theory",
                    "South(Y‚ÜíR): Theory ‚Üí Example",
                    "East(R‚ÜíH): Example ‚Üí Case study",
                    "West(X‚ÜíZ): Fact ‚Üí Fiction"
                  ],
                  mapping:[["X","Fact"],["Y","Theory"],["R","Example"],["H","Case study"],["Z","Fiction"]],
                  rationale:"Classic quartet: up from Fact, down to Example, lateral to Case study, counter to Fiction."
                },
                { id:30, level:"quad", theme:"Education ‚Äî Pedagogy weave",
                  premise:"A is west of D; B is north of A; C is east of B; D is south of C.",
                  anchors:[["A","Play"],["B","Pedagogy"],["C","Andragogy"]],
                  transforms:[
                    "Given A=Play; West requires D to be its structured counterpart ‚Üí Lesson",
                    "North(A‚ÜíB): Play ‚Üí Pedagogy (framework above)",
                    "East(B‚ÜíC): Pedagogy ‚Üí Andragogy (sibling adult-learning)",
                    "South(C‚ÜíD): Andragogy ‚Üí Lesson (specific instructional unit)"
                  ],
                  mapping:[["A","Play"],["B","Pedagogy"],["C","Andragogy"],["D","Lesson"]],
                  rationale:"Play vs Lesson as counter-styles; Pedagogy above Play; Andragogy as sibling to Pedagogy; Lesson as a concrete unit under Andragogy."
                }
            ];
        }

        function walkthroughN2SpeechText() {
            return [
                'n-back two, ten trial walkthrough.',
                'Algorithm reminder: symbol, map a thought, transform by the operation, pair letter and thought, repeat across atoms, recall and update prior pairings when letters return.',
                'Theme: illumination and understanding.',
                'Anchors: J equals Candle; D equals Fireworks; X equals Observation; Y equals Generalization; Z equals Anomaly.',
                'Trial one: D is north of J. Trial two: Z is west of X; Z is south of Y.',
                'Trial three: J is south of D. Match with trial one.',
                'Trial four: X is east of Z; Y is north of Z. Match with trial two.',
                'Trial five: D is east of J. No match with trial three.',
                'Trial six: Z is west of X; Z is south of Y. Match with trial four.',
                'Trial seven: J is west of D. Match with trial five.',
                'Trial eight: X is east of Z. No match with trial six.',
                'Trial nine: D is east of J. Match with trial seven.',
                'Trial ten: Z is west of X. Match with trial eight.',
                'When a letter returns, reuse its concept and update by the new relation; keep coherence across trials.'
            ].join(' ');
        }

        function renderWalkthroughN2(mount = document.getElementById('instContent')) {
            if (!mount) return;

            const html = `
            <div id="walkthroughN2" class="inst-section">
                <h3>n-Back-2: 10-Trial Walkthrough</h3>

                <p class="brandline"><strong>Imagi-World trains maximized imagination across the Arc of Abstraction.</strong> You map lived concepts onto letters and move them North/South/East/West while the logic engine keeps relations exact.</p>

                <h4>Quick Algorithm (repeat this every premise)</h4>
                <ol class="algo">
                    <li><strong>Symbol ‚Üí</strong> Note the letter(s) in the current premise.</li>
                    <li><strong>Map a thought ‚Üí</strong> Anchor each new letter to a vivid concept (your stream of consciousness).</li>
                    <li><strong>Transform ‚Üí</strong> Apply the premise operation to that concept: North = up-shift (more general/intense); South = down-shift (more specific/concrete); East = analogue/sibling; West = opposite/counter-role.</li>
                    <li><strong>Pairing ‚Üí</strong> Record the resulting <em>letter ‚Üî thought</em> pairing for this trial.</li>
                    <li><strong>Rinse/Repeat ‚Üí</strong> For multi-atom premises, repeat for each relation in the utterance (semicolon = tiny pause).</li>
                    <li><strong>Recall & Update ‚Üí</strong> When a letter reappears later, reuse its prior mapping and <em>update</em> it by the new relation (e.g., if K is north of J, then when P is above K you can infer new context linking P and J, too).</li>
                </ol>

                <h4>Theme for this walkthrough</h4>
                <p>We use a coherent theme: <em>Illumination &amp; Understanding</em>. First-time anchors:</p>
                <ul class="anchors">
                    <li>J := Candle (steady light)</li>
                    <li>D := Fireworks (intense/brief light)</li>
                    <li>X := Observation (raw sighting)</li>
                    <li>Y := Generalization (above observations)</li>
                    <li>Z := Anomaly (foil to a typical observation)</li>
                </ul>

                <h4>Ten Trials at n-Back-2 (MATCH means current ‚â° trial t‚àí2 under allowed inversions)</h4>

                <ol class="trials">
                    <li>
                        <p><strong>Trial 1 ‚Äî Premise:</strong> D is north of J.</p>
                        <p><strong>Mapping:</strong> J=Candle; North ‚Üí D=Fireworks (up-shift intensity).</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 2 ‚Äî Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> X=Observation; Y=Generalization; West ‚Üí Z=Anomaly (foil to typical observation); South from Y confirms Z is specific.</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 3 ‚Äî Premise:</strong> J is south of D.</p>
                        <p><strong>Mapping:</strong> Reuse J=Candle, D=Fireworks; South means Candle is less intense than Fireworks.</p>
                        <p><strong>n-back-2 vs Trial 1:</strong> <span class="match">MATCH</span> (inverse: D north of J ‚Üî J south of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 4 ‚Äî Premise:</strong> X is east of Z; Y is north of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Y, Z; East: Observation is a sibling to Anomaly; North: Generalization above Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 2:</strong> <span class="match">MATCH</span> (Z west of X ‚Üî X east of Z; Z south of Y ‚Üî Y north of Z).</p>
                    </li>
                    <li>
                        <p><strong>Trial 5 ‚Äî Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; East: both are light sources (analogue). Optionally note D as "burst light".</p>
                        <p><strong>n-back-2 vs Trial 3:</strong> <span class="nomatch">NO MATCH</span> (Trial 3 was South; axis mismatch, not an allowed inversion).</p>
                    </li>
                    <li>
                        <p><strong>Trial 6 ‚Äî Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> Same structure as Trial 2; reuse without re-anchoring.</p>
                        <p><strong>n-back-2 vs Trial 4:</strong> <span class="match">MATCH</span> (inverse pair of atoms holds).</p>
                    </li>
                    <li>
                        <p><strong>Trial 7 ‚Äî Premise:</strong> J is west of D.</p>
                        <p><strong>Mapping:</strong> Reuse J, D; West: Candle as counter to Fireworks (steady vs fleeting).</p>
                        <p><strong>n-back-2 vs Trial 5:</strong> <span class="match">MATCH</span> (D east of J ‚Üî J west of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 8 ‚Äî Premise:</strong> X is east of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Z; East: Observation as sibling to Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 6:</strong> <span class="nomatch">NO MATCH</span> (parity mismatch: k=1 vs k=2).</p>
                    </li>
                    <li>
                        <p><strong>Trial 9 ‚Äî Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; analogue relation sustained.</p>
                        <p><strong>n-back-2 vs Trial 7:</strong> <span class="match">MATCH</span> (inverse of Trial 7).</p>
                    </li>
                    <li>
                        <p><strong>Trial 10 ‚Äî Premise:</strong> Z is west of X.</p>
                        <p><strong>Mapping:</strong> Reuse Z, X; West: Anomaly as foil to Observation.</p>
                        <p><strong>n-back-2 vs Trial 8:</strong> <span class="match">MATCH</span> (inverse of Trial 8).</p>
                    </li>
                </ol>

                <h4>When the same letter returns: do this</h4>
                <ul class="returns">
                    <li><strong>Reuse</strong> the original concept; don't re-anchor.</li>
                    <li><strong>Check</strong> the new relation versus that concept (N up, S down, E analogue, W opposite).</li>
                    <li>If a letter must satisfy two relations, use a <em>compound nuance</em> ("chaotic example", "burst light") while keeping identity.</li>
                    <li><strong>Reframe</strong> only if the old choice breaks consistency across trials; if you reframe, note it.</li>
                    <li><strong>Infer context across letters:</strong> if K is north of J and P is above K, then P sits above J as well (transitively in your mental map). Keep your analogies coherent with such inferences while remembering the game's logical engine remains the final judge of matches.</li>
                </ul>

                <p class="closing"><strong>Mantra:</strong> Anchor ‚Üí Transform ‚Üí Cohere ‚Üí Commit ‚Üí Recall ‚Üí Update.</p>

                <div class="actions">
                    <button id="walkthroughN2Speak">Read this walkthrough aloud</button>
                    <button id="walkthroughN2Copy">Copy walkthrough text</button>
                </div>
            </div>
            `;

            mount.innerHTML = html;

            const speakBtn = mount.querySelector('#walkthroughN2Speak');
            const copyBtn = mount.querySelector('#walkthroughN2Copy');

            if (speakBtn) {
                speakBtn.addEventListener('click', () => {
                    if (typeof speakOnce === 'function') {
                        speakOnce(walkthroughN2SpeechText());
                    }
                });
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    const source = mount.querySelector('#walkthroughN2');
                    if (!source) return;
                    const text = source.innerText.trim();
                    try {
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            await navigator.clipboard.writeText(text);
                        } else {
                            window.prompt('Copy this walkthrough text:', text);
                        }
                    } catch (err) {
                        console.warn('Clipboard write failed', err);
                        window.prompt('Copy this walkthrough text:', text);
                    }
                });
            }
        }

        (function registerWalkthroughN2Tab() {
            const tabs = document.getElementById('instTabs');
            if (!tabs) return;
            if (tabs.querySelector('button[data-tab="walkthrough-n2-10"]')) {
                return;
            }
            const btn = document.createElement('button');
            btn.textContent = 'n-Back-2: 10-Trial Walkthrough';
            btn.setAttribute('data-tab', 'walkthrough-n2-10');
            tabs.appendChild(btn);
        })();

        async function speakOnce(text) {
            if (!text) return;
            if (!engine || !engine.voice || !engine.voice.voiceReady) return;
            if (typeof engine.voice.cancelAndWait === 'function') {
                await engine.voice.cancelAndWait();
            }
            engine.voice.speak(text, engine.voice.sessionToken);
        }

        const SANDBOX_TRANSFORMS = {
            N: {
                forward: (value) => `Up-shift(${value})`,
                reverse: (value) => `Down-shift(${value})`
            },
            S: {
                forward: (value) => `Down-shift(${value})`,
                reverse: (value) => `Up-shift(${value})`
            },
            E: {
                forward: (value) => `Analogue(${value})`,
                reverse: (value) => `Analogue(${value})`
            },
            W: {
                forward: (value) => `Opposite(${value})`,
                reverse: (value) => `Opposite(${value})`
            }
        };

        const AdvancePolicy = Object.freeze({ ACTIVE: 'active', LISTEN: 'listen' });
        let session = null;

        function makeEpoch() {
            const cryptoSource = (typeof crypto !== 'undefined' && crypto?.getRandomValues)
                ? crypto.getRandomValues(new Uint32Array(1))[0]
                : Date.now();
            const random = Math.floor(Math.random() * 1e9);
            return (cryptoSource ^ random) >>> 0;
        }

        function newSession(engine) {
            return {
                epoch: makeEpoch(),
                numTrials: engine.applyNumTrialsFromUI(),
                trialIndex: 0,
                policy: loadListenOnly() ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                abort: new AbortController(),
                trialToken: 0,
                phaseToken: 0,
                omissions: 0
            };
        }

        function valid(sess, trialToken, phaseToken) {
            // CRITICAL FIX: More defensive validation with detailed logging
            if (!session) {
                // Don't log this - it's normal during session transitions
                return false;
            }
            if (!sess) {
                console.warn('valid() failed: sess parameter is null/undefined');
                return false;
            }
            if (sess.epoch !== session.epoch) {
                // Don't log this - it's normal when a new session starts
                return false;
            }
            if (trialToken !== session.trialToken) {
                console.warn(`valid() failed: trialToken mismatch - expected ${session.trialToken}, got ${trialToken}`);
                return false;
            }
            if (phaseToken && phaseToken !== session.phaseToken) {
                // Don't log phase mismatches - they're common during async operations
                return false;
            }
            if (sess.abort && sess.abort.signal && sess.abort.signal.aborted) {
                // Don't log this - it's normal when session is being stopped
                return false;
            }
            return true;
        }

        const SpeechGate = {
            trialSpeakId: 0,
            inFlight: false,
            explicitRepeatPhase: 0,
            flightToken: null
        };

        function resetSpeechGateForTrial() {
            SpeechGate.trialSpeakId += 1;
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
        }

        function noteExplicitRepeat() {
            SpeechGate.explicitRepeatPhase += 1;
        }

        const TTSMon = { starts: 0, ends: 0 };

        function instrumentUtterance(utterance) {
            if (!utterance || typeof utterance.addEventListener !== 'function') {
                return;
            }
            utterance.addEventListener('start', () => { TTSMon.starts += 1; });
            utterance.addEventListener('end', () => { TTSMon.ends += 1; });
        }

        if (typeof window !== 'undefined') {
            window.SpeechGate = SpeechGate;
            window.TTSMon = TTSMon;
        }

        const Timer = (() => {
            let id = 0;
            const live = new Map();

            function clear(timerId) {
                const entry = live.get(timerId);
                if (!entry) return;
                clearTimeout(entry.handle);
                live.delete(timerId);
            }

            function set(label, ms, trialToken, signal, cb) {
                const timerId = ++id;
                const handle = setTimeout(() => {
                    live.delete(timerId);
                    // Always call callback - validation should be done by caller if needed
                    if (cb) cb();
                }, ms);
                live.set(timerId, { handle, label, trialToken, started: performance.now() });
                if (signal) {
                    signal.addEventListener('abort', () => clear(timerId), { once: true });
                }
                return timerId;
            }

            function cancelAll() {
                for (const entry of live.values()) {
                    clearTimeout(entry.handle);
                }
                live.clear();
            }

            return { set, clear, cancelAll, live };
        })();

        let heartbeat = null;

        function clearHeartbeat() {
            if (heartbeat) {
                clearInterval(heartbeat);
                heartbeat = null;
            }
        }

        function loadNumTrials() {
            const v = parseInt(localStorage.getItem(NUM_TRIALS_KEY) || '20', 10);
            const clamped = Math.min(10000, Math.max(1, isNaN(v) ? 20 : v));
            numTrialsInput.value = String(clamped);
            numTrialsSlider.value = String(Math.min(500, clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            return clamped;
        }

        function persistNumTrials(v) {
            const clamped = Math.min(10000, Math.max(1, v | 0));
            localStorage.setItem(NUM_TRIALS_KEY, String(clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            if (clamped <= 500) numTrialsSlider.value = String(clamped);
            numTrialsInput.value = String(clamped);
            return clamped;
        }

        numTrialsInput.addEventListener('change', () => {
            const value = parseInt(numTrialsInput.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        numTrialsSlider.addEventListener('input', () => {
            const value = parseInt(numTrialsSlider.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        const initialNumTrials = loadNumTrials();

        function sessionDefaults() {
            return {
                state: "STOPPED",
                trialIndex: 0,
                numTrials: initialNumTrials,
                seedSession: null,
                n: parseInt(document.getElementById('n-slider').value, 10),
                k: parseInt(document.getElementById('k-slider').value, 10),
                secondsPerTrial: parseFloat(document.getElementById('spt-slider').value)
            };
        }


        function cryptoRandom32() {
            if (window.crypto && window.crypto.getRandomValues) {
                const arr = new Uint32Array(1);
                window.crypto.getRandomValues(arr);
                return arr[0] >>> 0;
            }

            let x = Date.now() ^ Math.floor(Math.random() * 0xffffffff);
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            return x >>> 0;
        }

        function fnv1aHash(parts) {
            let hash = 0x811c9dc5;
            for (const part of parts) {
                const value = (part >>> 0);
                hash ^= value;
                hash = Math.imul(hash, 0x01000193);
            }
            return hash >>> 0;
        }

        class Mulberry32 {
            constructor(seed) {
                this.state = seed >>> 0;
            }

            next() {
                let t = this.state += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }

            shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            weightedChoice(items, weights) {
                const cumulative = [];
                let total = 0;
                for (const weight of weights) {
                    total += weight;
                    cumulative.push(total);
                }
                const r = this.next() * total;
                for (let i = 0; i < cumulative.length; i++) {
                    if (r <= cumulative[i]) return items[i];
                }
                return items[items.length - 1];
            }

            nextBetween(min, max) {
                return min + (max - min) * this.next();
            }
        }

        class SeedManager {
            constructor() {
                this.runCounterKey = 'relational-nback-run-counter';
                this.seedKey = 'relational-nback-last-seed';
                this.lockKey = 'relational-nback-lock-seed';
                this.sessionSeed = null;
                this.runCounter = this.loadRunCounter();
            }

            loadRunCounter() {
                const raw = localStorage.getItem(this.runCounterKey);
                const parsed = raw ? parseInt(raw, 10) : 0;
                return Number.isFinite(parsed) ? parsed : 0;
            }

            getLockPreference() {
                return localStorage.getItem(this.lockKey) === 'true';
            }

            setLockPreference(lock) {
                localStorage.setItem(this.lockKey, lock ? 'true' : 'false');
            }

            incrementRunCounter() {
                this.runCounter += 1;
                localStorage.setItem(this.runCounterKey, String(this.runCounter));
                return this.runCounter;
            }

            generateSessionSeed(lockSeed) {
                if (lockSeed) {
                    const existing = localStorage.getItem(this.seedKey);
                    if (existing) {
                        this.sessionSeed = parseInt(existing, 10) >>> 0;
                        return this.sessionSeed;
                    }
                }

                const counter = this.incrementRunCounter();
                const random = cryptoRandom32();
                const salt = Date.now() >>> 0;
                const seed = fnv1aHash([counter, random, salt]);
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
                return seed;
            }

            persistSessionSeed(seed) {
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
            }
        }

        class DisjointSet {
            constructor(elements = []) {
                this.parent = new Map();
                this.rank = new Map();
                elements.forEach(e => this.makeSet(e));
            }

            makeSet(x) {
                if (!this.parent.has(x)) {
                    this.parent.set(x, x);
                    this.rank.set(x, 0);
                }
            }

            find(x) {
                if (!this.parent.has(x)) {
                    this.makeSet(x);
                }
                const parent = this.parent.get(x);
                if (parent !== x) {
                    const root = this.find(parent);
                    this.parent.set(x, root);
                    return root;
                }
                return x;
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX === rootY) return rootX;

                const rankX = this.rank.get(rootX) || 0;
                const rankY = this.rank.get(rootY) || 0;

                if (rankX < rankY) {
                    this.parent.set(rootX, rootY);
                    return rootY;
                } else if (rankX > rankY) {
                    this.parent.set(rootY, rootX);
                    return rootX;
                } else {
                    this.parent.set(rootY, rootX);
                    this.rank.set(rootX, rankX + 1);
                    return rootX;
                }
            }

            getSets() {
                const result = new Map();
                for (const key of this.parent.keys()) {
                    const root = this.find(key);
                    if (!result.has(root)) {
                        result.set(root, new Set());
                    }
                    result.get(root).add(key);
                }
                return result;
            }
        }

        class Atom {
            constructor(axis, head, tail) {
                this.axis = axis;
                this.head = head;
                this.tail = tail;
            }

            equals(other) {
                return this.axis === other.axis && this.head === other.head && this.tail === other.tail;
            }

            toString() {
                return `${this.head} is ${RELATION_WORDS[this.axis]} ${this.tail}`;
            }

            toKey() {
                return `${this.axis},${this.head},${this.tail}`;
            }

            static invert(atom) {
                const invMap = { N: 'S', S: 'N', E: 'W', W: 'E' };
                return new Atom(invMap[atom.axis], atom.tail, atom.head);
            }
        }

        class Premise {
            constructor(config) {
                if (Array.isArray(config)) {
                    // ATOMIC premise path
                    this.type = 'ATOMIC';
                    this.atoms = [...config].sort((a, b) => {
                        if (a.axis !== b.axis) return a.axis.localeCompare(b.axis);
                        if (a.head !== b.head) return a.head.localeCompare(b.head);
                        return a.tail.localeCompare(b.tail);
                    });
                    this.meta = null;
                    this.semanticPairs = null;
                } else if (config && config.type === 'META_RELATIONAL') {
                    // META_RELATIONAL premise path (Level 6)
                    this.type = 'META_RELATIONAL';
                    this.atoms = [];  // Always ensure atoms is an array (empty for META)

                    // Validate META operators
                    const validOps = ['North', 'South', 'East', 'West'];
                    const p = config.p || [];

                    // Must be even number (pairs) and at least 4 (minimum 2 pairs for analogy)
                    if (!Array.isArray(p) || p.length < 4 || p.length % 2 !== 0) {
                        console.error('Invalid META premise: operators must be even array with min 4', p);
                        throw new Error(`Invalid META premise: expected even count >= 4, got ${p.length}`);
                    }

                    // Verify all operators are valid
                    const invalid = p.filter(op => !validOps.includes(op));
                    if (invalid.length > 0) {
                        console.error('Invalid META operators:', invalid);
                        throw new Error(`Invalid META operators: ${invalid.join(', ')}`);
                    }

                    // Note: Operators CAN repeat for k>2 (e.g., "North to South as North to East")

                    this.meta = {
                        p: [...p]  // Clone array
                    };
                } else {
                    console.error('Invalid Premise constructor argument:', config);
                    throw new Error('Invalid Premise constructor argument');
                }

                try {
                    this.features = this.computeFeatures();
                } catch (err) {
                    console.error('Failed to compute features for premise:', err);
                    // Provide default features to prevent crashes
                    this.features = {
                        lettersSet: new Set(),
                        degreeVector: new Map(),
                        skeletonIsoSignature: this.type.includes('META') ? 'META_ISO' : 'ERROR',
                        atomAxisProfile: new Map()
                    };
                }
            }

            getLetters() {
                if (this.type === 'META_RELATIONAL') {
                    return new Set(this.meta.p);
                }
                const letters = new Set();
                this.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            computeFeatures() {
                if (this.type === 'META_RELATIONAL') {
                    return {
                        lettersSet: this.getLetters(),
                        degreeVector: new Map(),
                        skeletonIsoSignature: 'META_ISO',
                        atomAxisProfile: new Map()
                    };
                }

                const lettersSet = new Set();
                const degreeVector = new Map();
                const axisProfile = new Map();
                const indexMap = {
                    N: [0, 1],
                    S: [2, 3],
                    E: [4, 5],
                    W: [6, 7]
                };

                const ensureVector = (letter) => {
                    if (!degreeVector.has(letter)) {
                        degreeVector.set(letter, [0, 0, 0, 0, 0, 0, 0, 0]);
                    }
                    return degreeVector.get(letter);
                };

                this.atoms.forEach(atom => {
                    lettersSet.add(atom.head);
                    lettersSet.add(atom.tail);

                    const [outIdx, inIdx] = indexMap[atom.axis];
                    const headVec = ensureVector(atom.head);
                    headVec[outIdx] += 1;
                    const tailVec = ensureVector(atom.tail);
                    tailVec[inIdx] += 1;

                    axisProfile.set(atom.axis, (axisProfile.get(atom.axis) || 0) + 1);
                });

                return {
                    lettersSet,
                    degreeVector,
                    skeletonIsoSignature: this.isoSignature(),
                    atomAxisProfile: axisProfile
                };
            }

            getFeatures() {
                return this.features;
            }

            atomKeys() {
                if (this.type === 'META_RELATIONAL') {
                    return [this.toKey()];
                }
                return this.atoms.map(atom => atom.toKey());
            }

            toKey() {
                if (this.type === 'META_RELATIONAL') {
                    return `META:${this.meta.p.join(',')}`;
                }
                return this.atomKeys().join('|');
            }

            toString() {
                if (this.type === 'META_RELATIONAL') {
                    const ops = this.meta.p;
                    const pairs = [];
                    for (let i = 0; i < ops.length; i += 2) {
                        pairs.push(`${ops[i]} to ${ops[i + 1]}`);
                    }
                    return pairs.join(' as ');
                }
                return this.atoms.map(a => a.toString()).join('; ');
            }

            toNaturalSpeech() {
                if (this.type === 'META_RELATIONAL') {
                    const ops = this.meta.p;
                    const pairs = [];
                    for (let i = 0; i < ops.length; i += 2) {
                        pairs.push(`${ops[i]} to ${ops[i + 1]}`);
                    }
                    return pairs.join('... as ') + '.';
                }
                return this.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ') + '.';
            }

            mirrorKey() {
                if (this.type === 'META_RELATIONAL') {
                    // For META premises, canonical form is the sorted version
                    const key1 = this.toKey();
                    const reversed = [...this.meta.p].reverse();
                    const key2 = `META:${reversed.join(',')}`;
                    return key1 < key2 ? key1 : key2;
                }
                const canonicalAtoms = this.atoms.map(atom => {
                    const inverted = Atom.invert(atom);
                    const current = `${atom.axis}|${atom.head}|${atom.tail}`;
                    const flipped = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return current < flipped ? current : flipped;
                }).sort();
                return canonicalAtoms.join('|');
            }

            isoSignature() {
                if (this.type === 'META_RELATIONAL') {
                    return 'META_ISO';
                }
                const letterMap = new Map();
                let nextCharCode = 'a'.charCodeAt(0);
                const normalized = this.atoms.map(atom => {
                    if (!letterMap.has(atom.head)) {
                        letterMap.set(atom.head, String.fromCharCode(nextCharCode++));
                    }
                    if (!letterMap.has(atom.tail)) {
                        letterMap.set(atom.tail, String.fromCharCode(nextCharCode++));
                    }
                    const headNorm = letterMap.get(atom.head);
                    const tailNorm = letterMap.get(atom.tail);
                    const normalizedAtom = new Atom(atom.axis, headNorm, tailNorm);
                    const inverted = Atom.invert(normalizedAtom);
                    const keyCurrent = `${normalizedAtom.axis}|${normalizedAtom.head}|${normalizedAtom.tail}`;
                    const keyInv = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return keyCurrent < keyInv ? keyCurrent : keyInv;
                });
                return normalized.sort().join('|');
            }
        }

        class NoveltyManager {
            constructor(windowSize = HAMMING_WINDOW, firstN = FIRST_N_NOVELTY) {
                this.windowSize = windowSize;
                this.firstN = firstN;
                this.seenExact = new Set();
                this.seenMirror = new Set();
                this.seenIso = new Set();
                this.history = [];
            }

            buildSignatures(premise) {
                return {
                    exact: premise.toKey(),
                    mirror: premise.mirrorKey(),
                    iso: premise.isoSignature(),
                    atoms: premise.atomKeys()
                };
            }

            computeHamming(atoms) {
                if (this.history.length === 0) return this.windowSize;
                const freq1 = this.buildFrequencyMap(atoms);
                let total = 0;
                const limit = Math.min(this.windowSize, this.history.length);
                for (let i = 0; i < limit; i++) {
                    const other = this.history[this.history.length - 1 - i];
                    const freq2 = other.frequency;
                    const allKeys = new Set([...freq1.keys(), ...freq2.keys()]);
                    let diff = 0;
                    allKeys.forEach(key => {
                        diff += Math.abs((freq1.get(key) || 0) - (freq2.get(key) || 0));
                    });
                    total += diff;
                }
                return total / limit;
            }

            buildFrequencyMap(atoms) {
                const freq = new Map();
                atoms.forEach(key => {
                    freq.set(key, (freq.get(key) || 0) + 1);
                });
                return freq;
            }

            evaluate(premise, signatures, trialIndex) {
                const exactHit = this.seenExact.has(signatures.exact);
                if (exactHit) {
                    return {
                        blocked: true,
                        reason: 'exact-repeat',
                        penalty: Infinity,
                        noveltyScores: { exact: 1, mirror: 0, iso: 0, hamming: 0 }
                    };
                }

                const mirrorHit = this.seenMirror.has(signatures.mirror);
                const isoHit = this.seenIso.has(signatures.iso);
                const hamming = this.computeHamming(signatures.atoms);

                const noveltyScores = {
                    exact: mirrorHit ? 1 : 0,
                    mirror: mirrorHit ? 1 : 0,
                    iso: isoHit ? 1 : 0,
                    hamming
                };

                if (trialIndex < this.firstN && (mirrorHit || isoHit)) {
                    return {
                        blocked: true,
                        reason: 'novelty-mode',
                        penalty: Infinity,
                        noveltyScores
                    };
                }

                let penalty = 0;
                if (mirrorHit) penalty += 1;
                if (isoHit) penalty += 2;

                return {
                    blocked: false,
                    penalty,
                    noveltyScores
                };
            }

            register(signatures) {
                this.seenExact.add(signatures.exact);
                this.seenMirror.add(signatures.mirror);
                this.seenIso.add(signatures.iso);
                this.history.push({
                    signature: signatures.exact,
                    frequency: this.buildFrequencyMap(signatures.atoms)
                });
                if (this.history.length > this.windowSize) {
                    this.history.shift();
                }
            }

            reset() {
                this.seenExact.clear();
                this.seenMirror.clear();
                this.seenIso.clear();
                this.history = [];
            }
        }

        class LetterPoolManager {
            constructor(allLetters, rng, usageTracker) {
                this.allLetters = allLetters;
                this.rng = rng;
                this.usageTracker = usageTracker;
                this.currentPool = [];
            }

            getUsage(letter) {
                const usage = this.usageTracker.get(letter);
                if (!usage) return 0;
                return usage.head + usage.tail;
            }

            sampleLetters(count, candidates = this.allLetters) {
                const available = candidates.filter(l => !this.currentPool.includes(l));
                const selection = [];
                const pool = [...available];
                while (selection.length < count && pool.length > 0) {
                    const weights = pool.map(letter => 1 / (1 + this.getUsage(letter)));
                    const choice = this.rng.weightedChoice(pool, weights);
                    selection.push(choice);
                    const index = pool.indexOf(choice);
                    pool.splice(index, 1);
                }
                return selection;
            }

            nextPool(k, options = {}) {
                const { expand = false } = options;
                const min = k + 1;
                const max = Math.min(6, 2 * k + 2);
                const targetSize = Math.max(min, Math.min(max, (this.currentPool.length || min) + (expand ? 1 : 0)));

                if (this.currentPool.length === 0) {
                    const letters = this.rng.shuffle(this.allLetters).slice(0, targetSize);
                    this.currentPool = letters;
                    return this.currentPool;
                }

                const drift = expand ? 0.5 : this.rng.nextBetween(0.3, 0.5);
                const keepCount = Math.max(min, Math.round(targetSize * (1 - drift)));
                const orderedByUsage = [...this.currentPool].sort((a, b) => this.getUsage(a) - this.getUsage(b));
                const keep = orderedByUsage.slice(0, keepCount);
                const needed = targetSize - keep.length;
                const candidates = this.allLetters.filter(letter => !keep.includes(letter));
                const additions = this.sampleLetters(needed, candidates);
                this.currentPool = this.rng.shuffle([...keep, ...additions]);
                return this.currentPool;
            }
        }

        function collectLetters(atoms) {
            const set = new Set();
            atoms.forEach(atom => {
                set.add(atom.head);
                set.add(atom.tail);
            });
            return set;
        }

        function addEdge(map, from, to) {
            if (!map.has(from)) {
                map.set(from, new Set());
            }
            map.get(from).add(to);
        }

        function topologicalAssign(nodes, edges) {
            const indegree = new Map();
            nodes.forEach(node => indegree.set(node, 0));
            edges.forEach((targets, source) => {
                targets.forEach(target => {
                    indegree.set(target, (indegree.get(target) || 0) + 1);
                });
            });

            const queue = [];
            indegree.forEach((degree, node) => {
                if (degree === 0) queue.push(node);
            });

            const order = [];
            while (queue.length > 0) {
                const node = queue.shift();
                order.push(node);
                const neighbors = edges.get(node);
                if (!neighbors) continue;
                neighbors.forEach(neighbor => {
                    indegree.set(neighbor, indegree.get(neighbor) - 1);
                    if (indegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            if (order.length !== nodes.length) {
                return { cycle: true, values: new Map() };
            }

            const values = new Map();
            order.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
                const base = values.get(node);
                const neighbors = edges.get(node);
                if (!neighbors) return;
                neighbors.forEach(neighbor => {
                    const current = values.get(neighbor) || 0;
                    const candidate = Math.max(current, base + 1);
                    values.set(neighbor, candidate);
                });
            });

            nodes.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
            });

            return { cycle: false, values };
        }

        function buildReachability(nodes, edges) {
            const reach = new Map();
            nodes.forEach(node => {
                const visited = new Set();
                const stack = [node];
                while (stack.length) {
                    const current = stack.pop();
                    const neighbors = edges.get(current);
                    if (!neighbors) continue;
                    neighbors.forEach(next => {
                        if (!visited.has(next)) {
                            visited.add(next);
                            stack.push(next);
                        }
                    });
                }
                reach.set(node, visited);
            });
            return reach;
        }

        class ConstraintSolver {
            analyze(allAtoms) {
                const letters = collectLetters(allAtoms);
                const ufX = new DisjointSet(letters);
                const ufY = new DisjointSet(letters);

                const graphX = new Map();
                const graphY = new Map();

                for (const atom of allAtoms) {
                    if (atom.axis === 'N' || atom.axis === 'S') {
                        ufX.union(atom.head, atom.tail);
                    } else {
                        ufY.union(atom.head, atom.tail);
                    }
                }

                for (const atom of allAtoms) {
                    if (atom.axis === 'N') {
                        const lesser = ufY.find(atom.tail);
                        const greater = ufY.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'S') {
                        const lesser = ufY.find(atom.head);
                        const greater = ufY.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'E') {
                        const lesser = ufX.find(atom.tail);
                        const greater = ufX.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    } else if (atom.axis === 'W') {
                        const lesser = ufX.find(atom.head);
                        const greater = ufX.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    }
                }

                const nodesX = Array.from(new Set([...graphX.keys(), ...Array.from(graphX.values()).flat()]));
                ufX.parent.forEach((_, letter) => nodesX.push(ufX.find(letter)));
                const uniqueNodesX = Array.from(new Set(nodesX));

                const nodesY = Array.from(new Set([...graphY.keys(), ...Array.from(graphY.values()).flat()]));
                ufY.parent.forEach((_, letter) => nodesY.push(ufY.find(letter)));
                const uniqueNodesY = Array.from(new Set(nodesY));

                const assignX = topologicalAssign(uniqueNodesX, graphX);
                if (assignX.cycle) {
                    return { ok: false, reason: 'horizontal-cycle' };
                }

                const assignY = topologicalAssign(uniqueNodesY, graphY);
                if (assignY.cycle) {
                    return { ok: false, reason: 'vertical-cycle' };
                }

                const coordinates = new Map();
                letters.forEach(letter => {
                    const xRep = ufX.find(letter);
                    const yRep = ufY.find(letter);
                    const x = assignX.values.get(xRep) || 0;
                    const y = assignY.values.get(yRep) || 0;
                    coordinates.set(letter, { x, y });
                });

                return {
                    ok: true,
                    coordinates,
                    ufX,
                    ufY,
                    graphX,
                    graphY,
                    nodesX: uniqueNodesX,
                    nodesY: uniqueNodesY
                };
            }

            evaluate(windowAtoms, candidateAtoms) {
                return this.analyze([...windowAtoms, ...candidateAtoms]);
            }
        }

        class EquivalenceEngine {
            constructor(transitivityEnabled = false) {
                this.transitivityEnabled = transitivityEnabled;
            }

            setTransitivity(enabled) {
                this.transitivityEnabled = enabled;
            }

            lettersOf(premise) {
                const letters = new Set();

                // META premises don't have atoms in the same way
                if (premise.type === 'META_RELATIONAL') {
                    if (premise.meta && premise.meta.p) {
                        premise.meta.p.forEach(op => letters.add(op));
                    }
                    return letters;
                }

                // ATOMIC premises
                if (premise.atoms && Array.isArray(premise.atoms)) {
                    premise.atoms.forEach(atom => {
                        if (atom && atom.head && atom.tail) {
                            letters.add(atom.head);
                            letters.add(atom.tail);
                        }
                    });
                }
                return letters;
            }

            computeInvertibleMapping(atomsA, atomsB) {
                const mapping = [];
                const used = new Set();

                const search = (index) => {
                    if (index === atomsA.length) return true;
                    for (let j = 0; j < atomsB.length; j++) {
                        if (used.has(j)) continue;
                        if (atomsA[index].equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: false });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                        const inverted = Atom.invert(atomsA[index]);
                        if (inverted.equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: true });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                    }
                    return false;
                };

                const ok = search(0);
                return ok ? mapping.slice() : null;
            }

            analyzeMidWindow(midAtoms) {
                if (!midAtoms || midAtoms.length === 0) {
                    return { ok: false };
                }
                const solver = new ConstraintSolver();
                const analysis = solver.analyze(midAtoms);
                if (!analysis.ok) {
                    return { ok: false };
                }
                const reachX = buildReachability(analysis.nodesX, analysis.graphX);
                const reachY = buildReachability(analysis.nodesY, analysis.graphY);
                return { ok: true, analysis, reachX, reachY };
            }

            isDerivableFromMid(atom, midInfo) {
                if (!midInfo.ok) return false;
                const { analysis, reachX, reachY } = midInfo;
                if (atom.axis === 'N') {
                    const lesser = analysis.ufY.find(atom.tail);
                    const greater = analysis.ufY.find(atom.head);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'S') {
                    const lesser = analysis.ufY.find(atom.head);
                    const greater = analysis.ufY.find(atom.tail);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'E') {
                    const lesser = analysis.ufX.find(atom.tail);
                    const greater = analysis.ufX.find(atom.head);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'W') {
                    const lesser = analysis.ufX.find(atom.head);
                    const greater = analysis.ufX.find(atom.tail);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                return false;
            }

            Equivalent(premA, premB, windowAtoms = [], midAtoms = []) {
                const atomsA = premA.atoms;
                const atomsB = premB.atoms;

                if (atomsA.length !== atomsB.length) {
                    return { ok: false, reason: 'parity' };
                }

                const mapping = this.computeInvertibleMapping(atomsA, atomsB);
                // Allow non-invertible mapping if Transitivity is on, to enable A->C derivable from A->B
                if (!mapping && !this.transitivityEnabled) {
                    return { ok: false, reason: 'mapping' };
                }

                const lettersA = this.lettersOf(premA);
                const lettersB = this.lettersOf(premB);
                const shared = new Set();
                lettersA.forEach(letter => {
                    if (lettersB.has(letter)) {
                        shared.add(letter);
                    }
                });
                if (shared.size < 2) {
                    return { ok: false, reason: 'anchors' };
                }

                const solver = new ConstraintSolver();
                const satResult = solver.analyze([...windowAtoms, ...atomsA, ...atomsB]);
                if (!satResult.ok) {
                    return { ok: false, reason: 'sat' };
                }

                const midInfo = this.analyzeMidWindow(midAtoms);
                if (midInfo.ok) {
                    for (const atom of [...atomsA, ...atomsB]) {
                        if (this.isDerivableFromMid(atom, midInfo) || this.isDerivableFromMid(Atom.invert(atom), midInfo)) {
                            return {
                                ok: false,
                                reason: 'mid-window-derivable',
                                mapping,
                                sharedLetters: Array.from(shared),
                                midWindowDerivable: true
                            };
                        }
                    }
                }

                return {
                    ok: true,
                    type: 'invertible',
                    mapping,
                    sharedLetters: Array.from(shared),
                    midWindowDerivable: false
                };
            }

            computeCertificate(nBackPremise, candidatePremise, midAtoms, windowAtoms = []) {
                if (!nBackPremise) {
                    return { match: false, reason: 'no-nback' };
                }

                if (nBackPremise.toKey() === candidatePremise.toKey()) {
                    return { match: false, reason: 'identity' };
                }

                // Router: dispatch based on premise type
                if (nBackPremise.type !== candidatePremise.type) {
                    return { match: false, reason: 'type-mismatch' };
                }

                if (nBackPremise.type === 'META_RELATIONAL') {
                    return this.computeMetaEquivalence(nBackPremise, candidatePremise);
                }

                // ATOMIC premise path (legacy)
                const result = this.Equivalent(nBackPremise, candidatePremise, windowAtoms, midAtoms || []);
                if (!result.ok) {
                    const response = { match: false, reason: result.reason };
                    if (result.reason === 'mid-window-derivable' || result.midWindowDerivable) {
                        response.midWindowDerivable = true;
                        if (this.transitivityEnabled) {
                            return {
                                match: true,
                                certificate: {
                                    type: 'transitive-closure',
                                    mapping: result.mapping || [],
                                    sharedLetters: result.sharedLetters || [],
                                    parity: true,
                                    midWindowDerivable: true
                                },
                                midWindowDerivable: true
                            };
                        }
                    }
                    return response;
                }

                const certificate = {
                    type: result.type,
                    mapping: result.mapping,
                    sharedLetters: result.sharedLetters,
                    parity: true,
                    midWindowDerivable: false
                };

                return { match: true, certificate, midWindowDerivable: false };
            }


            deduceImpliedOperator(p1, p2) {
                // Robust validation
                if (typeof p1 !== 'string' || typeof p2 !== 'string') {
                    console.error('deduceImpliedOperator: invalid input types', p1, p2);
                    return null;
                }

                // Maps compass operator names to their concepts
                const CONCEPT_MAP = {
                    'North': 'Up-shift',
                    'South': 'Down-shift',
                    'East': 'Analogue',
                    'West': 'Opposite'
                };

                const c1 = CONCEPT_MAP[p1];
                const c2 = CONCEPT_MAP[p2];

                if (!c1 || !c2) {
                    console.warn('deduceImpliedOperator: unknown operators', p1, p2);
                    return null;
                }

                // Same concept = Analogue (East)
                if (c1 === c2) {
                    return 'East';
                }

                // Opposite concepts = West
                const opposites = [
                    ['Up-shift', 'Down-shift'],
                    ['Down-shift', 'Up-shift'],
                    ['Analogue', 'Opposite'],
                    ['Opposite', 'Analogue']
                ];

                for (const [a, b] of opposites) {
                    if (c1 === a && c2 === b) {
                        return 'West';
                    }
                }

                // Orthogonal pairs (Up/Down with Analogue/Opposite) = null
                return null;
            }

            getMetaTruthValue(premise) {
                // Robust validation
                if (!premise || premise.type !== 'META_RELATIONAL') {
                    console.error('getMetaTruthValue: not a META premise', premise);
                    return 'INVALID';
                }

                if (!premise.meta || !Array.isArray(premise.meta.p)) {
                    console.error('getMetaTruthValue: invalid META structure', premise.meta);
                    return 'INVALID';
                }

                const operators = premise.meta.p;
                const length = operators.length;

                // Must be even number (pairs) and at least 4 (minimum 2 pairs for analogy)
                if (length < 4 || length % 2 !== 0) {
                    console.error('getMetaTruthValue: invalid operator count', length);
                    return 'INVALID';
                }

                try {
                    const numPairs = length / 2;
                    const deducedOperators = [];

                    // Deduce implied operator for each pair
                    for (let i = 0; i < numPairs; i++) {
                        const p0 = operators[i * 2];
                        const p1 = operators[i * 2 + 1];
                        const deduced = this.deduceImpliedOperator(p0, p1);
                        deducedOperators.push(deduced);
                    }

                    // Check if all deduced operators are the same
                    const firstOp = deducedOperators[0];
                    const allSame = deducedOperators.every(op => {
                        // null === null is true (orthogonal pairs)
                        // 'West' === 'West' is true
                        // null === 'West' is false
                        return op === firstOp;
                    });

                    return allSame;  // Returns true or false
                } catch (err) {
                    console.error('getMetaTruthValue: exception', err, premise);
                    return 'INVALID';
                }
            }

            computeMetaEquivalence(nBackPremise, candidatePremise) {
                // Defensive validation
                if (!nBackPremise || !candidatePremise) {
                    console.error('computeMetaEquivalence: null premise', { nBackPremise, candidatePremise });
                    return { match: false, reason: 'null-premise' };
                }

                if (nBackPremise.type !== 'META_RELATIONAL' || candidatePremise.type !== 'META_RELATIONAL') {
                    console.error('computeMetaEquivalence: not META premises', {
                        nBackType: nBackPremise.type,
                        candidateType: candidatePremise.type
                    });
                    return { match: false, reason: 'type-mismatch' };
                }

                try {
                    const truthA = this.getMetaTruthValue(nBackPremise);
                    const truthB = this.getMetaTruthValue(candidatePremise);

                    if (truthA === 'INVALID' || truthB === 'INVALID') {
                        console.warn('computeMetaEquivalence: invalid truth value', { truthA, truthB });
                        return { match: false, reason: 'meta-invalid' };
                    }

                    // 6th-order match: truth values must be equal
                    const match = (truthA === truthB);

                    return {
                        match,
                        certificate: match ? {
                            type: 'meta',
                            truthA,
                            truthB,
                            nBackOperators: nBackPremise.meta.p,
                            candidateOperators: candidatePremise.meta.p
                        } : null,
                        midWindowDerivable: false,
                        reason: match ? 'truth-match' : 'truth-mismatch'
                    };
                } catch (err) {
                    console.error('computeMetaEquivalence: exception', err);
                    return { match: false, reason: 'exception', error: err.message };
                }
            }

        }

        class MatchPlanner {
            constructor(rng) {
                this.rng = rng;
                this.schedule = [];
                this.flips = new Map();
                this.matchModeBag = [];
                this.decoyModeBag = [];
                this.foilRate = conflictConfig.foilRate;
                this.foilTypes = Object.keys(conflictConfig.foilTypesWeights);
                this.foilWeights = this.foilTypes.map(type => conflictConfig.foilTypesWeights[type]);
            }

            plan(totalTrials, n) {
                this.schedule = new Array(totalTrials).fill(false);
                this.flips.clear();
                const rate = this.rng.nextBetween(0.35, 0.55);
                const history = [];
                for (let i = 0; i < totalTrials; i++) {
                    if (i < n) {
                        this.schedule[i] = false;
                        history.push(false);
                        continue;
                    }

                    let decision = this.rng.next() < rate;
                    if (this.wouldRepeat(history, decision)) {
                        decision = !decision;
                        this.flips.set(i, true);
                    }

                    this.schedule[i] = decision;
                    history.push(decision);
                    if (history.length > 24) history.shift();
                }
                return this.schedule;
            }

            chooseConflictMode(plannedMatch) {
                if (plannedMatch) {
                    if (this.matchModeBag.length === 0) {
                        this.matchModeBag = this.rng.shuffle(['BSM', 'CAC']);
                    }
                    return this.matchModeBag.pop();
                }
                if (this.decoyModeBag.length === 0) {
                    const decoys = ['ASNM', 'APNM', 'PPHF', 'CBB', 'WLC', 'ISD'];
                    const bag = [];
                    for (let i = 0; i < 2; i++) {
                        bag.push(...decoys);
                    }
                    this.decoyModeBag = this.rng.shuffle(bag);
                }
                return this.decoyModeBag.pop();
            }

            sampleFoilType() {
                if (this.foilTypes.length === 0) {
                    return null;
                }
                return this.rng.weightedChoice(this.foilTypes, this.foilWeights);
            }

            maybePlanFoil() {
                if (this.foilRate <= 0) return null;
                if (this.rng.next() < this.foilRate) {
                    const type = this.sampleFoilType();
                    return type ? { type } : null;
                }
                return null;
            }

            wouldRepeat(history, decision) {
                const window = [...history, decision];
                if (window.length < 24) return false;
                const recent = window.slice(-12);
                const previous = window.slice(-24, -12);
                return this.isRotationEqual(previous, recent);
            }

            isRotationEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) return false;
                const joined1 = arr1.join('');
                const joined2 = arr2.join('');
                return (joined1 + joined1).includes(joined2);
            }

            forceFlip(index) {
                if (index < 0 || index >= this.schedule.length) return;
                this.schedule[index] = !this.schedule[index];
                this.flips.set(index, true);
            }

            wasFlipped(index) {
                return this.flips.get(index) || false;
            }
        }

        class GameLogger {
            constructor(limitBytes = 5 * 1024 * 1024) {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeLimit = limitBytes;
                this.sizeEstimate = 0;
            }

            estimateSize(entry) {
                try {
                    return JSON.stringify(entry).length;
                } catch (error) {
                    return 0;
                }
            }

            flushToArchive() {
                const keep = Math.min(1000, this.entries.length);
                const flushCount = this.entries.length - keep;
                if (flushCount <= 0) return false;
                const flushedEntries = this.entries.splice(0, flushCount);
                const flushedSizes = this.entrySizes.splice(0, flushCount);
                this.archivedChunks.push(JSON.stringify(flushedEntries));
                const reclaimed = flushedSizes.reduce((acc, value) => acc + value, 0);
                this.sizeEstimate = Math.max(0, this.sizeEstimate - reclaimed);
                return true;
            }

            add(entry) {
                const size = this.estimateSize(entry);
                this.entries.push(entry);
                this.entrySizes.push(size);
                this.sizeEstimate += size;
                while (this.sizeEstimate > this.sizeLimit) {
                    const flushed = this.flushToArchive();
                    if (!flushed) {
                        break;
                    }
                }
            }

            reset() {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeEstimate = 0;
            }

            getEntriesSnapshot() {
                const snapshot = [];
                for (const chunk of this.archivedChunks) {
                    try {
                        const parsed = JSON.parse(chunk);
                        if (Array.isArray(parsed)) {
                            snapshot.push(...parsed);
                        }
                    } catch (error) {
                        console.warn('Failed to parse archived log chunk', error);
                    }
                }
                snapshot.push(...this.entries);
                return snapshot;
            }

            toCSV() {
                const entries = this.getEntriesSnapshot();
                if (entries.length === 0) return '';
                const headers = Object.keys(entries[0]);
                const rows = [headers.join(',')];
                entries.forEach(entry => {
                    const row = headers.map(key => {
                        const value = entry[key];
                        if (value === null || value === undefined) return '';
                        if (typeof value === 'object') {
                            return JSON.stringify(value).replace(/"/g, '""');
                        }
                        return String(value).replace(/"/g, '""');
                    }).join(',');
                    rows.push(row);
                });
                return rows.join('\n');
            }

            toJSON() {
                return JSON.stringify(this.getEntriesSnapshot(), null, 2);
            }
        }

        class GameState {
            constructor(seed, options) {
                this.seed = seed;
                this.rng = new Mulberry32(seed);
                this.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                this.windowSize = options.windowSize;
                this.currentStep = 0;
                this.constraintStore = [];
                this.premiseHistory = [];
                this.letterUsage = new Map();
                this.axisUsage = { N: 0, S: 0, E: 0, W: 0 };
                this.cooldown = new Map();
                this.novelty = new NoveltyManager(HAMMING_WINDOW, FIRST_N_NOVELTY);
                this.letterPool = new LetterPoolManager(this.letters, this.rng, this.letterUsage);
                this.coordinates = new Map();
            }

            resetNovelty() {
                this.novelty.reset();
            }

            getWindowAtoms() {
                const cutoff = Math.max(0, this.currentStep - this.windowSize);
                return this.constraintStore
                    .filter(entry => entry.step >= cutoff)
                    .flatMap(entry => entry.atoms);
            }

            getConstraintsInRange(start, end) {
                return this.constraintStore
                    .filter(entry => entry.step >= start && entry.step <= end)
                    .flatMap(entry => entry.atoms);
            }

            ensureLetterUsage(letter) {
                if (!this.letterUsage.has(letter)) {
                    this.letterUsage.set(letter, { head: 0, tail: 0 });
                }
                return this.letterUsage.get(letter);
            }

            updateUsage(premise) {
                // META premises don't have atoms to track usage for
                if (!premise || premise.type === 'META_RELATIONAL') {
                    return;
                }

                // ATOMIC premises - track letter and axis usage
                if (premise.atoms && Array.isArray(premise.atoms)) {
                    premise.atoms.forEach(atom => {
                        if (atom && atom.head && atom.tail && atom.axis) {
                            this.ensureLetterUsage(atom.head).head += 1;
                            this.ensureLetterUsage(atom.tail).tail += 1;
                            if (this.axisUsage[atom.axis] !== undefined) {
                                this.axisUsage[atom.axis] += 1;
                            }
                        }
                    });
                }
            }

            recordPremise(premise, atoms, metadata) {
                // Defensive: ensure atoms is an array
                const safeAtoms = (Array.isArray(atoms) && atoms.length > 0) ? atoms : [];

                // For META premises, atoms will be empty array - that's expected
                if (premise && premise.type === 'META_RELATIONAL') {
                    console.log('Recording META premise:', premise.toString(), metadata);
                }

                this.constraintStore.push({ step: this.currentStep, atoms: safeAtoms });
                this.premiseHistory.push({ step: this.currentStep, premise, metadata });
                this.currentStep += 1;

                const cutoff = this.currentStep - this.windowSize;
                this.constraintStore = this.constraintStore.filter(entry => entry.step >= cutoff);
                this.premiseHistory = this.premiseHistory.filter(entry => entry.step >= cutoff - this.windowSize);

                this.updateUsage(premise);
            }

            getPremiseAt(index) {
                const entry = this.premiseHistory.find(p => p.step === index);
                return entry ? entry.premise : null;
            }

            getActiveCooldown(currentTrial) {
                const active = new Set();
                this.cooldown.forEach((expiry, letter) => {
                    if (expiry > currentTrial) {
                        active.add(letter);
                    }
                });
                return active;
            }

            applyCooldown(letters, currentTrial, n) {
                const cooldownLength = Math.ceil(n / 2);
                letters.forEach(letter => {
                    this.cooldown.set(letter, currentTrial + cooldownLength);
                });
            }
        }

        class PremiseGenerator {
            constructor(state, solver, equivalence) {
                this.state = state;
                this.solver = solver;
                this.equivalence = equivalence;
                this.planner = null;
            }

            setPlanner(planner) {
                this.planner = planner;
            }

            generate(options) {
                const {
                    trialIndex,
                    k,
                    n,
                    plannedMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters,
                    allowOverride,
                    foilPlan,
                    forceMetaLeap,
                    forceCompoundLeap
                } = options;

                // COMPOUND OPERATOR premise generation path (Level 7)
                if (forceCompoundLeap) {
                    try {
                        const compoundPremise = this.buildCompoundOperatorPremise(plannedMatch, nBackPremise, k);
                        if (compoundPremise && compoundPremise.atoms && compoundPremise.atoms.length > 0) {
                            const signatures = this.state.novelty.buildSignatures(compoundPremise);
                            return {
                                premise: compoundPremise,
                                signatures,
                                novelty: { noveltyScores: {}, blocked: false },
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: 1,
                                modeUsed: 'COMPOUND_OPERATOR',
                                features: compoundPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        } else {
                            console.error('buildCompoundOperatorPremise returned invalid premise', compoundPremise);
                        }
                    } catch (err) {
                        console.error('COMPOUND premise generation failed', err);
                        // Fall through to META or atomic generation as emergency fallback
                    }
                }

                // META premise generation path (Level 6)
                if (forceMetaLeap) {
                    try {
                        const metaPremise = this.buildMetaPremise(plannedMatch, nBackPremise, k);
                        if (metaPremise && metaPremise.type === 'META_RELATIONAL') {
                            const signatures = this.state.novelty.buildSignatures(metaPremise);
                            return {
                                premise: metaPremise,
                                signatures,
                                novelty: { noveltyScores: {}, blocked: false },
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: 1,
                                modeUsed: 'META',
                                features: metaPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        } else {
                            console.error('buildMetaPremise returned invalid premise', metaPremise);
                        }
                    } catch (err) {
                        console.error('META premise generation failed', err);
                        // Fall through to atomic generation as emergency fallback
                    }
                }

                const windowAtoms = this.state.getWindowAtoms();
                let bestCandidate = null;
                let attempts = 0;
                let expanded = false;
                const effectiveMatch = plannedMatch && Boolean(nBackPremise);
                let mode = effectiveMatch ? 'BSM' : 'ASNM';
                if (this.planner) {
                    mode = this.planner.chooseConflictMode(effectiveMatch);
                }

                let activeFoilPlan = (!effectiveMatch && foilPlan && typeof foilPlan.type === 'string') ? { type: foilPlan.type } : null;
                let foilAttempts = 0;

                while (attempts < MAX_GENERATION_ATTEMPTS) {
                    const expand = attempts > 0 && attempts % NOVELTY_OVERRIDE_THRESHOLD === 0;
                    if (expand) expanded = true;

                    let candidatePremise = null;
                    let candidateAtoms = null;
                    let modeUsed = mode;
                    let foilType = null;

                    if (!effectiveMatch && activeFoilPlan && nBackPremise) {
                        const foilResult = this.buildFoilPremise(activeFoilPlan.type, {
                            referencePremise: nBackPremise,
                            windowAtoms,
                            middleAtoms,
                            avoidLetters
                        });
                        foilAttempts++;
                        if (foilResult) {
                            candidatePremise = foilResult.premise;
                            candidateAtoms = candidatePremise.atoms;
                            foilType = foilResult.foilType;
                            modeUsed = `FOIL_${foilResult.foilType}`;
                        } else if (foilAttempts >= 60) {
                            activeFoilPlan = null;
                        }
                    }

                    if (!candidatePremise) {
                        const pool = this.state.letterPool.nextPool(k, { expand });
                        const context = {
                            mode,
                            plannedMatch: effectiveMatch,
                            nBackPremise,
                            pool,
                            k,
                            n,
                            trialIndex,
                            middleAtoms,
                            avoidLetters,
                            state: this.state,
                            rng: this.state.rng
                        };
                        const atomsFromMode = this.makePremiseWithMode(mode, context);
                        attempts++;
                        if (!atomsFromMode) {
                            if (attempts % 12 === 0 && this.planner) {
                                mode = this.planner.chooseConflictMode(effectiveMatch);
                            }
                            continue;
                        }
                        candidateAtoms = atomsFromMode;
                        candidatePremise = new Premise(atomsFromMode);
                    } else {
                        attempts++;
                        candidateAtoms = candidatePremise.atoms;
                    }

                    const premise = candidatePremise;
                    const features = premise.getFeatures();
                    const signatures = this.state.novelty.buildSignatures(premise);
                    const novelty = this.state.novelty.evaluate(premise, signatures, trialIndex);

                    if (novelty.blocked && !(allowOverride && expanded)) {
                        continue;
                    }

                    const satResult = this.solver.evaluate(windowAtoms, candidateAtoms);
                    if (!satResult.ok) {
                        continue;
                    }

                    let certificate = null;
                    let midDerivable = false;

                    if (effectiveMatch) {
                        const equivalence = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (!equivalence.match) {
                            continue;
                        }
                        certificate = equivalence.certificate;
                        midDerivable = equivalence.midWindowDerivable;
                    } else if (nBackPremise) {
                        const check = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (check.match) {
                            continue;
                        }
                    }

                    const score = Math.exp(ACCEPTANCE_ALPHA * novelty.noveltyScores.hamming - ACCEPTANCE_BETA * novelty.penalty);
                    if (!bestCandidate || score > bestCandidate.score) {
                        bestCandidate = {
                            premise,
                            signatures,
                            novelty,
                            satResult,
                            certificate,
                            midDerivable,
                            attempts,
                            modeUsed,
                            features,
                            foilType,
                            score
                        };
                    }

                    if (this.state.rng.next() < Math.min(1, score)) {
                        return bestCandidate;
                    }

                    if (attempts % 12 === 0 && this.planner) {
                        mode = this.planner.chooseConflictMode(effectiveMatch);
                    }
                }

                return bestCandidate;
            }

            makePremiseWithMode(mode, context) {
                const requiresNBack = ['ASNM', 'APNM', 'PPHF', 'BSM', 'WLC', 'CAC', 'ISD'];
                if (!context.nBackPremise && requiresNBack.includes(mode)) {
                    return this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
                switch (mode) {
                    case 'ASNM':
                        return this.makeAxisSwapNearMiss(context);
                    case 'APNM':
                        return this.makeAnchorPermutationNearMiss(context);
                    case 'PPHF':
                        return this.makeParityPreservedHubFlip(context);
                    case 'CBB':
                        return this.makeCycleBorderBait(context);
                    case 'BSM':
                        return this.makeBipartiteSignatureMatch(context);
                    case 'WLC':
                        return this.makeWrongLagCamouflage(context);
                    case 'CAC':
                        return this.makeCrossAxisCoupling(context);
                    case 'ISD':
                        return this.makeIsomorphicSkeletonDecoy(context);
                    default:
                        return context.plannedMatch
                            ? this.buildMatchCandidate(context.nBackPremise, context.pool, context.k)
                            : this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
            }

            buildFoilPremise(type, context) {
                const { referencePremise, windowAtoms, middleAtoms, avoidLetters } = context;
                if (!referencePremise) return null;
                const maxAttempts = 80;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    let candidate = null;
                    switch (type) {
                        case 'ANCHOR_ONE':
                            candidate = this.makeAnchorOneFoil(referencePremise);
                            break;
                        case 'PAIR_SWAP':
                            candidate = this.makePairSwapFoil(referencePremise);
                            break;
                        case 'PARITY_OFF':
                            candidate = this.makeParityOffFoil(referencePremise);
                            break;
                        case 'AXIS_ORTHO':
                            candidate = this.makeAxisOrthoFoil(referencePremise);
                            break;
                        case 'DERIVED_IN_ONE':
                            candidate = this.makeDerivedInOneFoil(referencePremise);
                            break;
                        case 'WINDOW_SHADOW':
                            candidate = this.makeWindowShadowFoil(referencePremise, middleAtoms);
                            break;
                        default:
                            candidate = null;
                    }
                    if (!candidate) {
                        continue;
                    }
                    if (avoidLetters) {
                        const letters = candidate.getLetters();
                        let blocked = false;
                        avoidLetters.forEach(letter => {
                            if (letters.has(letter)) {
                                blocked = true;
                            }
                        });
                        if (blocked) continue;
                    }
                    const sat = this.solver.evaluate(windowAtoms, candidate.atoms);
                    if (!sat.ok) {
                        continue;
                    }
                    const eq = this.equivalence.Equivalent(referencePremise, candidate, windowAtoms, middleAtoms);
                    if (eq.ok) {
                        continue;
                    }
                    if (!this.foilReasonMatches(type, eq.reason)) {
                        continue;
                    }
                    return { premise: candidate, foilType: type };
                }
                return null;
            }

            foilReasonMatches(type, reason) {
                const expected = {
                    ANCHOR_ONE: 'anchors',
                    PAIR_SWAP: 'mapping',
                    PARITY_OFF: 'parity',
                    AXIS_ORTHO: 'mapping',
                    DERIVED_IN_ONE: 'parity',
                    WINDOW_SHADOW: 'mid-window-derivable'
                };
                const matchReason = expected[type];
                if (!matchReason) return true;
                if (matchReason === reason) return true;
                if (type === 'DERIVED_IN_ONE' && reason === 'mid-window-derivable') return true;
                return false;
            }

            makeAnchorOneFoil(referencePremise) {
                const refLetters = referencePremise.getLetters();
                const refArray = Array.from(refLetters);
                if (refArray.length === 0) return null;
                const anchor = this.state.rng.choice(refArray);
                const banned = new Set(refLetters);
                banned.delete(anchor);
                const available = this.state.letters.filter(letter => !banned.has(letter));
                if (available.length === 0) return null;
                const atoms = [];
                for (const atom of referencePremise.atoms) {
                    const axis = atom.axis;
                    const head = atom.head === anchor ? anchor : this.state.rng.choice(available);
                    let tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                    let guard = 0;
                    while (tail === head && guard < 12) {
                        tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                        guard++;
                    }
                    if (tail === head) return null;
                    atoms.push(new Atom(axis, head, tail));
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refLetters.has(letter));
                if (shared.length !== 1 || shared[0] !== anchor) return null;
                return premise;
            }

            makePairSwapFoil(referencePremise) {
                const atoms = referencePremise.atoms;
                if (atoms.length < 2) return null;
                const heads = atoms.map(atom => atom.head);
                const tails = atoms.map(atom => atom.tail);
                for (let attempt = 0; attempt < 40; attempt++) {
                    const shuffledHeads = this.state.rng.shuffle(heads);
                    const shuffledTails = this.state.rng.shuffle(tails);
                    const candidates = [];
                    const usedKeys = new Set();
                    let valid = true;
                    for (let i = 0; i < atoms.length; i++) {
                        let head = shuffledHeads[i];
                        let tail = shuffledTails[i];
                        let guard = 0;
                        while (head === tail && guard < 8) {
                            tail = this.state.rng.choice(tails);
                            guard++;
                        }
                        if (head === tail) {
                            valid = false;
                            break;
                        }
                        const atomCandidate = new Atom(atoms[i].axis, head, tail);
                        const key = atomCandidate.toKey();
                        if (usedKeys.has(key)) {
                            valid = false;
                            break;
                        }
                        if (atomCandidate.equals(atoms[i]) || atomCandidate.equals(Atom.invert(atoms[i]))) {
                            valid = false;
                            break;
                        }
                        usedKeys.add(key);
                        candidates.push(atomCandidate);
                    }
                    if (!valid) continue;
                    const premise = new Premise(candidates);
                    if (premise.toKey() === referencePremise.toKey()) continue;
                    return premise;
                }
                return null;
            }

            makeParityOffFoil(referencePremise) {
                const refSet = referencePremise.getLetters();
                const refLetters = Array.from(refSet);
                const base = this.cloneAtoms(referencePremise);
                const originalLength = base.length;
                if (originalLength === 0) return null;
                let target = originalLength;
                if (originalLength === 1) {
                    target = Math.min(4, 2);
                } else if (originalLength === 4) {
                    target = 3;
                } else {
                    const delta = this.state.rng.next() < 0.5 ? -1 : 1;
                    target = Math.min(4, Math.max(1, originalLength + delta));
                    if (target === originalLength) {
                        target = Math.max(1, Math.min(4, originalLength - delta));
                    }
                    if (target === originalLength) {
                        target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                    }
                }
                if (target === originalLength) {
                    target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                }
                if (target < 1) target = 1;
                let atoms = base;
                if (target < originalLength) {
                    atoms = base.slice();
                    while (atoms.length > target) {
                        const index = this.state.rng.nextInt(0, atoms.length - 1);
                        atoms.splice(index, 1);
                    }
                } else if (target > originalLength) {
                    atoms = base.slice();
                    const axes = MATCH_AXES;
                    let guard = 0;
                    while (atoms.length < target && guard < 60) {
                        guard++;
                        const head = this.state.rng.choice(refLetters);
                        if (avoidLetters && avoidLetters.has(head)) continue;
                        let tailCandidates = refLetters.filter(letter => letter !== head);
                        if (avoidLetters) {
                            tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                        }
                        if (tailCandidates.length === 0) continue;
                        const tail = this.state.rng.choice(tailCandidates);
                        const axis = this.state.rng.choice(axes);
                        const candidate = new Atom(axis, head, tail);
                        if (atoms.some(atom => atom.toKey() === candidate.toKey())) continue;
                        atoms.push(candidate);
                    }
                    if (atoms.length !== target) return null;
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refSet.has(letter));
                if (shared.length < 2) return null;
                return premise;
            }

            makeAxisOrthoFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const index = this.state.rng.nextInt(0, base.length - 1);
                const orthMap = { N: 'E', S: 'W', E: 'N', W: 'S' };
                const axis = orthMap[base[index].axis];
                if (!axis) return null;
                base[index] = new Atom(axis, base[index].head, base[index].tail);
                return new Premise(base);
            }

            makeDerivedInOneFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const additions = [];
                for (let i = 0; i < base.length; i++) {
                    for (let j = 0; j < base.length; j++) {
                        if (i === j) continue;
                        const a = base[i];
                        const b = base[j];
                        if (a.axis !== b.axis) continue;
                        if (a.tail === b.head && a.head !== b.tail) {
                            const candidate = new Atom(a.axis, a.head, b.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                        if (b.tail === a.head && b.head !== a.tail) {
                            const candidate = new Atom(a.axis, b.head, a.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                    }
                }
                if (additions.length === 0) return null;
                base.push(this.state.rng.choice(additions));
                return new Premise(base);
            }

            makeWindowShadowFoil(referencePremise, middleAtoms) {
                if (!middleAtoms || middleAtoms.length === 0) return null;
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const refLetters = referencePremise.getLetters();
                const options = middleAtoms.filter(atom => {
                    const already = base.some(existing => existing.equals(atom));
                    return !already && (refLetters.has(atom.head) || refLetters.has(atom.tail));
                });
                if (options.length === 0) return null;
                const replacement = this.state.rng.choice(options);
                const index = this.state.rng.nextInt(0, base.length - 1);
                base[index] = new Atom(replacement.axis, replacement.head, replacement.tail);
                return new Premise(base);
            }

            cloneAtoms(premise) {
                return premise.atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
            }

            sampleNewLetter(excludeSet = new Set()) {
                const candidates = this.state.letters.filter(letter => !excludeSet.has(letter));
                if (candidates.length === 0) return null;
                return this.state.rng.choice(candidates);
            }

            normalizeAtomCount(atoms, pool, target, avoidLetters, options = {}) {
                if (!atoms) return null;
                const clones = atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
                const required = new Set();
                if (typeof options.requiredIndex === 'number') {
                    required.add(options.requiredIndex);
                }
                if (Array.isArray(options.requiredIndices)) {
                    options.requiredIndices.forEach(idx => required.add(idx));
                }

                const result = [];
                const usedKeys = new Set();
                const pushAtom = (atom) => {
                    const key = atom.toKey();
                    if (usedKeys.has(key)) return false;
                    result.push(atom);
                    usedKeys.add(key);
                    return true;
                };

                for (const idx of required) {
                    if (idx >= 0 && idx < clones.length) {
                        pushAtom(clones[idx]);
                    }
                }

                for (let i = 0; i < clones.length && result.length < target; i++) {
                    if (required.has(i)) continue;
                    pushAtom(clones[i]);
                }

                const poolLetters = pool.length > 0 ? pool : this.state.letters;
                let attempts = 0;
                while (result.length < target && attempts < 200) {
                    attempts++;
                    const head = this.state.rng.choice(poolLetters);
                    if (avoidLetters && avoidLetters.has(head)) continue;
                    let tailCandidates = poolLetters.filter(letter => letter !== head);
                    if (avoidLetters) {
                        tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                    }
                    if (tailCandidates.length === 0) continue;
                    const tail = this.state.rng.choice(tailCandidates);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    const atom = new Atom(axis, head, tail);
                    if (usedKeys.has(atom.toKey())) continue;
                    pushAtom(atom);
                }

                if (result.length !== target) return null;
                return result;
            }

            makeAxisSwapNearMiss({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise || nBackPremise.atoms.length === 0) return null;
                const base = this.cloneAtoms(nBackPremise);
                const index = this.state.rng.nextInt(0, base.length - 1);
                const axisOptions = MATCH_AXES.filter(axis => axis !== base[index].axis);
                if (axisOptions.length === 0) return null;
                base[index] = new Atom(this.state.rng.choice(axisOptions), base[index].head, base[index].tail);
                return this.normalizeAtomCount(base, pool, k, avoidLetters, { requiredIndex: index });
            }

            makeAnchorPermutationNearMiss({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length < 2) return null;
                const anchor = this.state.rng.choice(letters);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of letters) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, null);
            }

            makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise) return null;
                const counts = new Map();
                nBackPremise.atoms.forEach(atom => {
                    counts.set(atom.head, (counts.get(atom.head) || 0) + 1);
                    counts.set(atom.tail, (counts.get(atom.tail) || 0) + 1);
                });
                const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
                if (!sorted.length || sorted[0][1] < 2) return null;
                const hub = sorted[0][0];
                const exclude = new Set(nBackPremise.getLetters());
                let newHub = this.sampleNewLetter(exclude);
                if (!newHub) return null;
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = atom.head === hub ? newHub : atom.head;
                    const tail = atom.tail === hub ? newHub : atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeCycleBorderBait({ k, pool, avoidLetters }) {
                const uniquePool = Array.from(new Set(pool));
                const targetLetters = Math.max(3, Math.min(k + 1, 6));
                const letters = [];
                const used = new Set();
                const shuffled = this.state.rng.shuffle(uniquePool);
                for (const letter of shuffled) {
                    if (letters.length >= targetLetters) break;
                    letters.push(letter);
                    used.add(letter);
                }
                while (letters.length < targetLetters) {
                    const next = this.sampleNewLetter(used);
                    if (!next) break;
                    letters.push(next);
                    used.add(next);
                }
                if (letters.length < 3) return null;
                const axes = ['N', 'E', 'S', 'W'];
                const atoms = [];
                for (let i = 0; i < Math.min(k, letters.length - 1); i++) {
                    const axis = axes[i % axes.length];
                    atoms.push(new Atom(axis, letters[i], letters[i + 1]));
                }
                if (atoms.length < k) {
                    const axis = axes[atoms.length % axes.length];
                    const head = letters[letters.length - 1];
                    const tailIndex = letters.length > 2 ? 1 : 0;
                    atoms.push(new Atom(axis, head, letters[tailIndex]));
                }
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeBipartiteSignatureMatch({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const targetFeatures = nBackPremise.getFeatures();
                for (let attempt = 0; attempt < 12; attempt++) {
                    const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    if (candidate.toKey() === nBackPremise.toKey()) continue;
                    if (!this.compareDegreeVectors(candidate.getFeatures().degreeVector, targetFeatures.degreeVector)) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeWrongLagCamouflage({ trialIndex, n, state, pool, k }) {
                let altPremise = null;
                if (n > 1) {
                    altPremise = state.getPremiseAt(trialIndex - (n - 1));
                }
                if (!altPremise) {
                    altPremise = state.getPremiseAt(trialIndex - (n + 1));
                }
                if (!altPremise) return null;
                for (let attempt = 0; attempt < 10; attempt++) {
                    const atoms = this.buildMatchCandidate(altPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    const equivalence = this.equivalence.computeCertificate(altPremise, candidate, []);
                    if (!equivalence.match) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeCrossAxisCoupling(context) {
                const { nBackPremise, pool, k, plannedMatch, avoidLetters } = context;
                if (!nBackPremise) {
                    return plannedMatch
                        ? this.buildMatchCandidate(nBackPremise, pool, k)
                        : this.buildNovelPremise(pool, k, avoidLetters);
                }
                if (plannedMatch) {
                    for (let attempt = 0; attempt < 12; attempt++) {
                        const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                        if (!atoms) return null;
                        const candidate = new Premise(atoms);
                        if (candidate.toKey() === nBackPremise.toKey()) continue;
                        if (!this.hasCrossAxisCoupling(nBackPremise, candidate)) continue;
                        return atoms;
                    }
                    return null;
                }
                const atoms = this.makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters });
                if (!atoms) return null;
                const candidate = new Premise(atoms);
                return this.hasCrossAxisCoupling(nBackPremise, candidate) ? atoms : null;
            }

            makeIsomorphicSkeletonDecoy({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length === 0) return null;
                const sorted = [...letters].sort();
                const anchor = this.state.rng.choice(sorted);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of sorted) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                const candidate = new Premise(atoms);
                if (candidate.isoSignature() !== nBackPremise.isoSignature()) {
                    return null;
                }
                return this.normalizeAtomCount(candidate.atoms, pool, k, null);
            }

            compareDegreeVectors(a, b) {
                if (a.size !== b.size) return false;
                for (const [letter, vecA] of a.entries()) {
                    const vecB = b.get(letter);
                    if (!vecB) return false;
                    for (let i = 0; i < vecA.length; i++) {
                        if (vecA[i] !== vecB[i]) return false;
                    }
                }
                return true;
            }

            collectAxisUsage(premise) {
                const usage = new Map();
                const mark = (letter, axis) => {
                    if (!usage.has(letter)) {
                        usage.set(letter, { vertical: false, horizontal: false });
                    }
                    const entry = usage.get(letter);
                    if (axis === 'N' || axis === 'S') {
                        entry.vertical = true;
                    } else {
                        entry.horizontal = true;
                    }
                };
                premise.atoms.forEach(atom => {
                    mark(atom.head, atom.axis);
                    mark(atom.tail, atom.axis);
                });
                return usage;
            }

            hasCrossAxisCoupling(p1, p2) {
                const usage1 = this.collectAxisUsage(p1);
                const usage2 = this.collectAxisUsage(p2);
                const letters = new Set([...usage1.keys(), ...usage2.keys()]);
                for (const letter of letters) {
                    const info1 = usage1.get(letter) || { vertical: false, horizontal: false };
                    const info2 = usage2.get(letter) || { vertical: false, horizontal: false };
                    if ((info1.vertical || info2.vertical) && (info1.horizontal || info2.horizontal)) {
                        return true;
                    }
                }
                return false;
            }

            buildMatchCandidate(nBackPremise, pool, k) {
                if (!nBackPremise) return null;
                const atoms = [];
                const nAtoms = nBackPremise.atoms;
                for (let i = 0; i < nAtoms.length; i++) {
                    const atom = nAtoms[i];
                    const invert = this.state.rng.next() < 0.6;
                    atoms.push(invert ? Atom.invert(atom) : new Atom(atom.axis, atom.head, atom.tail));
                }

                while (atoms.length < k) {
                    const head = this.state.rng.choice(pool);
                    const tailOptions = pool.filter(l => l !== head);
                    if (tailOptions.length === 0) break;
                    const tail = this.state.rng.choice(tailOptions);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    atoms.push(new Atom(axis, head, tail));
                }
                return atoms.slice(0, k);
            }

            buildNovelPremise(pool, k, avoidLetters) {
                const atoms = [];
                const usedPairs = new Set();
                const axisWeights = MATCH_AXES.map(axis => 1 / (1 + this.state.axisUsage[axis]));

                for (let i = 0; i < k; i++) {
                    let attempts = 0;
                    while (attempts < 40) {
                        let head = this.state.rng.choice(pool);
                        let tailCandidates = pool.filter(letter => letter !== head);
                        if (avoidLetters && avoidLetters.size > 0) {
                            const filtered = tailCandidates.filter(letter => !avoidLetters.has(letter));
                            if (filtered.length > 0) {
                                tailCandidates = filtered;
                            }
                            if (avoidLetters.has(head)) {
                                const alternatives = pool.filter(letter => !avoidLetters.has(letter));
                                if (alternatives.length > 0) {
                                    head = this.state.rng.choice(alternatives);
                                    tailCandidates = pool.filter(letter => letter !== head && !avoidLetters.has(letter));
                                }
                            }
                        }

                        if (tailCandidates.length === 0) break;
                        const tail = this.state.rng.choice(tailCandidates);
                        const pairKey = `${head}|${tail}`;
                        if (usedPairs.has(pairKey)) {
                            attempts++;
                            continue;
                        }

                        const axis = this.state.rng.weightedChoice(MATCH_AXES, axisWeights);
                        atoms.push(new Atom(axis, head, tail));
                        usedPairs.add(pairKey);
                        break;
                    }
                }

                return atoms.length === k ? atoms : null;
            }

            buildMetaPremise(plannedMatch, nBackPremise, k) {
                // Generate a META_RELATIONAL premise (6th-order reasoning)
                // k controls number of operator pairs: k=2 ‚Üí 4 ops, k=3 ‚Üí 6 ops, k=4 ‚Üí 8 ops
                const META_OPERATORS = ['North', 'South', 'East', 'West'];

                // Determine number of operators needed (k pairs = k*2 operators)
                // Minimum 2 pairs (4 operators) for a valid analogy
                const numPairs = Math.max(2, Math.min(4, k || 2));
                const numOperators = numPairs * 2;

                try {
                    if (plannedMatch && nBackPremise && nBackPremise.type === 'META_RELATIONAL') {
                        // For match trials, create a premise with same truth value
                        const nBackTruth = this.equivalence.getMetaTruthValue(nBackPremise);

                        // Defensive check
                        if (nBackTruth === 'INVALID') {
                            console.warn('buildMetaPremise: n-back has invalid truth value, generating random');
                            const shuffled = this.generateMetaOperators(numOperators);
                            return new Premise({
                                type: 'META_RELATIONAL',
                                p: shuffled
                            });
                        }

                        // Generate premises until we find one with matching truth value
                        for (let attempt = 0; attempt < 50; attempt++) {
                            const shuffled = this.generateMetaOperators(numOperators);

                            try {
                                const candidate = new Premise({
                                    type: 'META_RELATIONAL',
                                    p: shuffled
                                });

                                const candidateTruth = this.equivalence.getMetaTruthValue(candidate);

                                // Accept if truth values match AND not identical to n-back
                                if (candidateTruth === nBackTruth && candidate.toKey() !== nBackPremise.toKey()) {
                                    return candidate;
                                }
                            } catch (err) {
                                console.warn('buildMetaPremise: candidate creation failed', err);
                                continue;
                            }
                        }

                        console.warn('buildMetaPremise: failed to find matching truth value after 50 attempts');
                    }

                    // For non-match or first trials, or fallback, generate a random META premise
                    const shuffled = this.generateMetaOperators(numOperators);
                    return new Premise({
                        type: 'META_RELATIONAL',
                        p: shuffled
                    });
                } catch (err) {
                    console.error('buildMetaPremise: critical error', err);
                    // Ultimate fallback - return a known valid META premise
                    return new Premise({
                        type: 'META_RELATIONAL',
                        p: this.generateMetaOperators(numOperators)
                    });
                }
            }

            generateMetaOperators(numOperators) {
                // Generate numOperators operators, ensuring NO consecutive duplicates
                // Example: ['North', 'South', 'East', 'West'] OK
                // Example: ['North', 'North', 'East', 'West'] INVALID (North-North is identity)
                const META_OPERATORS = ['North', 'South', 'East', 'West'];
                const result = [];

                for (let i = 0; i < numOperators; i++) {
                    let op;
                    let attempts = 0;
                    do {
                        op = this.state.rng.choice(META_OPERATORS);
                        attempts++;
                        // Prevent infinite loop
                        if (attempts > 50) {
                            console.warn('generateMetaOperators: too many attempts to avoid duplicate');
                            break;
                        }
                    } while (i > 0 && op === result[i - 1]);  // No consecutive duplicates

                    result.push(op);
                }

                return result;
            }

            generateCompoundOperator() {
                // Generate a compound operator like "north-west" or "south-east"
                // ALWAYS exactly 2 DIFFERENT operators (no "north-north" identity)
                const META_OPERATORS = ['north', 'south', 'east', 'west'];
                const op1 = this.state.rng.choice(META_OPERATORS);

                // Ensure op2 is different from op1
                const otherOps = META_OPERATORS.filter(op => op !== op1);
                const op2 = this.state.rng.choice(otherOps);

                return `${op1}-${op2}`;
            }

            buildCompoundOperatorPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 7: Compound Operator Relational premise
                // Example: "north-west is north of south-east"
                // k controls number of atoms: k=1 ‚Üí 1 atom, k=2 ‚Üí 2 atoms, etc.

                const numAtoms = Math.max(1, Math.min(4, k || 1));
                const META_AXES = ['N', 'S', 'E', 'W'];
                const atoms = [];

                try {
                    for (let i = 0; i < numAtoms; i++) {
                        // Generate two compound operators (always 2-operator sequences)
                        const compound1 = this.generateCompoundOperator();
                        const compound2 = this.generateCompoundOperator();

                        // Choose random meta-operator to relate them
                        const metaAxis = this.state.rng.choice(META_AXES);

                        // Create atom with compound operators as head/tail
                        atoms.push(new Atom(metaAxis, compound1, compound2));
                    }

                    return new Premise(atoms);
                } catch (err) {
                    console.error('buildCompoundOperatorPremise: critical error', err);
                    // Fallback to simple compound premise
                    return new Premise([new Atom('N', 'north-west', 'south-east')]);
                }
            }

        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // iOS-SPECIFIC FEMALE VOICE ENFORCEMENT SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // This VoiceSynthesis class implements comprehensive iOS Safari
        // Web Speech API bug workarounds to prevent male voice (Reed) usage.
        //
        // iOS CRITICAL BUGS FIXED:
        //
        // 1. VOICE OBJECT STALENESS (PRIMARY BUG):
        //    - Voice objects from getVoices() become "stale" when cached
        //    - Stale voice objects assigned to utterance.voice are IGNORED
        //    - iOS falls back to system default voice (Reed - MALE)
        //    - FIX: Store voiceName + voiceLang as STRINGS only
        //    - FIX: Call getFreshVoiceObject() before EVERY speak()
        //
        // 2. DUAL PROPERTY REQUIREMENT:
        //    - iOS requires BOTH utterance.voice AND utterance.lang set
        //    - Setting only ONE property causes iOS to IGNORE both
        //    - iOS falls back to default voice (Reed - MALE)
        //    - FIX: Always set both properties together in speak()
        //
        // 3. ONE VOICE PER LOCALE LIMITATION:
        //    - iOS allows only ONE voice per locale to be selected
        //    - For en-US, that voice is Samantha (FEMALE) - this is GOOD
        //    - Attempting other en-US voices causes fallback to Reed
        //    - FIX: Priority cascade locks to Samantha for iOS
        //
        // 4. ASYNCHRONOUS VOICE LOADING:
        //    - getVoices() returns empty array on first call
        //    - voiceschanged event is unreliable/never fires on Safari
        //    - FIX: Polling mechanism (250ms interval, 3000ms timeout)
        //
        // 5. USER GESTURE REQUIREMENT:
        //    - iOS requires speechSynthesis triggered from user interaction
        //    - FIX: unlockIOSSpeech() speaks empty utterance on button click
        //
        // SAFETY LAYERS:
        // - Layer 1: Null check - refuse if voiceName/voiceLang null
        // - Layer 2: Male voice pattern check - refuse if matches Reed, etc.
        // - Layer 3: Female voice confirmation - warn if no female match
        // - Layer 4: utterance.voice verification - refuse if not set
        // - Layer 5: iOS dual-property check - refuse if only one set
        // - Layer 6: Final male voice check - refuse if assigned voice is male
        //
        // All safety checks REFUSE TO SPEAK rather than risk default voice.
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        class VoiceSynthesis {
            constructor() {
                this.synth = window.speechSynthesis;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL FIX: Store voice NAME and LANG, NOT voice object
                // Voice objects become "stale" on iOS and cause fallback to Reed
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.voiceName = null;          // Store voice name as string
                this.voiceLang = null;          // Store voice lang as string
                this.voiceReady = false;
                this.pitch = 1.2;
                this.rate = 0.9;
                this.volume = 1.0;
                this.sessionToken = makeEpoch();

                // iOS-specific flags
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                            (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                this.iosGestureUnlocked = false;

                console.log(`üé§ VoiceSynthesis initialized - Platform: ${this.isIOS ? 'iOS' : 'Desktop'}`);
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: User Gesture Unlock
            // iOS requires speechSynthesis to be triggered from user interaction
            // Call this on voice-mode button click to unlock speech for session
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            unlockIOSSpeech() {
                if (!this.isIOS || this.iosGestureUnlocked) {
                    return;
                }

                try {
                    // Speak empty utterance to unlock iOS speech synthesis
                    const unlockUtterance = new SpeechSynthesisUtterance('');
                    unlockUtterance.volume = 0;
                    this.synth.speak(unlockUtterance);
                    this.iosGestureUnlocked = true;
                    console.log('‚úì iOS speech synthesis unlocked via user gesture');
                } catch (err) {
                    console.warn('iOS gesture unlock failed:', err);
                }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: Polling-Based Voice Loading
            // iOS Safari returns empty array on first getVoices() call
            // voiceschanged event is unreliable - use polling instead
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            async initialize() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`  Initializing voice system - Platform: ${this.isIOS ? 'iOS' : 'Desktop'}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // iOS: Unlock speech from user gesture (if not already done)
                if (this.isIOS) {
                    this.unlockIOSSpeech();
                }

                return new Promise((resolve, reject) => {
                    let pollAttempts = 0;
                    const maxPollAttempts = 12; // 12 √ó 250ms = 3000ms max wait
                    const pollIntervalMs = 250; // Poll every 250ms

                    let pollInterval = null;
                    let pollTimeout = null;

                    const stopPolling = () => {
                        if (pollInterval) clearInterval(pollInterval);
                        if (pollTimeout) clearTimeout(pollTimeout);
                    };

                    // Polling function
                    const pollForVoices = () => {
                        pollAttempts++;
                        console.log(`üì¢ Polling for voices... attempt ${pollAttempts}/${maxPollAttempts}`);

                        try {
                            const voices = this.synth.getVoices();
                            console.log(`  Retrieved ${voices?.length || 0} voices from speechSynthesis.getVoices()`);

                            if (voices && voices.length > 0) {
                                // SUCCESS: Voices loaded
                                stopPolling();
                                console.log(`‚úì Voices loaded successfully after ${pollAttempts} attempts`);

                                try {
                                    this.selectVoice(voices);
                                    this.voiceReady = true;
                                    console.log(`‚úì Voice system initialized: ${this.voiceName || 'null'} (${this.voiceLang || 'null'})`);
                                    resolve();
                                } catch (err) {
                                    console.error('Voice selection failed:', err);
                                    reject(err);
                                }
                            }
                        } catch (error) {
                            console.error('Polling error:', error);
                            stopPolling();
                            reject(error);
                        }
                    };

                    // Timeout handler
                    pollTimeout = setTimeout(() => {
                        stopPolling();
                        console.error('‚úó Voice loading timeout after 3000ms');
                        reject(new Error('Voice loading timeout - no voices available'));
                    }, 3000);

                    // Start polling every 250ms
                    pollInterval = setInterval(pollForVoices, pollIntervalMs);

                    // Immediate first attempt
                    pollForVoices();

                    // Also listen for voiceschanged event (unreliable on iOS but doesn't hurt)
                    if (this.synth.onvoiceschanged !== undefined) {
                        this.synth.onvoiceschanged = () => {
                            console.log('  voiceschanged event fired (backup trigger)');
                            pollForVoices();
                        };
                    }
                });
            }

            selectVoice(voices) {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('    ULTRA-COMPREHENSIVE FEMALE-ONLY VOICE SELECTION (ANY LANGUAGE)');
                console.log('    USER REQUIREMENT: ANY female voice, ZERO male voices');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Total voices available: ${voices.length}`);

                // Log all available voices for debugging
                voices.forEach((v, idx) => {
                    console.log(`  [${idx}] ${v.name} (${v.lang}) - ${v.localService ? 'local' : 'remote'}`);
                });

                // Detect platform
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                const platform = isIOS ? 'iOS' : 'Desktop';
                console.log(`Platform detected: ${platform}`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 1: WESTERN-ONLY LANGUAGE WHITELIST
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const westernLanguageCodes = [
                    'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',
                    'en', // Generic English
                    'fr-FR', 'fr-CA', 'fr-BE', 'fr-CH',
                    'de-DE', 'de-AT', 'de-CH',
                    'es-ES', 'es-MX', 'es-AR',
                    'it-IT', 'it-CH',
                    'pt-PT', 'pt-BR',
                    'nl-NL', 'nl-BE',
                    'sv-SE',
                    'da-DK',
                    'no-NO',
                    'fi-FI',
                    'pl-PL',
                    'cs-CZ',
                    'hu-HU',
                    'ro-RO',
                    'el-GR'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 2: NON-WESTERN LANGUAGE/ACCENT EXCLUSION (COMPLETE BLACKLIST)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const nonWesternLanguageCodes = [
                    // INDIAN LANGUAGES (ALL INDIAN ACCENTS - CRITICAL EXCLUSION)
                    'hi-IN', 'hi', 'ta-IN', 'ta', 'bn-IN', 'bn', 'te-IN', 'te',
                    'mr-IN', 'mr', 'gu-IN', 'gu', 'kn-IN', 'kn', 'ml-IN', 'ml',
                    'pa-IN', 'pa', 'or-IN', 'or', 'as-IN', 'as', 'ur-IN', 'ur',

                    // CHINESE LANGUAGES
                    'zh-CN', 'zh-TW', 'zh-HK', 'zh', 'cmn', 'yue', 'nan',

                    // JAPANESE
                    'ja-JP', 'ja',

                    // KOREAN
                    'ko-KR', 'ko',

                    // ARABIC LANGUAGES
                    'ar-SA', 'ar-EG', 'ar-AE', 'ar-DZ', 'ar', 'ar-MA', 'ar-TN',
                    'ar-IQ', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-OM', 'ar-QA',

                    // RUSSIAN/SLAVIC (non-Western European)
                    'ru-RU', 'ru', 'uk-UA', 'uk', 'be-BY', 'be',

                    // THAI
                    'th-TH', 'th',

                    // VIETNAMESE
                    'vi-VN', 'vi',

                    // INDONESIAN/MALAY
                    'id-ID', 'id', 'ms-MY', 'ms',

                    // TURKISH
                    'tr-TR', 'tr',

                    // PERSIAN
                    'fa-IR', 'fa',

                    // HEBREW
                    'he-IL', 'he', 'iw-IL', 'iw'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 3: EXHAUSTIVE MALE VOICE EXCLUSION LIST (100+ NAMES)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const maleVoiceNames = [
                    // ‚ïê‚ïê‚ïê COMMON ENGLISH MALE VOICES ‚ïê‚ïê‚ïê
                    'Alex', 'Daniel', 'Fred', 'Tom', 'Thomas', 'Oliver', 'Ralph',
                    'Bruce', 'James', 'John', 'Nathan', 'Aaron', 'Jorge', 'Diego',
                    'Timothy', 'Mark', 'David', 'Richard', 'Chris', 'Christopher',
                    'Matthew', 'Paul', 'George', 'Kevin', 'Jason', 'Michael', 'Robert',
                    'William', 'Joseph', 'Charles', 'Steven', 'Edward', 'Brian',
                    'Andrew', 'Anthony', 'Donald', 'Kenneth', 'Joshua', 'Brandon',
                    'Justin', 'Ryan', 'Eric', 'Nicholas', 'Jacob', 'Jonathan',
                    'Samuel', 'Benjamin', 'Patrick', 'Alexander', 'Jack', 'Henry',
                    'Oscar', 'Adam', 'Ethan', 'Noah', 'Liam', 'Mason', 'Logan',
                    'Lucas', 'Isaac', 'Nathan', 'Caleb', 'Christian', 'Hunter',
                    'Jordan', 'Dylan', 'Brandon', 'Jose', 'Austin', 'Evan',
                    'Sean', 'Tyler', 'Kyle', 'Ian', 'Carter', 'Xavier',

                    // ‚ïê‚ïê‚ïê CRITICAL iOS/macOS MALE VOICES (PREVIOUSLY MISSING - MOST LIKELY CULPRITS) ‚ïê‚ïê‚ïê
                    'Reed', 'Reed (Enhanced)', 'Reed (Compact)',
                    'Rocko', 'Rocko (Enhanced)', 'Rocko (Compact)',
                    'Lee', 'Lee (Enhanced)', 'Lee (Compact)',
                    'Gordon', 'Gordon (Enhanced)', 'Gordon (Compact)',
                    'Martin', 'Martin (Enhanced)', 'Martin (Compact)',
                    'Xander', 'Xander (Enhanced)', 'Xander (Compact)',
                    'Yuri', 'Yuri (Enhanced)', 'Yuri (Compact)',
                    'Otoya', 'Otoya (Enhanced)', 'Otoya (Compact)',
                    'Maged', 'Maged (Enhanced)', 'Maged (Compact)',
                    'Majed', 'Majed (Enhanced)', 'Majed (Compact)',
                    'Tarik', 'Tarik (Enhanced)', 'Tarik (Compact)',

                    // ‚ïê‚ïê‚ïê ADDITIONAL iOS/macOS MALE VOICES ‚ïê‚ïê‚ïê
                    'Carmit', 'Carmit (Enhanced)', 'Carmit (Compact)',
                    'Lekha', 'Lekha (Enhanced)', 'Lekha (Compact)',
                    'Lesya', 'Lesya (Enhanced)', 'Lesya (Compact)',
                    'Luca', 'Luca (Enhanced)', 'Luca (Compact)',
                    'Maged', 'Majed', 'Tarik',
                    'Yannick', 'Yannick (Enhanced)', 'Yannick (Compact)',
                    'Steffi', 'Steffi (Enhanced)', 'Steffi (Compact)',
                    'Yuri', 'Yuri (Enhanced)', 'Yuri (Compact)',
                    'Xander', 'Xander (Enhanced)', 'Xander (Compact)',

                    // ‚ïê‚ïê‚ïê SIRI MALE VARIANTS (ALL) ‚ïê‚ïê‚ïê
                    'Siri Male', 'Siri Male (Enhanced)', 'Siri Male (Compact)',
                    'Siri Male #1', 'Siri Male #2', 'Siri Male #3', 'Siri Male #4',

                    // ‚ïê‚ïê‚ïê INDIAN MALE VOICES (CRITICAL EXCLUSION - RISHI) ‚ïê‚ïê‚ïê
                    'Rishi', 'Prabhat', 'Hemant', 'Swara', 'Kalpana',

                    // ‚ïê‚ïê‚ïê MICROSOFT MALE VOICES ‚ïê‚ïê‚ïê
                    'Microsoft David', 'Microsoft Mark', 'Microsoft Paul',
                    'Microsoft George', 'Microsoft Rishi', 'Microsoft James',
                    'Microsoft Sean', 'Microsoft Guy', 'Microsoft Michael',
                    'Microsoft David Desktop', 'Microsoft Mark Desktop',

                    // ‚ïê‚ïê‚ïê GOOGLE MALE VOICES ‚ïê‚ïê‚ïê
                    'Google UK English Male', 'Google US English Male',
                    'Google Hindi Male', 'Google Tamil Male', 'Google Bengali Male',
                    'Google French Male', 'Google German Male', 'Google Spanish Male',
                    'Google Italian Male', 'Google Portuguese Male',
                    'Google Arabic Male', 'Google Russian Male', 'Google Japanese Male',
                    'Google Korean Male', 'Google Chinese Male', 'Google Dutch Male',

                    // ‚ïê‚ïê‚ïê APPLE/iOS MALE VOICES (ALL VARIANTS) ‚ïê‚ïê‚ïê
                    'Alex (Enhanced)', 'Fred (Enhanced)', 'Daniel (Compact)',
                    'Oliver (Enhanced)', 'Ralph (Compact)', 'Tom (Compact)',
                    'Alex (Compact)', 'Fred (Compact)', 'Daniel (Enhanced)',
                    'Oliver (Compact)', 'Ralph (Enhanced)', 'Thomas (Enhanced)',
                    'Tom (Enhanced)', 'Bruce (Enhanced)', 'Bruce (Compact)',
                    'James (Enhanced)', 'James (Compact)', 'John (Enhanced)', 'John (Compact)',

                    // ‚ïê‚ïê‚ïê NOVELTY/OTHER PLATFORM MALE VOICES ‚ïê‚ïê‚ïê
                    'Albert', 'Bad News', 'Bahh', 'Bells', 'Boing', 'Bubbles',
                    'Cellos', 'Deranged', 'Good News', 'Hysterical', 'Junior',
                    'Pipe Organ', 'Trinoids', 'Whisper', 'Wobble', 'Zarvox',

                    // ‚ïê‚ïê‚ïê ADDITIONAL PLATFORM-SPECIFIC MALE VOICES ‚ïê‚ïê‚ïê
                    'Eddy', 'Grandpa', 'Rocky', 'Shelley', 'Superstar',
                    'Jacques', 'Henri', 'Antoine', 'Pierre', 'Marc',
                    'Klaus', 'Hans', 'Markus',
                    'Carlos', 'Juan', 'Luis', 'Miguel', 'Pablo',
                    'Luca', 'Paolo', 'Marco', 'Giorgio', 'Matteo',

                    // ‚ïê‚ïê‚ïê EUROPEAN/MULTILINGUAL MALE VOICES ‚ïê‚ïê‚ïê
                    'Diego', 'Diego (Enhanced)', 'Diego (Compact)',
                    'Jorge', 'Jorge (Enhanced)', 'Jorge (Compact)',
                    'Juan', 'Juan (Enhanced)', 'Juan (Compact)',
                    'Tomas', 'Tomas (Enhanced)', 'Tomas (Compact)',
                    'Damien', 'Damien (Enhanced)', 'Damien (Compact)',
                    'Nicolas', 'Nicolas (Enhanced)', 'Nicolas (Compact)',
                    'Matthias', 'Matthias (Enhanced)', 'Matthias (Compact)',
                    'Viktor', 'Viktor (Enhanced)', 'Viktor (Compact)',
                    'Marko', 'Marko (Enhanced)', 'Marko (Compact)'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 4: EXHAUSTIVE MALE VOICE REGEX PATTERNS
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const malePatterns = [
                    // Common male names
                    /\balex\b/i, /\bdaniel\b/i, /\bfred\b/i, /\btom\b/i, /\bthomas\b/i,
                    /\boliver\b/i, /\bralph\b/i, /\bbruce\b/i, /\bjames\b/i, /\bjohn\b/i,
                    /\bnathan\b/i, /\baaron\b/i, /\bjorge\b/i, /\bdiego\b/i,
                    /\btimothy\b/i, /\bmark\b/i, /\bdavid\b/i, /\brichard\b/i,
                    /\bchris\b/i, /\bchristopher\b/i, /\bmatthew\b/i, /\bpaul\b/i,
                    /\bgeorge\b/i, /\bkevin\b/i, /\bjason\b/i, /\bmichael\b/i,
                    /\brobert\b/i, /\bwilliam\b/i, /\bjoseph\b/i, /\bcharles\b/i,
                    /\bsteven\b/i, /\bedward\b/i, /\bbrian\b/i, /\bandrew\b/i,
                    /\banthony\b/i, /\bdonald\b/i, /\bkenneth\b/i, /\bjoshua\b/i,
                    /\bjustin\b/i, /\bryan\b/i, /\beric\b/i, /\bjacob\b/i,
                    /\bpatrick\b/i, /\balexander\b/i, /\bjack\b/i, /\bhenry\b/i,
                    /\bethan\b/i, /\bnoah\b/i, /\bliam\b/i, /\bmason\b/i,
                    /\btyler\b/i, /\bkyle\b/i, /\bdylan\b/i, /\badam\b/i,
                    /\bsean\b/i, /\bcarlos\b/i, /\bjuan\b/i, /\bluis\b/i,

                    // CRITICAL iOS/macOS MALE VOICES (PREVIOUSLY MISSING - MOST LIKELY CULPRITS)
                    /\breed\b/i, /\brocko\b/i, /\blee\b/i, /\bgordon\b/i,
                    /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                    /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i,

                    // ADDITIONAL iOS/macOS MALE PATTERNS
                    /\bcarmit\b/i, /\blekha\b/i, /\blesya\b/i,
                    /\btomas\b/i, /\bdamien\b/i, /\bnicolas\b/i,
                    /\bmatthias\b/i, /\bviktor\b/i, /\bmarko\b/i,
                    /\bluca\b/i, /\bpaolo\b/i, /\bmarco\b/i, /\bgiorgio\b/i, /\bmatteo\b/i,
                    /\bjacques\b/i, /\bhenri\b/i, /\bantoine\b/i, /\bpierre\b/i, /\bmarc\b/i,
                    /\bklaus\b/i, /\bhans\b/i, /\bmarkus\b/i, /\byannick\b/i,
                    /\beddy\b/i, /\bgrandpa\b/i, /\brocky\b/i, /\bshelley\b/i, /\bsuperstar\b/i,

                    // SIRI MALE PATTERNS
                    /siri.*male/i, /male.*siri/i,

                    // INDIAN MALE VOICES (CRITICAL EXCLUSION - RISHI + ALL INDIAN NAMES)
                    /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i,

                    // Generic male indicators
                    /\bmale\b/i, /\bman\b/i, /\b\(m\)\b/i, /\bmale voice\b/i,
                    /\bguy\b/i, /\bdude\b/i, /\bboy\b/i, /\bmr\b/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 5: INDIAN VOICE EXCLUSION (NAME-BASED)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const indianVoiceNames = [
                    // ALL INDIAN VOICES (BOTH MALE AND FEMALE)
                    'Rishi', 'Prabhat', 'Hemant', 'Swara', 'Kalpana',
                    'Lekha', 'Raveena', 'Veena',
                    'Aditi', 'Anjali', 'Divya', 'Kavya', 'Priya', 'Shreya'
                ];

                const indianVoicePatterns = [
                    /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i, /\bswara\b/i, /\bkalpana\b/i,
                    /\blekha\b/i, /\braveena\b/i, /\bveena\b/i,
                    /\baditi\b/i, /\banjali\b/i, /\bdivya\b/i, /\bkavya\b/i,
                    /\bpriya\b/i, /\bshreya\b/i,
                    /hindi/i, /tamil/i, /bengali/i, /telugu/i, /marathi/i, /gujarati/i,
                    /indian/i, /india/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 6: COMPREHENSIVE WESTERN FEMALE VOICE INCLUSION LIST (50+)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const femaleVoiceNames = [
                    // ‚ïê‚ïê‚ïê COMMON ENGLISH FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Samantha', 'Karen', 'Victoria', 'Susan', 'Zoe', 'Moira',
                    'Tessa', 'Fiona', 'Nicky', 'Serena', 'Hazel', 'Zira',
                    'Aria', 'Eva', 'Ava', 'Emma', 'Emily', 'Sarah', 'Kate',
                    'Anna', 'Lauren', 'Jessica', 'Jennifer', 'Michelle',
                    'Catherine', 'Elizabeth', 'Amanda', 'Rebecca', 'Nicole',
                    'Stephanie', 'Melissa', 'Ashley', 'Heather', 'Rachel',
                    'Amy', 'Laura', 'Angela', 'Kimberly', 'Lisa', 'Mary',
                    'Sandra', 'Nancy', 'Betty', 'Dorothy', 'Helen', 'Deborah',
                    'Donna', 'Carol', 'Ruth', 'Sharon', 'Cynthia',

                    // ‚ïê‚ïê‚ïê MICROSOFT WESTERN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Microsoft Zira', 'Microsoft Hazel', 'Microsoft Susan',
                    'Microsoft Zira Desktop', 'Microsoft Zira - English (United States)',
                    'Microsoft Linda', 'Microsoft Heather', 'Microsoft Laura',

                    // ‚ïê‚ïê‚ïê GOOGLE WESTERN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Google UK English Female', 'Google US English Female',
                    'Google Australian Female', 'Google French Female',
                    'Google German Female', 'Google Spanish Female',
                    'Google Italian Female', 'Google Portuguese Female',

                    // ‚ïê‚ïê‚ïê APPLE/iOS FEMALE VOICES (ALL VARIANTS) ‚ïê‚ïê‚ïê
                    'Samantha (Enhanced)', 'Karen (Enhanced)', 'Moira (Enhanced)',
                    'Tessa (Enhanced)', 'Victoria (Enhanced)', 'Fiona (Enhanced)',
                    'Samantha (Compact)', 'Karen (Compact)', 'Moira (Compact)',
                    'Tessa (Compact)', 'Victoria (Compact)', 'Fiona (Compact)',

                    // iOS format variations: "Name - Language (Country)"
                    'Samantha - English (United States)', 'Samantha - English (US)',
                    'Karen - English (Australia)', 'Karen - English (Australian)',
                    'Moira - English (Ireland)', 'Moira - English (Irish)',
                    'Tessa - English (South Africa)', 'Tessa - English (South African)',
                    'Victoria - English (United States)', 'Victoria - English (US)',
                    'Fiona - English (Scotland)', 'Fiona - English (Scottish)',
                    'Nicky - English (United States)', 'Serena - English (United Kingdom)',

                    // iOS format variations: "Name (Country Code)"
                    'Samantha (US)', 'Karen (AU)', 'Moira (IE)', 'Tessa (ZA)',
                    'Victoria (US)', 'Fiona (GB)', 'Nicky (US)', 'Serena (GB)',

                    // ‚ïê‚ïê‚ïê SIRI VARIANTS ‚ïê‚ïê‚ïê
                    'Siri Female', 'Siri Female (Enhanced)', 'Siri Female (Compact)',
                    'Siri (Female)', 'Siri - Female', 'Female Siri',

                    // ‚ïê‚ïê‚ïê EUROPEAN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Amelie', 'Audrey', 'Aurelie', 'Celine', 'Chantal',
                    'Marie', 'Sophie', 'Yelda', 'Zofia', 'Petra', 'Vicki',
                    'Katja', 'Sabina', 'Carmit', 'Kyoko', 'Luciana', 'Joana'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 7: WESTERN FEMALE VOICE REGEX PATTERNS (EXPANDED FOR iOS)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const femalePatterns = [
                    // Core female names (iOS/macOS primary)
                    /\bsamantha\b/i, /\bkaren\b/i, /\bvictoria\b/i, /\bsusan\b/i,
                    /\bzoe\b/i, /\bmoira\b/i, /\btessa\b/i, /\bfiona\b/i,
                    /\bnicky\b/i, /\bserena\b/i, /\bhazel\b/i, /\bzira\b/i,

                    // Additional common female names
                    /\baria\b/i, /\beva\b/i, /\bava\b/i, /\bemma\b/i,
                    /\bemily\b/i, /\bsarah\b/i, /\bkate\b/i, /\banna\b/i,
                    /\blauren\b/i, /\bjessica\b/i, /\bjennifer\b/i, /\bmichelle\b/i,
                    /\bcatherine\b/i, /\belizabeth\b/i, /\bamanda\b/i,
                    /\brebecca\b/i, /\bnicole\b/i, /\bstephanie\b/i, /\bmelissa\b/i,
                    /\bashley\b/i, /\bheather\b/i, /\brachel\b/i, /\bamy\b/i,
                    /\blaura\b/i, /\bangela\b/i, /\blisa\b/i, /\bmary\b/i,

                    // European female names
                    /\bamelie\b/i, /\baudrey\b/i, /\bceline\b/i, /\bmarie\b/i,
                    /\bsophie\b/i, /\bpietra\b/i, /\bvicki\b/i, /\bkatja\b/i,
                    /\bjoana\b/i, /\bluciana\b/i, /\bcarmit\b/i, /\bkyoko\b/i,

                    // Generic female indicators
                    /\bfemale\b/i, /\bwoman\b/i, /\b\(f\)\b/i, /\bfemale voice\b/i,
                    /\bsiri.*female\b/i, /female.*siri/i, /\blady\b/i, /\bgirl\b/i,
                    /\bms\b/i, /\bmiss\b/i, /\bmrs\b/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SIMPLIFIED FILTERING: EXCLUDE MALES ONLY, ACCEPT ALL OTHERS
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // USER REQUIREMENT: "I just want a female voice, it doesn't have to be western"
                // NEW APPROACH: Inverse logic - reject ONLY male voices, accept everything else

                console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  FILTERING: REMOVING MALE VOICES ONLY (ANY LANGUAGE)   ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                const femaleVoices = voices.filter(voice => {
                    const voiceName = voice.name;

                    // Check by male name (comprehensive list)
                    const isMaleName = maleVoiceNames.some(maleName =>
                        voiceName.toLowerCase() === maleName.toLowerCase() ||
                        voiceName.toLowerCase().includes(maleName.toLowerCase())
                    );

                    // Check by male pattern (regex)
                    const isMalePattern = malePatterns.some(pattern =>
                        pattern.test(voiceName)
                    );

                    if (isMaleName || isMalePattern) {
                        console.log(`  ‚úó‚úó‚úó EXCLUDED (MALE VOICE): ${voiceName} (${voice.lang})`);
                        return false;
                    }

                    console.log(`  ‚úì‚úì‚úì ACCEPTED (FEMALE/NON-MALE): ${voiceName} (${voice.lang})`);
                    return true;
                });

                console.log(`\nAfter male voice filtering: ${femaleVoices.length} voices remain (${voices.length - femaleVoices.length} male voices EXCLUDED)`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRITICAL RULE: If NO non-male voices exist, FAIL HARD
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if (femaleVoices.length === 0) {
                    console.error('\n‚úó‚úó‚úó CRITICAL FAILURE ‚úó‚úó‚úó');
                    console.error('NO FEMALE VOICES AVAILABLE!');
                    console.error('All available voices matched male exclusion patterns.');
                    this.voiceName = null;
                    this.voiceLang = null;
                    this.showVoiceWarning('ERROR: Only male voices available on this system!');
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('   VOICE SELECTION FAILED (No female voices found)');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                    return;
                }

                const finalVoicePool = femaleVoices;

                console.log(`FINAL VOICE POOL SIZE: ${finalVoicePool.length} female voices (any language)`);
                console.log(`  (${voices.length} original ‚Üí ${finalVoicePool.length} after male exclusion)\n`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TIER 1: PLATFORM-SPECIFIC PRIORITY LISTS (PREFERRED VOICES)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const iOSFemalePriority = [
                    'Samantha',
                    'Samantha (Enhanced)',
                    'Karen',
                    'Karen (Enhanced)',
                    'Moira',
                    'Moira (Enhanced)',
                    'Tessa',
                    'Tessa (Enhanced)',
                    'Victoria',
                    'Victoria (Enhanced)',
                    'Fiona',
                    'Fiona (Enhanced)',
                    'Nicky',
                    'Serena',
                    'Siri Female',
                    'Siri Female (Enhanced)',
                    'Siri Female (Compact)'
                ];

                const desktopFemalePriority = [
                    'Samantha',
                    'Victoria',
                    'Karen',
                    'Susan',
                    'Zoe',
                    'Hazel',
                    'Zira',
                    'Microsoft Zira',
                    'Microsoft Zira Desktop',
                    'Microsoft Hazel',
                    'Microsoft Susan',
                    'Google US English Female',
                    'Google UK English Female',
                    'Google Australian Female'
                ];

                const priorityList = isIOS ? iOSFemalePriority : desktopFemalePriority;

                console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  TIER 1: PRIORITY LIST MATCHING                       ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                for (const priorityName of priorityList) {
                    console.log(`  Trying priority voice: ${priorityName}`);
                    const match = finalVoicePool.find(v => v.name === priorityName);
                    if (match) {
                        console.log(`  ‚úì‚úì‚úì PRIORITY VOICE FOUND: ${match.name} (${match.lang})`);

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // FINAL SAFETY NET: Verify this is NOT a male voice (should never happen)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        const voiceName = match.name;
                        const isMaleName = maleVoiceNames.some(maleName =>
                            voiceName.toLowerCase().includes(maleName.toLowerCase())
                        );
                        const isMalePattern = malePatterns.some(pattern => pattern.test(voiceName));

                        if (isMaleName || isMalePattern) {
                            console.error(`  ‚úó‚úó‚úó SAFETY BLOCK: Priority voice "${voiceName}" matched MALE pattern! Skipping.`);
                            continue;
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: Store name and lang as STRINGS, not object
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        this.voiceName = match.name;
                        this.voiceLang = match.lang;
                        this.persistVoice(match, this.isIOS);
                        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log(`   VOICE SELECTION COMPLETE: ${this.voiceName} (${this.voiceLang})`);
                        console.log('   (Stored as name+lang strings for iOS compatibility)');
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                        return;
                    }
                }
                console.log('  No priority matches found');

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TIER 2: USE FIRST VOICE FROM FILTERED POOL
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  TIER 2: SELECTING FIRST FEMALE VOICE FROM POOL        ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                if (finalVoicePool.length > 0) {
                    const candidateVoice = finalVoicePool[0];
                    const voiceName = candidateVoice.name;

                    console.log(`  Candidate voice: ${voiceName} (${candidateVoice.lang})`);

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // FINAL SAFETY NET: Verify this is NOT a male voice (should never happen)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    const isMaleName = maleVoiceNames.some(maleName =>
                        voiceName.toLowerCase().includes(maleName.toLowerCase())
                    );
                    const isMalePattern = malePatterns.some(pattern => pattern.test(voiceName));

                    if (isMaleName || isMalePattern) {
                        console.error(`  ‚úó‚úó‚úó SAFETY BLOCK: Candidate voice "${voiceName}" matched MALE pattern!`);
                        console.error('  This should never happen - male voice in female pool!');
                        this.voiceName = null;
                        this.voiceLang = null;
                        this.showVoiceWarning('ERROR: Male voice detected in female pool! Refusing assignment for safety.');
                        return;
                    }

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // iOS CRITICAL: Store name and lang as STRINGS, not object
                    // Voice passed male exclusion filter, so it's female - ACCEPT IT
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    this.voiceName = candidateVoice.name;
                    this.voiceLang = candidateVoice.lang;
                    console.log(`  ‚úì‚úì‚úì SELECTED: ${this.voiceName} (${this.voiceLang})`);
                    this.persistVoice(candidateVoice, this.isIOS);
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`   VOICE SELECTION COMPLETE: ${this.voiceName} (${this.voiceLang})`);
                    console.log('   (Stored as name+lang strings for iOS compatibility)');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                    return;
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRITICAL FAILURE - No suitable voices exist
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.error('\n‚úó‚úó‚úó CRITICAL FAILURE ‚úó‚úó‚úó');
                console.error('No female voices available on this device!');
                console.error('All available voices matched male exclusion patterns.');
                console.error('This should not happen on iPhone - investigating available voices:');
                voices.forEach((v, idx) => {
                    console.error(`  [${idx}] ${v.name} (${v.lang})`);
                });
                this.voiceName = null;
                this.voiceLang = null;
                this.showVoiceWarning('ERROR: No female voice available on this device!');
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('   VOICE SELECTION FAILED');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            }

            // Helper method to persist voice selection with platform awareness
            persistVoice(voice, isIOS) {
                localStorage.setItem('relational-nback-voice-name', voice.name);
                localStorage.setItem('relational-nback-voice-lang', voice.lang);
                localStorage.setItem('relational-nback-voice-platform', isIOS ? 'ios' : 'desktop');
                console.log('Persisted voice:', voice.name, voice.lang, isIOS ? 'ios' : 'desktop');
            }

            // Method to reset voice selection (for manual override)
            resetVoiceSelection() {
                localStorage.removeItem('relational-nback-voice-name');
                localStorage.removeItem('relational-nback-voice-lang');
                localStorage.removeItem('relational-nback-voice-platform');
                this.voiceName = null;
                this.voiceLang = null;
                console.log('Voice selection reset');
            }

            // Display warning to user about voice selection issues
            showVoiceWarning(message) {
                console.warn(`VOICE WARNING: ${message}`);

                // Update voice-info element if it exists
                const voiceInfoEl = document.getElementById('voice-info');
                if (voiceInfoEl) {
                    voiceInfoEl.innerHTML = `<span style="color: #e74c3c;">‚ö† ${message}</span>`;
                }

                // Optionally show alert for critical issues
                if (message.includes('ERROR')) {
                    setTimeout(() => {
                        alert(`Voice System Warning:\n\n${message}\n\nThe game may not work correctly without a suitable voice.`);
                    }, 500);
                }
            }

            getVoiceInfo() {
                return this.voiceName ? `${this.voiceName} (${this.voiceLang})` : 'Voice not initialized';
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: Get FRESH voice object from getVoices()
            // NEVER return cached voice object - causes staleness on iOS
            // This method is called by speak() before EVERY utterance
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            getFreshVoiceObject() {
                if (!this.voiceName || !this.voiceLang) {
                    console.error('getFreshVoiceObject: No voice selected (voiceName/voiceLang null)');
                    return null;
                }

                try {
                    const voices = this.synth.getVoices();

                    if (!voices || voices.length === 0) {
                        console.error('getFreshVoiceObject: getVoices() returned empty array');
                        return null;
                    }

                    // Find voice by name AND lang (exact match)
                    const freshVoice = voices.find(v =>
                        v.name === this.voiceName &&
                        v.lang === this.voiceLang
                    );

                    if (freshVoice) {
                        console.log(`‚úì Fresh voice object retrieved: ${freshVoice.name} (${freshVoice.lang})`);
                        return freshVoice;
                    }

                    // FALLBACK: Selected voice not found - try to find ANY female voice
                    console.warn(`Selected voice "${this.voiceName}" (${this.voiceLang}) not found in current getVoices()`);
                    console.warn('Attempting fallback to ANY available female voice...');

                    // Use the same male exclusion logic as selectVoice()
                    const maleVoiceNames = ['Reed', 'Alex', 'Daniel', 'Fred', 'Tom', 'Thomas', 'Oliver', 'Ralph', 'Bruce', 'James', 'Rishi', 'Rocko', 'Lee', 'Gordon', 'Martin', 'Xander', 'Yuri'];
                    const malePatterns = [/\breed\b/i, /\balex\b/i, /\bmale\b/i, /\brishi\b/i, /\bman\b/i];

                    const anyFemaleVoice = voices.find(v => {
                        const isMaleName = maleVoiceNames.some(maleName =>
                            v.name.toLowerCase().includes(maleName.toLowerCase())
                        );
                        const isMalePattern = malePatterns.some(pattern => pattern.test(v.name));
                        return !isMaleName && !isMalePattern;
                    });

                    if (anyFemaleVoice) {
                        console.warn(`‚ö† Using fallback female voice: ${anyFemaleVoice.name} (${anyFemaleVoice.lang})`);
                        return anyFemaleVoice;
                    }

                    console.error('getFreshVoiceObject: No female voice found (all voices are male)');
                    return null;

                } catch (err) {
                    console.error('getFreshVoiceObject error:', err);
                    return null;
                }
            }

            // Backward compatibility alias (calls getFreshVoiceObject)
            getLockedVoice() {
                return this.getFreshVoiceObject();
            }

            async cancelAndWait() {
                try {
                    this.synth.cancel();
                } catch (error) {
                    console.warn('speechSynthesis.cancel failed', error);
                }
                await new Promise(resolve => setTimeout(resolve, 50));
                this.sessionToken = makeEpoch();
            }

            speak(text, guardToken = null) {
                if (!text) {
                    return Promise.resolve({ fallback: false, attempts: 0 });
                }

                return new Promise(resolve => {
                    if (guardToken && guardToken !== this.sessionToken) {
                        resolve({ fallback: false, attempts: 0 });
                        return;
                    }

                    const utterance = new SpeechSynthesisUtterance(text);
                    const voice = this.getLockedVoice();

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL SAFETY RULE #1: REFUSE TO SPEAK IF NO VOICE ASSIGNED
                    // This prevents browser from using its DEFAULT voice (male on iPhone)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (!voice) {
                        console.error('‚úó‚úó‚úó CRITICAL SAFETY BLOCK: No voice assigned (this.voice is null)!');
                        console.error('REFUSING TO SPEAK to prevent browser default voice (likely male) from being used!');
                        console.error('Voice system failed to initialize properly or all voices were filtered out.');
                        console.error('Check browser console for voice selection errors.');
                        resolve({ fallback: true, attempts: 0 });
                        return;
                    }

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // COMPREHENSIVE SAFETY CHECK: Prevent ANY male voices from speaking
                    // This is the SECOND line of defense - if a male voice reaches here,
                    // we refuse to speak rather than use it
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (voice) {
                        const voiceName = voice.name;

                        // EXHAUSTIVE male voice detection patterns (CRITICAL - includes Reed, Rocko, Lee, Gordon, etc.)
                        const malePatterns = [
                            // Common male names
                            /\balex\b/i, /\bdaniel\b/i, /\bfred\b/i, /\btom\b/i, /\bthomas\b/i,
                            /\boliver\b/i, /\bralph\b/i, /\bbruce\b/i, /\bjames\b/i, /\bjohn\b/i,
                            /\bnathan\b/i, /\baaron\b/i, /\bjorge\b/i, /\bdiego\b/i,
                            /\bmark\b/i, /\bdavid\b/i, /\brichard\b/i, /\bpaul\b/i, /\bgeorge\b/i,
                            /\bmichael\b/i, /\brobert\b/i, /\bwilliam\b/i, /\bjoseph\b/i,

                            // CRITICAL iOS/macOS male voices (PREVIOUSLY MISSING)
                            /\breed\b/i, /\brocko\b/i, /\blee\b/i, /\bgordon\b/i,
                            /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                            /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i,

                            // Additional male voices
                            /\bluca\b/i, /\bpaolo\b/i, /\bmarco\b/i, /\btomas\b/i,
                            /\bnicolas\b/i, /\bviktor\b/i, /\bmarko\b/i,

                            // INDIAN MALE VOICES
                            /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i,

                            // Siri male
                            /siri.*male/i, /male.*siri/i,

                            // Generic male indicators
                            /\bmale\b/i, /\bman\b/i, /\b\(m\)\b/i, /\bmale voice\b/i,
                            /\bguy\b/i, /\bdude\b/i, /\bboy\b/i, /\bmr\b/i
                        ];

                        const isMaleVoice = malePatterns.some(pattern => pattern.test(voiceName));

                        if (isMaleVoice) {
                            console.error(`‚úó‚úó‚úó RUNTIME SAFETY BLOCK: Prevented male voice "${voiceName}" from speaking!`);
                            console.error('CRITICAL: Male voice bypassed selectVoice filtering - this should NEVER happen!');
                            console.error('Refusing to speak. Voice system is compromised.');
                            resolve({ fallback: true, attempts: 0 });
                            return;
                        }

                        // ADDITIONAL SAFETY: Confirm voice matches female patterns (EXPANDED FOR iOS)
                        const femalePatterns = [
                            // Core iOS/macOS female voices
                            /\bsamantha\b/i, /\bkaren\b/i, /\bvictoria\b/i, /\bsusan\b/i,
                            /\bzoe\b/i, /\bmoira\b/i, /\btessa\b/i, /\bfiona\b/i,
                            /\bnicky\b/i, /\bserena\b/i, /\bhazel\b/i, /\bzira\b/i,

                            // Additional common female names
                            /\baria\b/i, /\beva\b/i, /\bava\b/i, /\bemma\b/i,
                            /\bemily\b/i, /\bsarah\b/i, /\bkate\b/i, /\banna\b/i,
                            /\blauren\b/i, /\bjessica\b/i, /\bjennifer\b/i, /\bmichelle\b/i,
                            /\bcatherine\b/i, /\belizabeth\b/i, /\bamanda\b/i,
                            /\brebecca\b/i, /\bnicole\b/i, /\bstephanie\b/i, /\bmelissa\b/i,

                            // European female names
                            /\bamelie\b/i, /\baudrey\b/i, /\bceline\b/i, /\bmarie\b/i,
                            /\bsophie\b/i, /\bvicki\b/i, /\bkatja\b/i, /\bjoana\b/i,
                            /\bluciana\b/i,

                            // Generic female indicators
                            /\bfemale\b/i, /\bwoman\b/i, /\bsiri.*female\b/i, /female.*siri/i,
                            /\blady\b/i, /\bgirl\b/i, /\b\(f\)\b/i
                        ];

                        const isFemaleVoice = femalePatterns.some(pattern => pattern.test(voiceName));

                        if (!isFemaleVoice) {
                            console.warn(`‚ö† WARNING: Voice "${voiceName}" does not match known female patterns`);
                            console.warn('Allowing it to proceed, but this voice may not be female');
                            console.warn('If you hear a male voice, please report this immediately');
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: Set BOTH utterance.voice AND utterance.lang
                        // Setting only ONE property causes iOS to ignore and use default
                        // BOTH must be set together or iOS falls back to Reed (male)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        utterance.voice = voice;
                        utterance.lang = voice.lang;

                        if (this.isIOS) {
                            console.log(`iOS: Set both utterance.voice="${voice.name}" AND utterance.lang="${voice.lang}"`);
                        }
                    }

                    utterance.pitch = this.pitch;
                    utterance.rate = this.rate;
                    utterance.volume = this.volume;

                    let settled = false;
                    const finish = (fallback) => {
                        if (settled) return;
                        settled = true;
                        clearTimeout(fallbackTimer);
                        resolve({ fallback, attempts: 1 });
                    };

                    const fallbackTimer = setTimeout(() => finish(true), estimateUtteranceMs(text, this.rate) + 400);

                    utterance.onend = () => finish(false);
                    utterance.onerror = () => finish(true);

                    setTimeout(() => {
                        if (settled) return;
                        if (guardToken && guardToken !== this.sessionToken) {
                            finish(true);
                            return;
                        }
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // CRITICAL SAFETY RULE #2: VERIFY utterance.voice IS SET
                        // Final check before speaking - if utterance.voice is not set,
                        // browser will use DEFAULT voice (Reed on iPhone)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if (!utterance.voice) {
                            console.error('‚úó‚úó‚úó CRITICAL SAFETY BLOCK: utterance.voice is not set!');
                            console.error('REFUSING TO SPEAK - would use browser default voice (male)!');
                            console.error('This should NEVER happen - voice was not properly assigned to utterance.');
                            finish(true);
                            return;
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: VERIFY BOTH utterance.voice AND utterance.lang ARE SET
                        // iOS requires BOTH properties or ignores voice and uses default Reed
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if (this.isIOS) {
                            if (!utterance.voice || !utterance.lang) {
                                console.error('‚úó‚úó‚úó iOS CRITICAL SAFETY BLOCK: utterance.voice OR utterance.lang not set!');
                                console.error(`utterance.voice: ${utterance.voice?.name || 'NULL'}`);
                                console.error(`utterance.lang: ${utterance.lang || 'NULL'}`);
                                console.error('iOS requires BOTH properties set or will use default voice (Reed - male)!');
                                console.error('REFUSING TO SPEAK!');
                                finish(true);
                                return;
                            }
                            console.log(`‚úì iOS dual-property check passed: voice="${utterance.voice.name}", lang="${utterance.lang}"`);
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // FINAL VERIFICATION: Confirm assigned voice is female
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        const assignedVoiceName = utterance.voice.name;
                        console.log(`üì¢ About to speak with voice: "${assignedVoiceName}" (${utterance.voice.lang})`);

                        // One last male voice check (includes Reed - iOS default)
                        const finalMaleCheck = [
                            /\breed\b/i, /\brocko\b/i, /\balex\b/i, /\bfred\b/i, /\btom\b/i,
                            /\bmale\b/i, /\bman\b/i, /\brishi\b/i, /\blee\b/i, /\bgordon\b/i,
                            /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                            /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i, /\bdaniel\b/i
                        ];

                        if (finalMaleCheck.some(pattern => pattern.test(assignedVoiceName))) {
                            console.error(`‚úó‚úó‚úó FINAL SAFETY BLOCK: Assigned voice "${assignedVoiceName}" is MALE!`);
                            console.error('REFUSING TO SPEAK!');
                            finish(true);
                            return;
                        }

                        try {
                            this.synth.resume();
                        } catch (err) {
                            console.warn('speechSynthesis.resume failed', err);
                        }
                        try {
                            this.synth.speak(utterance);
                        } catch (err) {
                            console.warn('speechSynthesis.speak failed', err);
                            finish(true);
                        }
                    }, 120);
                });
            }

            async speakPremise(premise, guardToken = null) {
                if (!premise) {
                    return { fallback: false, attempts: 0 };
                }
                const text = formatPremiseForSpeech(premise);
                return this.speak(text, guardToken);
            }
        }

        class GameEngine {
            constructor() {
                this.session = sessionDefaults();
                this.session.state = 'STOPPED';
                this.seedManager = new SeedManager();
                this.logger = new GameLogger();
                this.voice = new VoiceSynthesis();
                this.state = null;
                this.solver = null;
                this.equivalence = new EquivalenceEngine(false);
                this.generator = null;
                this.planner = null;
                this.matchSchedule = [];
                this.awaitingResponse = false;
                this.sessionToken = makeEpoch();
                this.responseStartTime = 0;
                this.currentPremises = [];
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.M = 8;
                this.lockSeed = this.seedManager.getLockPreference();
                this.resetOnRestart = false;
                this.pendingPlannerFlip = false;
                this.pendingRestart = false;
                this.statusMessage = 'Idle';
                this.policy = AdvancePolicy.ACTIVE;
                this.lastSpokenFallback = false;
                this.activePremise = null;
                this.forceMetaLeap = false;
                this.forceCompoundLeap = false;
            }

            get n() {
                return this.session.n;
            }

            set n(value) {
                this.session.n = value;
            }

            get k() {
                return this.session.k;
            }

            set k(value) {
                this.session.k = value;
            }

            get secondsPerTrial() {
                return this.session.secondsPerTrial;
            }

            set secondsPerTrial(value) {
                this.session.secondsPerTrial = value;
            }

            get totalTrials() {
                return this.session.numTrials;
            }

            set totalTrials(value) {
                this.session.numTrials = value;
            }

            applyNumTrialsFromUI() {
                const current = loadNumTrials();
                this.session.numTrials = current;
                return current;
            }

            speakOnce(text) {
                if (!text) return;
                this.voice.speak(text, this.voice.sessionToken);
            }

            renderSummary() {
                this.statusMessage = `Session complete. ${this.session.numTrials} trials finished.`;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
            }

            async initialize() {
                await this.voice.initialize();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL: Unlock speech synthesis from user gesture
                // Must be called after voice.initialize() to enable iOS speech
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.voice.unlockIOSSpeech();

                this.updateVoiceInfo();
                this.attachUI();
                this.updateUI();
            }

            attachUI() {
                if (window._imagiHandlersBound) {
                    return;
                }
                window._imagiHandlersBound = true;

                const lockSeedToggle = document.getElementById('lock-seed-toggle');
                if (lockSeedToggle) {
                    lockSeedToggle.checked = this.lockSeed;
                    lockSeedToggle.addEventListener('change', (e) => {
                        this.lockSeed = e.target.checked;
                        this.seedManager.setLockPreference(this.lockSeed);
                    });
                }

                const resetSeedToggle = document.getElementById('reset-seed-toggle');
                if (resetSeedToggle) {
                    resetSeedToggle.addEventListener('change', (e) => {
                        this.resetOnRestart = e.target.checked;
                    });
                }

                const transitivityToggle = document.getElementById('transitivity-toggle');
                if (transitivityToggle) {
                    this.equivalence.setTransitivity(transitivityToggle.checked); // Apply initial state
                    transitivityToggle.addEventListener('change', (e) => {
                        this.equivalence.setTransitivity(e.target.checked);
                    });
                }

                const gLeapToggle = document.getElementById('g-leap-toggle');
                if (gLeapToggle) {
                    gLeapToggle.addEventListener('change', (e) => {
                        this.forceMetaLeap = e.target.checked;

                        // If Level 6 enabled, disable Level 7
                        if (this.forceMetaLeap) {
                            const compoundToggle = document.getElementById('compound-leap-toggle');
                            if (compoundToggle) compoundToggle.checked = false;
                            this.forceCompoundLeap = false;
                        }

                        // Disable transitivity toggle in META mode (doesn't apply to operator logic)
                        const transitivityCtrl = document.getElementById('transitivity-toggle');
                        if (transitivityCtrl) {
                            transitivityCtrl.disabled = this.forceMetaLeap || this.forceCompoundLeap;
                        }

                        // Update k slider label to show what k means in META mode
                        const kLabel = document.getElementById('k-label');
                        if (kLabel) {
                            kLabel.textContent = this.forceMetaLeap ? 'Operator Pairs' :
                                               this.forceCompoundLeap ? 'Compound Atoms' : 'Atoms per Premise';
                        }
                    });
                }

                const compoundLeapToggle = document.getElementById('compound-leap-toggle');
                if (compoundLeapToggle) {
                    compoundLeapToggle.addEventListener('change', (e) => {
                        this.forceCompoundLeap = e.target.checked;

                        // If Level 7 enabled, disable Level 6
                        if (this.forceCompoundLeap) {
                            const gToggle = document.getElementById('g-leap-toggle');
                            if (gToggle) gToggle.checked = false;
                            this.forceMetaLeap = false;
                        }

                        // Disable transitivity toggle in COMPOUND mode (doesn't apply)
                        const transitivityCtrl = document.getElementById('transitivity-toggle');
                        if (transitivityCtrl) {
                            transitivityCtrl.disabled = this.forceMetaLeap || this.forceCompoundLeap;
                        }

                        // Update k slider label
                        const kLabel = document.getElementById('k-label');
                        if (kLabel) {
                            kLabel.textContent = this.forceCompoundLeap ? 'Compound Atoms' :
                                               this.forceMetaLeap ? 'Operator Pairs' : 'Atoms per Premise';
                        }
                    });
                }

                const debugToggle = document.getElementById('debug-toggle');
                if (debugToggle) {
                    debugToggle.addEventListener('change', (e) => {
                        document.getElementById('debug').hidden = !e.target.checked;
                    });
                }

                const sptSlider = document.getElementById('spt-slider');
                const sptNumber = document.getElementById('spt-number');
                const syncSeconds = (value) => {
                    this.secondsPerTrial = parseFloat(value);
                    const sptValue = document.getElementById('spt-value');
                    if (sptValue) {
                        sptValue.textContent = this.secondsPerTrial.toFixed(1);
                    }
                };
                if (sptSlider) {
                    sptSlider.addEventListener('input', (e) => {
                        if (sptNumber) {
                            sptNumber.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }
                if (sptNumber) {
                    sptNumber.addEventListener('input', (e) => {
                        if (sptSlider) {
                            sptSlider.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }

                const nSlider = document.getElementById('n-slider');
                if (nSlider) {
                    nSlider.addEventListener('input', (e) => {
                        this.n = parseInt(e.target.value, 10);
                        const nValue = document.getElementById('n-value');
                        if (nValue) {
                            nValue.textContent = this.n;
                        }
                    });
                }

                const kSlider = document.getElementById('k-slider');
                if (kSlider) {
                    kSlider.addEventListener('input', (e) => {
                        this.k = parseInt(e.target.value, 10);
                        const kValue = document.getElementById('k-value');
                        if (kValue) {
                            kValue.textContent = this.k;
                        }
                    });
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        this.pendingRestart = false;
                        startSession();
                    });
                }

                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        restartSession();
                    });
                }

                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) {
                    stopBtn.addEventListener('click', () => {
                        stopSession();
                    });
                }

                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) {
                    repeatBtn.addEventListener('click', () => {
                        onRepeatPressed();
                    });
                }

                const previewBtn = document.getElementById('preview-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', async () => {
                        const previewPremise = new Premise([
                            new Atom('N', 'A', 'B'),
                            new Atom('E', 'C', 'D')
                        ]);
                        await this.voice.speakPremise(previewPremise, this.voice.sessionToken);
                    });
                }

                const resetVoiceBtn = document.getElementById('reset-voice-btn');
                if (resetVoiceBtn) {
                    resetVoiceBtn.addEventListener('click', async () => {
                        console.log('Manual voice reset requested');
                        // Reset voice selection and re-initialize
                        this.voice.resetVoiceSelection();
                        this.voice.voiceReady = false;

                        try {
                            await this.voice.initialize();
                            this.updateVoiceInfo();
                            alert('Voice selection has been reset and re-initialized.\n\nSelected voice: ' + this.voice.getVoiceInfo());
                        } catch (error) {
                            console.error('Voice re-initialization failed:', error);
                            alert('Voice re-initialization failed: ' + error.message);
                        }
                    });
                }

                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        const handler = window.__imagiActiveResponse;
                        if (typeof handler === 'function') {
                            e.preventDefault();
                            handler(e.code === 'Space' ? 'match' : 'nomatch');
                        }
                    }
                });

                const exportBtn = document.getElementById('export-btn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => {
                        this.exportData();
                    });
                }

                const testBtn = document.getElementById('test-btn');
                if (testBtn) {
                    testBtn.addEventListener('click', async () => {
                        const panel = document.getElementById('test-panel');
                        const resultsEl = document.getElementById('test-results');
                        if (panel) panel.hidden = false;
                        if (resultsEl) {
                            resultsEl.innerHTML = '<p>Running tests...</p>';
                            const harness = new TestHarness();
                            const results = await harness.runAll();
                            resultsEl.innerHTML = results.map(result => {
                                const cls = result.passed ? 'pass' : 'fail';
                                const symbol = result.passed ? '‚úì' : '‚úó';
                                return `<div class="test-result ${cls}">${symbol} ${result.test}: ${result.details}</div>`;
                            }).join('');
                        }
                    });
                }
            }

            updateVoiceInfo() {
                const info = document.getElementById('voice-info');
                if (info) {
                    const voiceInfo = this.voice.getVoiceInfo();
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                    const platform = isIOS ? 'iOS' : 'Desktop';

                    // Determine voice status with female voice awareness
                    let voiceStatus;
                    if (this.voice.voice) {
                        const voiceName = this.voice.voice.name;

                        // Check if it's a known female voice
                        const knownFemaleVoices = [
                            'Samantha', 'Karen', 'Moira', 'Tessa', 'Victoria', 'Fiona',
                            'Nicky', 'Serena', 'Susan', 'Zoe', 'Hazel', 'Zira'
                        ];
                        const isKnownFemale = knownFemaleVoices.some(name => voiceName.includes(name));

                        if (voiceName.includes('Samantha')) {
                            voiceStatus = '<span style="color: #2ecc71;">‚úì Samantha (Female)</span>';
                        } else if (isKnownFemale) {
                            voiceStatus = '<span style="color: #2ecc71;">‚úì Female Voice</span>';
                        } else {
                            voiceStatus = '<span style="color: #f39c12;">‚ö† Ambiguous Voice</span>';
                        }
                    } else {
                        voiceStatus = '<span style="color: #e74c3c;">‚úó No Voice</span>';
                    }

                    info.innerHTML = `<strong>Voice:</strong> ${voiceInfo} | <strong>Platform:</strong> ${platform} | ${voiceStatus}`;
                    console.log(`Voice info updated: ${voiceInfo} on ${platform}`);
                }
            }

            updateUI() {
                const trialCount = document.getElementById('trial-count');
                if (trialCount) {
                    trialCount.textContent = this.session.trialIndex;
                }
                const scoreEl = document.getElementById('score');
                if (scoreEl) {
                    scoreEl.textContent = this.score;
                }
                const omissionsEl = document.getElementById('omissions');
                if (omissionsEl) {
                    omissionsEl.textContent = this.omissions;
                }
                const accuracyEl = document.getElementById('accuracy');
                const accuracy = this.totalResponses > 0 ? (this.correctResponses / this.totalResponses) * 100 : null;
                if (accuracyEl) {
                    accuracyEl.textContent = accuracy !== null ? `${accuracy.toFixed(1)}%` : '-';
                }
                const rollingEl = document.getElementById('rolling-acc');
                const rolling = this.recentAccuracy.length > 0
                    ? (this.recentAccuracy.reduce((a, b) => a + b, 0) / this.recentAccuracy.length) * 100
                    : null;
                if (rollingEl) {
                    rollingEl.textContent = rolling !== null ? `${rolling.toFixed(1)}%` : '-';
                }

                const running = this.session.state === 'RUNNING';
                const statusText = running ? `Running (n=${this.n}, k=${this.k})` : this.statusMessage;
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = statusText;
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) startBtn.disabled = running;
                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) restartBtn.disabled = !running;
                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) stopBtn.disabled = !running;
            }

            prepareSession(sess) {
                const totalPlanned = sess.numTrials;
                this.session = sessionDefaults();
                this.session.trialIndex = 0;
                this.session.numTrials = totalPlanned;
                this.session.state = 'RUNNING';
                this.policy = sess.policy;
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.pendingPlannerFlip = false;
                this.awaitingResponse = false;
                this.lastSpokenFallback = false;

                const shouldResetLogs = !this.pendingRestart || this.resetOnRestart;
                this.pendingRestart = false;

                const seed = this.seedManager.generateSessionSeed(this.lockSeed);
                this.session.seedSession = seed;
                this.state = new GameState(seed, { windowSize: Math.max(2 * this.n + 2, 12) });
                this.state.resetNovelty();
                this.solver = new ConstraintSolver();
                this.generator = new PremiseGenerator(this.state, this.solver, this.equivalence);
                this.planner = new MatchPlanner(this.state.rng);
                this.generator.setPlanner(this.planner);
                this.matchSchedule = this.planner.plan(totalPlanned, this.n);
                if (shouldResetLogs) {
                    this.logger.reset();
                }
                this.currentPremises = [];
                this.statusMessage = `Running (n=${this.n}, k=${this.k})`;
                this.sessionToken = makeEpoch();

                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = '';
                }
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) repeatBtn.disabled = true;
                const matchBtn = document.getElementById('match-btn');
                if (matchBtn) matchBtn.disabled = true;
                const noMatchBtn = document.getElementById('no-match-btn');
                if (noMatchBtn) noMatchBtn.disabled = true;
                window.__imagiActiveResponse = null;
                window.forceCurrentTrialTimeout = null;
                window.currentPremiseText = '';

                this.updateUI();
            }

            async finalizeSession(sess, aborted) {
                // CRITICAL FIX: Add comprehensive logging to track why session is stopping
                const reason = aborted ? 'ABORTED' : 'COMPLETED';
                const trialProgress = `${sess?.trialIndex || 0}/${sess?.numTrials || 'unknown'}`;
                console.log(`finalizeSession called: ${reason}, trials: ${trialProgress}, epoch: ${sess?.epoch}`);

                // DEFENSIVE: Capture stack trace to see what triggered this finalization
                if (aborted && sess && sess.trialIndex < sess.numTrials) {
                    console.warn(`Session stopped prematurely at trial ${sess.trialIndex}/${sess.numTrials}. Stack trace:`);
                    console.trace();
                }

                this.awaitingResponse = false;
                this.session.state = 'STOPPED';
                this.statusMessage = aborted ? 'Stopped' : `Session complete. ${this.session.numTrials} trials finished.`;
                if (!aborted) {
                    this.renderSummary();
                }
                this.activePremise = null;
                this.updateUI();
            }

            planTrial(trialIndex) {
                const scheduledMatch = this.matchSchedule[trialIndex] || false;
                const nBackIndex = trialIndex - this.n;
                const nBackPremise = nBackIndex >= 0 ? this.currentPremises[nBackIndex] : null;
                const middleAtoms = nBackIndex >= 0 ? this.state.getConstraintsInRange(nBackIndex + 1, trialIndex - 1) : [];
                const cooldown = this.state.getActiveCooldown(trialIndex);
                const planMatch = scheduledMatch && Boolean(nBackPremise);
                const foilPlan = (!planMatch && nBackPremise) ? this.planner.maybePlanFoil() : null;
                return { trialIndex, scheduledMatch, nBackPremise, middleAtoms, cooldown, planMatch, foilPlan };
            }

            tryGenerate(plan, override = null) {
                const params = {
                    trialIndex: plan.trialIndex,
                    k: this.k,
                    n: this.n,
                    plannedMatch: override !== null ? override : plan.planMatch,
                    nBackPremise: plan.nBackPremise,
                    middleAtoms: plan.middleAtoms,
                    avoidLetters: (override !== null ? override : plan.planMatch) ? plan.cooldown : null,
                    allowOverride: true,
                    foilPlan: plan.foilPlan,
                    forceMetaLeap: this.forceMetaLeap,
                    forceCompoundLeap: this.forceCompoundLeap
                };
                return this.generator.generate(params);
            }

            async generatePremiseGuaranteed(plan) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const result = this.tryGenerate(plan, null);
                    if (result) {
                        return { ...result, planMatch: plan.planMatch };
                    }
                    if (plan.scheduledMatch && attempt === 0) {
                        this.planner.forceFlip(plan.trialIndex);
                        this.pendingPlannerFlip = true;
                        const flipped = this.tryGenerate(plan, false);
                        if (flipped) {
                            return { ...flipped, planMatch: false };
                        }
                    }
                }

                if (!plan._flipped && plan.nBackPremise) {
                    const flippedPlan = { ...plan, planMatch: !plan.planMatch, scheduledMatch: false, _flipped: true };
                    for (let attempt = 0; attempt < 30; attempt++) {
                        const result = this.tryGenerate(flippedPlan, flippedPlan.planMatch);
                        if (result) {
                            return { ...result, planMatch: flippedPlan.planMatch };
                        }
                    }
                }

                return this.buildNeutralNonMatch(plan);
            }

            buildNeutralNonMatch(plan) {
                const letters = this.state?.letters || 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const head = this.state?.rng ? this.state.rng.choice(letters) : letters[0];
                const tails = letters.filter(letter => letter !== head);
                const tail = (this.state?.rng ? this.state.rng.choice(tails.length ? tails : letters) : (tails[0] || letters[1] || head));
                const axis = this.state?.rng ? this.state.rng.choice(MATCH_AXES) : 'N';
                const safeTail = tail === head ? letters[(letters.indexOf(head) + 1) % letters.length] : tail;
                const premise = new Premise([new Atom(axis, head, safeTail)]);
                const signatures = this.state ? this.state.novelty.buildSignatures(premise) : { exact: premise.toKey() };
                const windowAtoms = this.state ? this.state.getWindowAtoms() : [];
                const satResult = this.solver ? this.solver.evaluate(windowAtoms, premise.atoms) : { ok: true, coordinates: new Map() };
                return {
                    premise,
                    signatures,
                    novelty: { noveltyScores: {}, blocked: false },
                    satResult,
                    certificate: null,
                    modeUsed: 'fallback',
                    features: premise.getFeatures(),
                    foilType: null,
                    planMatch: false
                };
            }


            async executeTrial(sess, trialToken, signal) {
                // CRITICAL FIX: Enhanced validation with detailed logging
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid at start, trial ${sess.trialIndex}, reason: ${!session ? 'no global session' : session.epoch !== sess.epoch ? 'epoch mismatch' : trialToken !== session.trialToken ? 'token mismatch' : signal.aborted ? 'signal aborted' : 'unknown'}`);
                    return;
                }
                resetSpeechGateForTrial();
                const currentIndex = sess.trialIndex;
                this.session.trialIndex = currentIndex;
                this.updateUI();

                let plan = this.planTrial(currentIndex);
                let result = await this.generatePremiseGuaranteed(plan);
                if (!result) {
                    console.warn('Premise generation returned null; using neutral fallback.');
                    result = this.buildNeutralNonMatch(plan);
                }

                const { premise, signatures, novelty, satResult, certificate, modeUsed, features, foilType, planMatch } = result;
                this.activePremise = premise;
                const planType = planMatch ? 'match' : (foilType ? `foil:${foilType}` : 'nonmatch');
                const featureSnapshot = features || premise.getFeatures();

                this.currentPremises.push(premise);
                this.state.recordPremise(premise, premise.atoms, { plannedMatch: planMatch, certificate, modeUsed, foilType });
                this.state.novelty.register(signatures);
                this.state.coordinates = satResult.coordinates;

                sess.phaseToken = (sess.phaseToken || 0) + 1;
                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = premise.toString();
                }
                window.currentPremiseText = formatPremiseForSpeech(premise);
                const matchBtn = document.getElementById('match-btn');
                const noMatchBtn = document.getElementById('no-match-btn');
                const repeatBtn = document.getElementById('repeat-btn');
                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = false;

                const speechMeta = await speakPremiseSafe(sess, premise, trialToken, signal);
                this.lastSpokenFallback = Boolean(speechMeta?.fallback);
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid after speech, trial ${currentIndex}`);
                    return;
                }

                if (sess.policy === AdvancePolicy.LISTEN) {
                    await dwellSafe(this.secondsPerTrial, trialToken, signal);
                    if (!valid(sess, trialToken)) {
                        console.warn(`executeTrial: invalid after dwell, trial ${currentIndex}`);
                        return;
                    }
                    this.logTrial({
                        planMatch,
                        planType,
                        certificate,
                        featureSnapshot,
                        premise,
                        novelty,
                        satResult,
                        foilType,
                        responsePayload: { choice: null, correct: null, rt: null, omission: false, timeout: false },
                        modeUsed,
                        trialIndex: currentIndex,
                        passiveAdvance: true,
                        trialTokenAtStart: trialToken,
                        listenOnly: true
                    });
                    if (repeatBtn) repeatBtn.disabled = true;
                    const feedbackEl = document.getElementById('feedback');
                    if (feedbackEl) {
                        feedbackEl.textContent = 'Listening‚Ä¶';
                        feedbackEl.className = 'feedback';
                    }
                    this.updateUI();
                    this.activePremise = null;
                    return;
                }

                this.awaitingResponse = true;
                this.responseStartTime = Date.now();
                if (matchBtn) matchBtn.disabled = false;
                if (noMatchBtn) noMatchBtn.disabled = false;

                const response = await collectResponseSafe(this.secondsPerTrial, trialToken, signal);
                this.awaitingResponse = false;
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid after collectResponse, trial ${currentIndex}`);
                    return;
                }

                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = true;

                const responseChoice = response?.type === 'answer' ? response.choice : null;
                const timeout = response?.type === 'timeout';
                const omission = timeout || responseChoice === null;
                const actualMatch = Boolean(planMatch && certificate);
                let correct = null;
                if (!timeout && responseChoice !== null) {
                    correct = (responseChoice === 'match') === actualMatch;
                }

                if (timeout) {
                    this.omissions += 1;
                } else if (correct !== null) {
                    this.totalResponses += 1;
                    if (correct) {
                        this.score += 1;
                        this.correctResponses += 1;
                    }
                    this.recentAccuracy.push(correct ? 1 : 0);
                    if (this.recentAccuracy.length > this.M) {
                        this.recentAccuracy.shift();
                    }
                }

                const rt = (!timeout && responseChoice !== null) ? Date.now() - this.responseStartTime : null;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    if (timeout) {
                        feedbackEl.textContent = 'Response window expired.';
                        feedbackEl.className = 'feedback incorrect';
                    } else if (correct) {
                        feedbackEl.textContent = 'Correct';
                        feedbackEl.className = 'feedback correct';
                    } else if (correct === false) {
                        feedbackEl.textContent = 'Incorrect';
                        feedbackEl.className = 'feedback incorrect';
                    } else {
                        feedbackEl.textContent = '';
                        feedbackEl.className = 'feedback';
                    }
                }

                if (actualMatch && certificate) {
                    this.state.applyCooldown(Array.from(premise.getLetters()), currentIndex, this.n);
                }

                this.logTrial({
                    planMatch,
                    planType,
                    certificate,
                    featureSnapshot,
                    premise,
                    novelty,
                    satResult,
                    foilType,
                    responsePayload: {
                        choice: responseChoice,
                        correct,
                        rt,
                        omission,
                        timeout
                    },
                    modeUsed,
                    trialIndex: currentIndex,
                    passiveAdvance: false,
                    trialTokenAtStart: trialToken,
                    listenOnly: false
                });

                this.activePremise = null;
                this.updateUI();
            }

            logTrial({ planMatch, planType, certificate, featureSnapshot, premise, novelty, satResult, foilType, responsePayload, modeUsed, trialIndex, passiveAdvance, trialTokenAtStart, listenOnly }) {
                const { choice, correct, rt, omission, timeout } = responsePayload;
                const featureLog = {
                    lettersSet: Array.from(featureSnapshot.lettersSet).sort(),
                    degreeVector: {},
                    skeletonIsoSignature: featureSnapshot.skeletonIsoSignature,
                    atomAxisProfile: {}
                };
                featureSnapshot.degreeVector.forEach((vec, letter) => {
                    featureLog.degreeVector[letter] = [...vec];
                });
                featureSnapshot.atomAxisProfile.forEach((count, axis) => {
                    featureLog.atomAxisProfile[axis] = count;
                });

                const plannerFlip = this.pendingPlannerFlip || (this.planner && typeof this.planner.wasFlipped === 'function' ? this.planner.wasFlipped(trialIndex) : false);
                this.pendingPlannerFlip = false;

                const logEntry = {
                    seedSession: this.seedManager.sessionSeed,
                    trialIndex,
                    trialNumber: trialIndex + 1,
                    numTrials: this.session.numTrials,
                    n: this.n,
                    k: this.k,
                    letters: Array.from(premise.getLetters()).join(''),
                    atomsCanonical: premise.toKey(),
                    atomsMirrorCanonical: premise.mirrorKey(),
                    isoSignature: premise.isoSignature(),
                    plannedMatch: planMatch,
                    planType,
                    foilType: foilType || null,
                    certificate: certificate || null,
                    satStatus: satResult.ok,
                    midWindowDerivable: certificate ? certificate.midWindowDerivable : false,
                    noveltyScores: novelty?.noveltyScores || {},
                    response: { choice, correct, rtMs: rt, omission, timeout },
                    cooldownLetters: Array.from(this.state.getActiveCooldown(trialIndex + 1)),
                    plannerFlip,
                    modeUsed,
                    mode: listenOnly ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                    passiveAdvance,
                    ttsFallback: Boolean(this.lastSpokenFallback),
                    trialTokenAtStart,
                    features: featureLog
                };

                this.logger.add(logEntry);
                this.updateDebugPanel(logEntry);
            }

            updateDebugPanel(entry) {
                const debug = document.getElementById('debug-content');
                if (!debug) return;
                const el = document.createElement('div');
                el.className = 'debug-premise';
                el.textContent = `Trial ${entry.trialIndex}: ${entry.atomsCanonical} | Plan=${entry.planType} | Response=${entry.response.choice}`;
                debug.prepend(el);
                while (debug.childElementCount > 20) {
                    debug.removeChild(debug.lastChild);
                }
            }

            exportData() {
                const data = {
                    seedSession: this.seedManager.sessionSeed,
                    entries: this.logger.getEntriesSnapshot()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `imagi-world-session-${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        const DEBOUNCE_MS = 250;
        let lastBtn = 0;

        function debounce() {
            const now = performance.now();
            if (now - lastBtn < DEBOUNCE_MS) return false;
            lastBtn = now;
            return true;
        }

        function cancelSpeechImmediately() {
            try {
                window.speechSynthesis?.cancel();
            } catch (err) {
                console.warn('speechSynthesis.cancel immediate failed', err);
            }
        }

        function clearAllEngineTimers() {
            Timer.cancelAll();
            clearHeartbeat();
        }

        function stopSession() {
            if (!session) {
                console.log('stopSession called, but no active session');
                return;
            }

            // CRITICAL FIX: Add logging to track when and why stopSession is called
            console.log(`stopSession called: trial ${session.trialIndex}/${session.numTrials}, epoch ${session.epoch}`);
            console.trace('stopSession stack trace:');

            try {
                session.abort.abort();
            } catch (err) {
                console.warn('abort stop failed', err);
            }
            clearAllEngineTimers();
            cancelSpeechImmediately();
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
            engine.finalizeSession(session, true);
            window.__imagiActiveResponse = null;
            window.forceCurrentTrialTimeout = null;
            session = null;
        }

        async function runLoop(sess) {
            const signal = sess.abort.signal;
            console.log(`runLoop started: epoch ${sess.epoch}, numTrials ${sess.numTrials}`);

            // CRITICAL FIX: Wrap each trial in try-catch to prevent single trial errors from stopping entire session
            while (!signal.aborted && sess.trialIndex < sess.numTrials) {
                sess.trialToken += 1;
                sess.phaseToken = 0;

                try {
                    await engine.executeTrial(sess, sess.trialToken, signal);
                } catch (err) {
                    console.error(`runLoop: Error in executeTrial at trial ${sess.trialIndex}:`, err);
                    // DEFENSIVE: Log error but continue with next trial instead of stopping entire session
                    // This prevents transient errors (speech synthesis failures, DOM timing issues) from killing the session
                    console.warn(`Continuing to next trial despite error in trial ${sess.trialIndex}`);
                }

                if (signal.aborted) {
                    console.warn(`runLoop: aborted at trial ${sess.trialIndex}`);
                    break;
                }
                sess.trialIndex += 1;
            }

            if (!signal.aborted) {
                console.log(`runLoop: completed ${sess.trialIndex}/${sess.numTrials} trials normally`);
                await engine.finalizeSession(sess, false);
                clearAllEngineTimers();
                session = null;
            } else {
                console.warn(`runLoop: session aborted, completed ${sess.trialIndex}/${sess.numTrials} trials`);
                // Note: Don't call finalizeSession here - stopSession() already does it
            }
        }

        function startSession() {
            if (!debounce()) return;

            // CRITICAL FIX: Clean up old session first, then create new one atomically
            // This prevents race conditions between stopSession() and session creation
            stopSession();

            // Create new session and prepare engine BEFORE starting runLoop
            const newSess = newSession(engine);
            session = newSess;  // Set global session immediately to prevent epoch mismatches

            engine.prepareSession(newSess);
            wireHeartbeat(newSess);

            // CRITICAL FIX: Add better error handling that doesn't stop on transient errors
            runLoop(newSess).catch((err) => {
                console.error('runLoop encountered error:', err);
                // Only stop if session is still the one that errored (not already replaced)
                if (session && session.epoch === newSess.epoch) {
                    console.error('Stopping session due to unrecoverable error in runLoop');
                    stopSession();
                } else {
                    console.warn('runLoop error for stale session, ignoring');
                }
            });
        }

        function restartSession() {
            if (!debounce()) return;
            stopSession();
            startSession();
        }

        function formatPremiseForSpeech(premise) {
            if (!premise) return '';

            // Use premise's toNaturalSpeech() method which handles all types
            return premise.toNaturalSpeech();
        }

        function estimateUtteranceMs(text, rate = 0.9) {
            const cps = 12 * rate;
            return Math.max(900, Math.min(9000, Math.round((text.length / cps) * 1000) + 300));
        }

        async function speakPremiseSafe(sess, premise, trialToken, signal) {
            if (!valid(sess, trialToken)) {
                return { fallback: false, attempts: 0 };
            }

            return new Promise((resolve) => {
                const mySpeakId = SpeechGate.trialSpeakId;
                const myRepeatPhase = SpeechGate.explicitRepeatPhase;

                if (SpeechGate.inFlight) {
                    resolve({ fallback: false, attempts: 0 });
                    return;
                }

                const flightToken = Symbol('speech-flight');
                SpeechGate.inFlight = true;
                SpeechGate.flightToken = flightToken;

                try {
                    window.speechSynthesis?.cancel();
                } catch (err) {
                    console.warn('speechSynthesis.cancel before speak failed', err);
                }
                try {
                    window.speechSynthesis?.resume();
                } catch (err) {
                    console.warn('speechSynthesis.resume after cancel failed', err);
                }

                const text = formatPremiseForSpeech(premise);
                window.currentPremiseText = text;
                const utterance = new SpeechSynthesisUtterance(text);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL FIX: Use VoiceSynthesis class's selected voice
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PROBLEM: Previous code used voices[0] which on iPhone = Reed (male)
                // SOLUTION: Use engine.voice.getFreshVoiceObject() for properly selected female voice
                // This matches the Voice Preview button behavior which works perfectly on iPhone

                const freshVoice = engine?.voice?.getFreshVoiceObject();
                if (freshVoice) {
                    utterance.voice = freshVoice;
                    utterance.lang = freshVoice.lang;
                    console.log(`‚úì speakPremiseSafe using selected voice: ${freshVoice.name} (${freshVoice.lang})`);
                } else {
                    console.error('‚úó speakPremiseSafe: getFreshVoiceObject() returned null - attempting fallback');
                    // Fallback: Try to get voices array directly (should not happen if voice initialized)
                    const voices = window.speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        // Last resort: use voices[0] (will be male on iPhone, but better than silence)
                        utterance.voice = voices[0];
                        utterance.lang = voices[0].lang;
                        console.warn(`‚ö† Using fallback voice: ${voices[0].name} (may be male on iPhone)`);
                    }
                }

                const pitch = engine?.voice?.pitch ?? 1.2;
                const rate = engine?.voice?.rate ?? 0.9;
                const volume = engine?.voice?.volume ?? 1.0;
                utterance.pitch = pitch;
                utterance.rate = rate;
                utterance.volume = volume;

                instrumentUtterance(utterance);

                let settled = false;

                const finish = (fallback) => {
                    if (settled) return;
                    settled = true;
                    if (SpeechGate.flightToken === flightToken) {
                        SpeechGate.inFlight = false;
                        SpeechGate.flightToken = null;
                    }
                    clearTimeout(fallbackTimer);
                    signal.removeEventListener('abort', onAbort);
                    resolve({ fallback, attempts: 1 });
                };

                const onAbort = () => finish(false);
                signal.addEventListener('abort', onAbort, { once: true });

                const fallbackTimer = setTimeout(() => {
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    finish(true);
                }, estimateUtteranceMs(text, rate) + 400);

                utterance.onend = () => finish(false);
                utterance.onerror = () => finish(true);

                setTimeout(() => {
                    if (settled) return;
                    if (signal.aborted) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    try {
                        window.speechSynthesis?.resume();
                    } catch (err) {
                        console.warn('speechSynthesis.resume failed', err);
                    }
                    try {
                        window.speechSynthesis?.speak(utterance);
                    } catch (err) {
                        console.warn('speechSynthesis.speak failed', err);
                        finish(true);
                    }
                }, 100);
            });
        }

        function secondsPerTrial() {
            return engine.secondsPerTrial;
        }

        async function dwellSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                let resolved = false;
                const safeResolve = () => {
                    if (!resolved) {
                        resolved = true;
                        resolve();
                    }
                };
                Timer.set('dwell', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, safeResolve);
                // Ensure promise resolves if signal aborts
                signal.addEventListener('abort', safeResolve, { once: true });
            });
        }

        function bindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.addEventListener('click', onMatch, { once: true });
            noMatchBtn?.addEventListener('click', onNo, { once: true });
        }

        function unbindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.removeEventListener('click', onMatch);
            noMatchBtn?.removeEventListener('click', onNo);
        }

        async function collectResponseSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                let settled = false;
                const settle = (payload) => {
                    if (settled) return;
                    settled = true;
                    cleanup();
                    resolve(payload);
                };

                const onMatch = () => settle({ type: 'answer', choice: 'match' });
                const onNo = () => settle({ type: 'answer', choice: 'nomatch' });
                bindTrialButtons(onMatch, onNo);
                window.__imagiActiveResponse = (choice) => {
                    if (choice === 'match') {
                        onMatch();
                    } else {
                        onNo();
                    }
                };

                const timerId = Timer.set('resp', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, () => settle({ type: 'timeout' }));

                const cleanup = () => {
                    unbindTrialButtons(onMatch, onNo);
                    Timer.clear(timerId);
                    window.__imagiActiveResponse = null;
                };

                signal.addEventListener('abort', () => settle({ type: 'timeout' }), { once: true });
                window.forceCurrentTrialTimeout = () => settle({ type: 'timeout' });
            });
        }

        function wireHeartbeat(sess) {
            clearHeartbeat();
            let lastTick = performance.now();
            let lastTrial = -1;
            let nudgeCount = 0;  // Track consecutive nudges to prevent over-aggressive watchdog

            heartbeat = setInterval(() => {
                // CRITICAL FIX: More defensive session checks to prevent race conditions
                if (!session || !sess) {
                    clearHeartbeat();
                    return;
                }
                if (session.epoch !== sess.epoch) {
                    // Session has been replaced, this watchdog is stale
                    clearHeartbeat();
                    return;
                }
                if (sess.abort.signal.aborted) {
                    clearHeartbeat();
                    return;
                }

                const now = performance.now();

                // Reset nudge count when trial advances successfully
                if (sess.trialIndex !== lastTrial) {
                    lastTrial = sess.trialIndex;
                    lastTick = now;
                    nudgeCount = 0;  // Reset nudge counter on progress
                    return;
                }

                // CRITICAL FIX: More generous timeout calculation to reduce false positives
                // Add extra buffer for browser variability, tab switching, etc.
                const typical = estimateUtteranceMs(window.currentPremiseText || 'H is east of R; Y is north of X.', 0.90) + (secondsPerTrial() * 1000) + 3000;  // Increased from 1500ms to 3000ms buffer
                const elapsed = now - lastTick;

                if (elapsed > typical) {
                    nudgeCount++;
                    console.warn(`Watchdog nudge #${nudgeCount} (elapsed: ${Math.round(elapsed)}ms, typical: ${Math.round(typical)}ms)`);

                    // CRITICAL FIX: Only nudge if we haven't exceeded reasonable retry limit
                    // This prevents infinite nudge loops from stopping the session
                    if (nudgeCount <= 3) {  // Allow up to 3 nudges before giving up on this trial
                        cancelSpeechImmediately();
                        if (session?.policy === AdvancePolicy.ACTIVE) {
                            window.forceCurrentTrialTimeout?.();
                        } else {
                            Timer.set('dwell-nudge', 50, session.trialToken, session.abort.signal, () => {});
                        }
                    } else {
                        console.error(`Watchdog: Trial ${sess.trialIndex} appears stuck after ${nudgeCount} nudges, but continuing session`);
                        // Don't abort the session - just reset the tick and hope next trial works
                        // This is better than stopping the entire session randomly
                    }

                    lastTick = now;  // Reset tick regardless of nudge count
                }
            }, 500);
        }

        function onRepeatPressed() {
            if (!session) return;
            const premise = engine.activePremise || engine.currentPremises[Math.max(0, session.trialIndex - 1)];
            if (!premise) return;
            noteExplicitRepeat();
            cancelSpeechImmediately();
            setTimeout(() => {
                if (!session || session.abort.signal.aborted) return;
                SpeechGate.inFlight = false;
                SpeechGate.flightToken = null;
                speakPremiseSafe(session, premise, session.trialToken, session.abort.signal);
            }, 120);
        }

        function shouldAutoStopForOmissions() {
            return session?.policy === AdvancePolicy.ACTIVE;
        }

        document.addEventListener('visibilitychange', () => {
            try {
                window.speechSynthesis?.resume();
            } catch (err) {
                console.warn('speechSynthesis.resume visibility failed', err);
            }
        });

        class InstructionsManager {
            constructor(engine) {
                this.engine = engine;
                this.voice = engine.voice;
                this.sections = TUTORIAL_SECTIONS;
                this.dialog = document.getElementById('dlgInstructions');
                this.openButton = document.getElementById('btnInstructions');
                this.closeButton = document.getElementById('instClose');
                this.nav = document.getElementById('instTabs');
                this.tabButtons = Array.from(this.nav.querySelectorAll('button'));
                this.content = document.getElementById('instContent');
                this.prevButton = document.getElementById('instPrev');
                this.nextButton = document.getElementById('instNext');
                this.readAloudCheckbox = document.getElementById('instReadAloud');
                this.currentIndex = 0;
                this.dialogOpen = false;
                this.previousFocus = null;
                this.visited = new Set();
                this.completed = false;
                this.readAloud = false;
                this.pendingSpeechToken = null;
                this.boundKeydown = (event) => this.handleKeydown(event);
                this.boundFocusIn = (event) => this.enforceFocus(event);
                this.nav.setAttribute('role', 'tablist');
                this.tabButtons.forEach(btn => {
                    btn.setAttribute('role', 'tab');
                    const isActive = this.sections[this.currentIndex] && this.sections[this.currentIndex].id === btn.dataset.tab;
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    btn.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                this.sandbox = {
                    premise: null,
                    mapping: {},
                    journal: []
                };
                this.sandboxElements = null;
            }

            initialize() {
                this.loadState();
                this.attachEvents();
                this.renderCurrentSection();
                this.updateCompletionState();
            }

            loadState() {
                const storedSection = localStorage.getItem('instSection');
                const storedIndex = this.sections.findIndex(section => section.id === storedSection);
                if (storedIndex >= 0) {
                    this.currentIndex = storedIndex;
                }

                const visitedRaw = localStorage.getItem('instVisited');
                if (visitedRaw) {
                    try {
                        const parsed = JSON.parse(visitedRaw);
                        if (Array.isArray(parsed)) {
                            parsed.forEach(id => this.visited.add(id));
                        }
                    } catch (err) {
                        console.warn('Failed to parse tutorial visited state', err);
                    }
                }

                const completed = localStorage.getItem('instCompleted');
                this.completed = completed === 'true';

                const readAloud = localStorage.getItem('instReadAloud');
                this.readAloud = readAloud === 'true';
                this.readAloudCheckbox.checked = this.readAloud;

                const journalRaw = localStorage.getItem('instPracticeJournal');
                if (journalRaw) {
                    try {
                        const parsed = JSON.parse(journalRaw);
                        if (Array.isArray(parsed)) {
                            this.sandbox.journal = parsed;
                        }
                    } catch (err) {
                        console.warn('Failed to parse sandbox journal', err);
                    }
                }
            }

            attachEvents() {
                this.openButton.addEventListener('click', () => this.openDialog());
                this.closeButton.addEventListener('click', () => this.closeDialog());

                this.tabButtons.forEach((button) => {
                    const sectionId = button.dataset.tab;
                    const index = this.sections.findIndex(section => section.id === sectionId);
                    if (index === -1) return;
                    button.addEventListener('click', () => {
                        this.currentIndex = index;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    });
                });

                this.prevButton.addEventListener('click', () => {
                    if (this.currentIndex > 0) {
                        this.currentIndex -= 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.nextButton.addEventListener('click', () => {
                    if (this.currentIndex < this.sections.length - 1) {
                        this.currentIndex += 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.readAloudCheckbox.addEventListener('change', (event) => {
                    this.readAloud = event.target.checked;
                    localStorage.setItem('instReadAloud', this.readAloud ? 'true' : 'false');
                    if (this.dialogOpen && this.readAloud) {
                        this.queueSpeech(true);
                    } else {
                        this.cancelSpeech();
                    }
                });
            }

            openDialog() {
                if (this.dialogOpen) return;
                this.dialogOpen = true;
                this.previousFocus = document.activeElement;
                this.dialog.hidden = false;
                document.body.classList.add('dialog-open');
                this.content.scrollTop = 0;
                this.markVisited(this.sections[this.currentIndex].id);
                this.focusInitialElement();
                document.addEventListener('keydown', this.boundKeydown, true);
                document.addEventListener('focusin', this.boundFocusIn, true);
                if (this.readAloud) {
                    this.queueSpeech(true);
                }
            }

            closeDialog() {
                if (!this.dialogOpen) return;
                this.dialogOpen = false;
                this.dialog.hidden = true;
                document.body.classList.remove('dialog-open');
                document.removeEventListener('keydown', this.boundKeydown, true);
                document.removeEventListener('focusin', this.boundFocusIn, true);
                this.cancelSpeech();
                if (this.previousFocus && typeof this.previousFocus.focus === 'function') {
                    this.previousFocus.focus();
                } else {
                    this.openButton.focus();
                }
            }

            handleKeydown(event) {
                if (!this.dialogOpen) return;
                if (event.key === 'Escape') {
                    event.preventDefault();
                    this.closeDialog();
                    return;
                }
                if (event.key === 'Tab') {
                    this.trapFocus(event);
                }
            }

            enforceFocus(event) {
                if (!this.dialogOpen) return;
                if (!this.dialog.contains(event.target)) {
                    const focusable = this.getFocusableElements();
                    if (focusable.length > 0) {
                        focusable[0].focus();
                    } else {
                        this.content.focus();
                    }
                }
            }

            trapFocus(event) {
                const focusable = this.getFocusableElements();
                if (focusable.length === 0) {
                    event.preventDefault();
                    this.content.focus();
                    return;
                }
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                const active = document.activeElement;

                if (event.shiftKey) {
                    if (active === first || !this.dialog.contains(active)) {
                        event.preventDefault();
                        last.focus();
                    }
                } else {
                    if (active === last) {
                        event.preventDefault();
                        first.focus();
                    }
                }
            }

            getFocusableElements() {
                const selectors = ['button', '[href]', 'input', 'select', 'textarea', '[tabindex]:not([tabindex="-1"])'];
                return Array.from(this.dialog.querySelectorAll(selectors.join(',')))
                    .filter(el => !el.hasAttribute('disabled') && el.tabIndex !== -1 && this.dialog.contains(el));
            }

            focusInitialElement() {
                const focusable = this.getFocusableElements();
                if (focusable.length > 0) {
                    focusable[0].focus();
                } else {
                    this.content.focus();
                }
            }

            renderCurrentSection() {
                const section = this.sections[this.currentIndex];
                if (!section) return;
                this.tabButtons.forEach((button) => {
                    const isActive = button.dataset.tab === section.id;
                    button.classList.toggle('active', isActive);
                    if (this.visited.has(button.dataset.tab)) {
                        button.classList.add('visited');
                    }
                    button.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    button.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                if (typeof section.render === 'function') {
                    this.content.innerHTML = '';
                    section.render(this.content);
                } else {
                    this.content.innerHTML = section.html;
                    if (section.id === 'examples') {
                        renderGuidedExamples();
                    }
                }
                this.content.scrollTop = 0;
                localStorage.setItem('instSection', section.id);
                this.markVisited(section.id);
                this.updateNavButtons();
                if (section.id === 'practice') {
                    this.setupSandboxUI();
                } else {
                    this.sandboxElements = null;
                }
                if (this.dialogOpen && this.readAloud) {
                    this.queueSpeech();
                }
            }

            updateNavButtons() {
                this.prevButton.disabled = this.currentIndex === 0;
                this.nextButton.disabled = this.currentIndex === this.sections.length - 1;
            }

            markVisited(id) {
                if (!this.visited.has(id)) {
                    this.visited.add(id);
                    localStorage.setItem('instVisited', JSON.stringify(Array.from(this.visited)));
                }
                if (this.visited.size === this.sections.length) {
                    this.completed = true;
                    localStorage.setItem('instCompleted', 'true');
                }
                this.updateCompletionState();
            }

            updateCompletionState() {
                this.openButton.classList.toggle('completed', this.completed);
            }

            async queueSpeech(force = false) {
                if (!this.readAloud || !this.dialogOpen) return;
                if (!this.voice || !this.voice.voiceReady) return;
                const section = this.sections[this.currentIndex];
                if (!section || !section.speech) return;
                const token = Symbol('instSpeech');
                this.pendingSpeechToken = token;
                if (force) {
                    await this.voice.cancelAndWait();
                } else {
                    await this.voice.cancelAndWait();
                }
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!this.dialogOpen || !this.readAloud || this.pendingSpeechToken !== token) {
                    return;
                }
                await this.voice.speak(section.speech, this.voice.sessionToken);
            }

            cancelSpeech() {
                this.pendingSpeechToken = null;
                if (this.voice && typeof this.voice.cancelAndWait === 'function') {
                    this.voice.cancelAndWait();
                }
            }

            setupSandboxUI() {
                const panel = document.createElement('div');
                panel.className = 'sandbox-panel';

                const workspaceTitle = document.createElement('h4');
                workspaceTitle.textContent = 'Practice Workspace';
                panel.appendChild(workspaceTitle);

                const controls = document.createElement('div');
                controls.className = 'sandbox-controls';

                const loadBtn = this.createSandboxButton('Load current premise', () => this.loadCurrentPremise());
                const spawnBtn = this.createSandboxButton('Spawn practice premise', () => this.spawnPracticePremise());
                const applyBtn = this.createSandboxButton('Apply Relation Operations', () => this.applySandboxOperations());
                const commitBtn = this.createSandboxButton('Commit to Journal', () => this.commitSandboxJournal());

                controls.append(loadBtn, spawnBtn, applyBtn, commitBtn);
                panel.appendChild(controls);

                const status = document.createElement('div');
                status.className = 'hint';
                panel.appendChild(status);

                const atoms = document.createElement('div');
                atoms.className = 'sandbox-atom-list';
                panel.appendChild(atoms);

                const grid = document.createElement('div');
                grid.className = 'sandbox-letter-grid';
                panel.appendChild(grid);

                const journalTitle = document.createElement('h4');
                journalTitle.textContent = 'Journal';
                panel.appendChild(journalTitle);

                const journal = document.createElement('div');
                journal.className = 'sandbox-journal';
                panel.appendChild(journal);

                this.content.appendChild(panel);

                this.sandboxElements = {
                    status, atoms, grid, journal
                };

                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.renderSandboxJournal();
                this.updateSandboxStatus('Load the latest premise or spawn a fresh training premise to begin.');
            }

            createSandboxButton(label, handler) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'secondary';
                btn.textContent = label;
                btn.addEventListener('click', handler);
                return btn;
            }

            loadCurrentPremise() {
                const current = this.engine.currentPremises && this.engine.currentPremises.length > 0
                    ? this.engine.currentPremises[this.engine.currentPremises.length - 1]
                    : null;
                if (!current) {
                    this.updateSandboxStatus('No live premise available yet. Start a session or spawn practice.');
                    return;
                }
                this.sandbox.premise = {
                    atoms: current.atoms.map(atom => ({ axis: atom.axis, head: atom.head, tail: atom.tail }))
                };
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Loaded the latest live premise into the sandbox.');
            }

            spawnPracticePremise() {
                const practice = this.generatePracticePremise();
                this.sandbox.premise = practice;
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Spawned a fresh training premise.');
            }

            generatePracticePremise() {
                const k = Math.max(2, Math.min(4, this.engine ? this.engine.k : 3));
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const usedPairs = new Set();
                const atoms = [];
                for (let i = 0; i < k; i++) {
                    let head = letters[Math.floor(Math.random() * letters.length)];
                    let tail = letters[Math.floor(Math.random() * letters.length)];
                    let attempts = 0;
                    while ((head === tail || usedPairs.has(`${head}-${tail}`)) && attempts < 40) {
                        head = letters[Math.floor(Math.random() * letters.length)];
                        tail = letters[Math.floor(Math.random() * letters.length)];
                        attempts += 1;
                    }
                    usedPairs.add(`${head}-${tail}`);
                    const axis = MATCH_AXES[Math.floor(Math.random() * MATCH_AXES.length)];
                    atoms.push({ axis, head, tail });
                }
                return { atoms };
            }

            applySandboxOperations() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before applying operations.');
                    return;
                }
                let changed = false;
                const mapping = this.sandbox.mapping;
                this.sandbox.premise.atoms.forEach(atom => {
                    const headKey = atom.head;
                    const tailKey = atom.tail;
                    const headValue = (mapping[headKey] || '').trim();
                    const tailValue = (mapping[tailKey] || '').trim();
                    const transform = SANDBOX_TRANSFORMS[atom.axis];
                    if (!transform) return;
                    if (tailValue && !headValue) {
                        mapping[headKey] = transform.forward(tailValue);
                        changed = true;
                    } else if (headValue && !tailValue) {
                        mapping[tailKey] = transform.reverse(headValue);
                        changed = true;
                    }
                });
                this.renderSandboxInputs();
                this.updateSandboxStatus(changed ? 'Applied relation operations. Tweak any concept as needed.' : 'No changes applied. Anchor at least one letter first.');
            }

            commitSandboxJournal() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before committing to the journal.');
                    return;
                }
                const entries = Object.entries(this.sandbox.mapping)
                    .map(([letter, value]) => [letter, value ? value.trim() : ''])
                    .filter(([, value]) => value.length > 0)
                    .sort((a, b) => a[0].localeCompare(b[0]));
                if (entries.length === 0) {
                    this.updateSandboxStatus('Add at least one mapped concept before committing.');
                    return;
                }
                const record = {
                    timestamp: new Date().toISOString(),
                    premise: this.sandbox.premise.atoms,
                    mapping: entries
                };
                this.sandbox.journal.unshift(record);
                this.sandbox.journal = this.sandbox.journal.slice(0, 20);
                localStorage.setItem('instPracticeJournal', JSON.stringify(this.sandbox.journal));
                this.renderSandboxJournal();
                this.updateSandboxStatus('Mapping committed to journal.');
            }

            renderSandboxPremise() {
                if (!this.sandboxElements) return;
                const atoms = this.sandbox.premise ? this.sandbox.premise.atoms : [];
                if (!atoms || atoms.length === 0) {
                    this.sandboxElements.atoms.textContent = 'No practice premise loaded yet.';
                } else {
                    this.sandboxElements.atoms.textContent = atoms
                        .map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`)
                        .join('; ');
                }
            }

            renderSandboxInputs() {
                if (!this.sandboxElements) return;
                const grid = this.sandboxElements.grid;
                grid.innerHTML = '';
                if (!this.sandbox.premise) return;
                const letters = new Set();
                this.sandbox.premise.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                Array.from(letters).sort().forEach(letter => {
                    const cell = document.createElement('div');
                    cell.className = 'sandbox-letter';
                    const label = document.createElement('label');
                    label.textContent = `${letter} concept`;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = this.sandbox.mapping[letter] || '';
                    input.addEventListener('input', (event) => {
                        this.sandbox.mapping[letter] = event.target.value;
                    });
                    cell.append(label, input);
                    grid.appendChild(cell);
                });
            }

            renderSandboxJournal() {
                if (!this.sandboxElements) return;
                const journal = this.sandboxElements.journal;
                journal.innerHTML = '';
                if (this.sandbox.journal.length === 0) {
                    const empty = document.createElement('p');
                    empty.className = 'hint';
                    empty.textContent = 'Your journal entries will appear here.';
                    journal.appendChild(empty);
                    return;
                }
                this.sandbox.journal.forEach(entry => {
                    const item = document.createElement('div');
                    item.className = 'sandbox-journal-entry';
                    const timestamp = document.createElement('div');
                    timestamp.innerHTML = `<strong>${new Date(entry.timestamp).toLocaleString()}</strong>`;
                    const premise = document.createElement('div');
                    premise.textContent = `Premise: ${entry.premise.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ')}`;
                    const mapping = document.createElement('div');
                    mapping.innerHTML = entry.mapping.map(([letter, value]) => `<code>${letter}</code>: ${value}`).join('; ');
                    item.append(timestamp, premise, mapping);
                    journal.appendChild(item);
                });
            }

            updateSandboxStatus(message) {
                if (!this.sandboxElements) return;
                this.sandboxElements.status.textContent = message;
            }
        }

        class TestHarness {
            constructor() {
                this.seedManager = new SeedManager();
            }

            async runAll() {
                return [
                    await this.testNovelty(),
                    await this.testContradictions(),
                    await this.testCertificate(),
                    await this.testInputGating(),
                    await this.testProofExamples()
                ];
            }

            async testNovelty() {
                const seeds = [];
                const firstPremises = new Set();
                for (let i = 0; i < 5; i++) {
                    const seed = this.seedManager.generateSessionSeed(false);
                    seeds.push(seed);
                    const state = new GameState(seed, { windowSize: 12 });
                    const solver = new ConstraintSolver();
                    const eq = new EquivalenceEngine(false);
                    const generator = new PremiseGenerator(state, solver, eq);
                    let unique = true;
                    for (let trial = 0; trial < FIRST_N_NOVELTY; trial++) {
                        const result = generator.generate({
                            trialIndex: trial,
                            k: 2,
                            n: 2,
                            plannedMatch: false,
                            nBackPremise: null,
                            middleAtoms: [],
                            avoidLetters: null,
                            allowOverride: false
                        });
                        if (!result) {
                            unique = false;
                            break;
                        }
                        const key = result.premise.toKey();
                        if (firstPremises.has(key)) {
                            unique = false;
                        }
                        firstPremises.add(key);
                        state.novelty.register(state.novelty.buildSignatures(result.premise));
                    }
                }
                return {
                    test: 'Novelty',
                    passed: firstPremises.size >= seeds.length * FIRST_N_NOVELTY,
                    details: 'First six premises differ across restarts'
                };
            }

            async testContradictions() {
                const state = new GameState(12345, { windowSize: 12 });
                const solver = new ConstraintSolver();
                const atoms = [new Atom('N', 'A', 'B'), new Atom('S', 'A', 'B')];
                const sat = solver.evaluate([], atoms);
                return {
                    test: 'Constraint contradictions',
                    passed: !sat.ok,
                    details: 'Opposite relations rejected by SAT core'
                };
            }

            async testCertificate() {
                const premiseA = new Premise([new Atom('N', 'A', 'B'), new Atom('W', 'A', 'C')]);
                const premiseB = new Premise([new Atom('S', 'B', 'A'), new Atom('E', 'C', 'A')]);
                const eq = new EquivalenceEngine(false);
                const certificate = eq.computeCertificate(premiseA, premiseB, []);
                return {
                    test: 'Certificate generation',
                    passed: certificate.match && certificate.certificate.mapping.length === 2,
                    details: 'Invertible mapping generated for 2-atom pair'
                };
            }

            async testInputGating() {
                const dummyEngine = new GameEngine();
                await dummyEngine.voice.initialize();
                const dummySession = {
                    ...newSession(dummyEngine),
                    abort: new AbortController(),
                    trialToken: 1
                };
                session = dummySession;
                const promise = collectResponseSafe(0.05, dummySession.trialToken, dummySession.abort.signal);
                dummySession.abort.abort();
                const result = await promise;
                session = null;
                return {
                    test: 'Input gating',
                    passed: result.type === 'timeout',
                    details: 'Abort resolves response promise as timeout'
                };
            }

            async testProofExamples() {
                const eq = new EquivalenceEngine(false);
                const p1 = new Premise([new Atom('N', 'A', 'B')]);
                const mid = [new Atom('N', 'B', 'C')];
                const p2 = new Premise([new Atom('N', 'A', 'C')]);
                const cert = eq.computeCertificate(p1, p2, mid);
                return {
                    test: 'Proof-based equivalence',
                    passed: !cert.match,
                    details: 'Mid-window derivable relation rejected when transitivity off'
                };
            }
        }

        const engine = new GameEngine();
        const instructions = new InstructionsManager(engine);
        instructions.initialize();
        engine.initialize().then(() => {
            console.log('Game engine initialization complete');
            instructions.updateCompletionState();
            if (instructions.dialogOpen && instructions.readAloud) {
                instructions.queueSpeech(true);
            }
        }).catch((error) => {
            console.error('Game engine initialization failed:', error);
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = 'Voice initialization failed. Check console for details.';
            }
            alert('Voice system failed to initialize. Please check your browser settings and reload the page.\n\nError: ' + error.message);
        });
    </script>
</body>
</html>

