<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imagi-world</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin: 20px 0;
            font-size: 2rem;
            text-align: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .controls {
            background: #16213e;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #numTrialsSlider {
            width: 100%;
            margin-top: 8px;
        }

        #numTrialsDisplay {
            display: block;
            margin-top: 8px;
            font-weight: 600;
            color: #e94560;
        }

        .label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .hint {
            display: block;
            margin-top: 4px;
            color: #aaa;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        input[type="range"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: 1px solid #1a4d7a;
            border-radius: 6px;
            font-size: 1rem;
            margin-left: 10px;
        }

        input[type="number"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .range-value {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #e94560;
        }

        .dual-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dual-control input[type="range"] {
            flex: 1;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #d63651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        #btnInstructions.completed::after {
            content: ' ‚úì';
            font-weight: 700;
            color: #2ecc71;
        }

        button.secondary {
            background: #0f3460;
        }

        button.secondary:hover:not(:disabled) {
            background: #1a4d7a;
        }

        button.danger {
            background: #c0392b;
        }

        button.danger:hover:not(:disabled) {
            background: #a93226;
        }

        button.success {
            background: #27ae60;
        }

        button.success:hover:not(:disabled) {
            background: #229954;
        }

        .game-area {
            background: #16213e;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            width: 100%;
        }

        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e94560;
        }

        .response-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .response-buttons button {
            flex: 1;
            padding: 20px;
            font-size: 1.2rem;
        }

        .match-btn {
            background: #2ecc71;
        }

        .match-btn:hover:not(:disabled) {
            background: #27ae60;
        }

        .no-match-btn {
            background: #e74c3c;
        }

        .no-match-btn:hover:not(:disabled) {
            background: #c0392b;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .feedback.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .feedback.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        #debug {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
        }

        #debug h3 {
            margin-bottom: 15px;
            color: #e94560;
        }

        .debug-premise {
            margin-bottom: 10px;
            padding: 8px;
            background: #16213e;
            border-radius: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .voice-info {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 10px;
        }

        .voice-info strong {
            color: #e94560;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .test-panel {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }


        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .test-result.pass {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .test-result.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .premise-display {
            font-size: 1.3rem;
            color: #aaa;
            margin: 20px 0;
            min-height: 60px;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .response-buttons {
                flex-direction: column;
            }
        }

        #dlgInstructions {
            position: fixed;
            inset: 0;
            background: rgba(10, 14, 26, 0.88);
            backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 999;
        }

        #dlgInstructions[hidden] {
            display: none;
        }

        #dlgInstructions > header,
        #dlgInstructions > footer,
        #dlgInstructions > nav,
        #dlgInstructions > article {
            width: min(960px, 100%);
        }

        #dlgInstructions > header {
            background: #16213e;
            padding: 20px 60px 20px 24px;
            border-radius: 12px 12px 0 0;
            position: relative;
        }

        #instTitle {
            margin-bottom: 12px;
            font-size: 1.6rem;
        }

        #instClose {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            font-size: 1.4rem;
            line-height: 1;
            color: #e94560;
            cursor: pointer;
            padding: 4px 8px;
        }

        #instClose:hover {
            transform: none;
            color: #fff;
            background: transparent;
            box-shadow: none;
        }

        #instTabs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            background: #0f3460;
            padding: 16px;
        }

        #instTabs button {
            background: #16213e;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.95rem;
            border: 1px solid transparent;
        }

        #instTabs button.active {
            background: #e94560;
            border-color: #f08fa2;
        }

        #instTabs button.visited:not(.active) {
            border-color: #27ae60;
        }

        #instContent {
            background: #0a0e1a;
            padding: 24px;
            min-height: 280px;
            max-height: 360px;
            overflow-y: auto;
            outline: none;
        }

        #instContent h3 {
            margin-bottom: 12px;
            font-size: 1.3rem;
        }

        #instContent p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #walkthroughN2 .algo li {
            margin: 0.25rem 0;
        }

        #walkthroughN2 .anchors,
        #walkthroughN2 .returns {
            margin-left: 1rem;
        }

        #walkthroughN2 .trials > li {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border: 1px solid var(--border, #444);
            border-radius: 0.5rem;
            background: rgba(22, 33, 62, 0.6);
        }

        #walkthroughN2 .match {
            color: var(--ok, #2ecc71);
            font-weight: 600;
        }

        #walkthroughN2 .nomatch {
            color: var(--warn, #e67e22);
            font-weight: 600;
        }

        #walkthroughN2 .actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        #walkthroughN2 .brandline {
            margin-bottom: 0.5rem;
        }

        #instContent ul,
        #instContent ol {
            margin-left: 20px;
            margin-bottom: 12px;
            line-height: 1.6;
        }

        #examplesFilters {
            margin: .5rem 0 1rem;
            display: flex;
            gap: .5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        #examplesFilters button.active {
            font-weight: 700;
            text-decoration: underline;
        }

        #examplesList > li {
            margin: 0 0 1rem 0;
            padding: .75rem;
            border: 1px solid var(--border, #ddd);
            border-radius: .5rem;
        }

        .exActions {
            display: flex;
            gap: .5rem;
            margin-top: .5rem;
        }

        #instFooter {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #16213e;
            padding: 16px 24px;
            border-radius: 0 0 12px 12px;
        }

        #instFooter .inline {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        #instFooter .spacer {
            flex: 1;
        }

        .inst-brand-tagline {
            font-size: 0.9rem;
            color: #f5c0d1;
            line-height: 1.5;
        }

        body.dialog-open {
            overflow: hidden;
        }

        .sandbox-panel {
            margin-top: 16px;
            padding: 16px;
            background: #111a33;
            border-radius: 8px;
        }

        .sandbox-panel h4 {
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .sandbox-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .sandbox-letter {
            background: #16213e;
            padding: 10px;
            border-radius: 6px;
        }

        .sandbox-letter label {
            font-size: 0.85rem;
            margin-bottom: 6px;
        }

        .sandbox-letter input[type="text"] {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #1a4d7a;
            background: #0f3460;
            color: #fff;
        }

        .sandbox-atom-list {
            margin-bottom: 12px;
            font-family: 'Courier New', monospace;
        }

        .sandbox-journal {
            margin-top: 12px;
            max-height: 140px;
            overflow-y: auto;
            background: #0f0f24;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .sandbox-journal-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed rgba(233, 69, 96, 0.4);
        }

        @media (max-width: 780px) {
            #instTabs {
                grid-template-columns: repeat(2, 1fr);
            }

            #instFooter {
                flex-direction: column;
                align-items: stretch;
            }

            #instFooter .spacer {
                display: none;
            }

            .inst-footer-brand {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <h1>üåÄImagi-worldüåÄ</h1>

        <div class="controls">
            <div class="control-group">
                <label>N-Back Level: <span class="range-value" id="n-value">1</span></label>
                <input type="range" id="n-slider" min="1" max="5" value="1">
            </div>

            <div class="control-group">
                <label><span id="k-label">Atoms per Premise</span> (k): <span class="range-value" id="k-value">1</span></label>
                <input type="range" id="k-slider" min="1" max="4" value="1">
            </div>

            <div class="control-group">
                <label>Seconds per Trial: <span class="range-value" id="spt-value">8.0</span> s</label>
                <div class="dual-control">
                    <input type="range" id="spt-slider" min="1" max="60" step="0.5" value="8.0">
                    <input type="number" id="spt-number" min="1" max="60" step="0.5" value="8.0">
                </div>
            </div>

            <div class="control-group">
                <label for="numTrialsInput">Number of trials per session</label>
                <input id="numTrialsInput" type="number" min="1" max="10000" step="1" value="20" />
                <input id="numTrialsSlider" type="range" min="1" max="500" step="1" value="20" />
                <span id="numTrialsDisplay">Trials: 20</span>
            </div>

            <div class="control-group">
                <label for="logic-level-select">Topology Mode (Da Vinci Hierarchy):</label>
                <select id="logic-level-select" style="width: 100%; padding: 8px; background: #0f3460; color: #eee; border: 1px solid #e94560; border-radius: 4px; font-size: 0.95rem;">
                    <option value="0">Standard / Manual (User Controls k)</option>
                    <option value="1">Dialectical Superposition (1 Node, 2 Vectors - k=2)</option>
                    <option value="2">Semantic Tensor (3 Nodes, Intersection - k=2)</option>
                    <option value="3">System Homology (4 Nodes, Symmetry - k=3)</option>
                    <option value="4">Complementary Interface (6 Nodes, Asymmetry - k=5)</option>
                </select>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="lock-seed-toggle">
                <label for="lock-seed-toggle" style="margin-bottom: 0;">Lock seed (reuse until unlocked)</label>
            </div>

            <div class="control-group" style="margin-top: 15px;">
                <button id="force-new-seed-btn" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #e94560 0%, #c72a47 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 1rem; transition: all 0.3s ease; box-shadow: 0 2px 5px rgba(233, 69, 96, 0.3);">
                    üîÑ Force New Seed (Clear Lock & Reset)
                </button>
                <div style="font-size: 0.85rem; color: #aaa; margin-top: 5px; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                    Clears localStorage seed cache. Next session will use a completely fresh random seed. Use if premises are repeating.
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="reset-seed-toggle">
                <label for="reset-seed-toggle" style="margin-bottom: 0;">Reset stats & logs on Restart</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="debug-toggle">
                <label for="debug-toggle" style="margin-bottom: 0;">Show Debug Panel</label>
            </div>

            <div class="control-group">
                <label class="inline" title="Let the session play without responses">
                    <input id="listenOnlyToggle" type="checkbox" />
                    Listen-Only (Auto-Advance)
                </label>
                <small id="listenOnlyHint" aria-live="polite" hidden>
                    Listening mode: scoring disabled; session will auto-advance to completion.
                </small>
            </div>

            <div style="margin-top: 20px;">
                <div class="button-group">
                    <button id="start-btn" class="success">Start</button>
                    <button id="restart-btn" class="success" disabled>Restart</button>
                    <button id="stop-btn" class="danger" disabled>Stop</button>
                    <button id="repeat-btn" class="secondary" disabled>Repeat Audio</button>
                    <button id="preview-btn" class="secondary">Voice Preview</button>
                    <button id="reset-voice-btn" class="secondary">Reset Voice</button>
                    <button id="btnInstructions" aria-haspopup="dialog" aria-controls="dlgInstructions">Instructions</button>
                    <button id="btnDaVinciInstructions" class="secondary" style="background: #ffa500; color: white;">Da Vinci does Imagi-World</button>
                </div>
                <div class="button-group">
                    <button id="test-btn" class="secondary">Run Tests</button>
                    <button id="export-btn" class="secondary">Download so far</button>
                </div>
            </div>

            <div class="voice-info" id="voice-info">Initializing voice...</div>

            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                 RUNTIME DIAGNOSTICS PANEL
                 Shows actual runtime values during session (not just UI selections).
                 Critical for debugging mode/seed issues.
                 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
            <div id="runtime-diagnostics-panel" style="background: linear-gradient(135deg, #16213e 0%, #0f3460 100%); padding: 15px; margin: 15px 0; border-left: 5px solid #e94560; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: none;">
                <h3 style="color: #e94560; margin: 0 0 10px 0; font-size: 1.1rem; font-weight: bold;">üîç Runtime Diagnostics</h3>
                <div style="display: grid; grid-template-columns: 1fr; gap: 8px; font-family: 'Courier New', monospace; font-size: 0.95rem;">
                    <div id="runtime-mode-indicator" style="color: #00ffff; font-weight: bold; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                        <span style="color: #aaa;">Active Mode:</span> <span id="mode-value">Not Started</span>
                    </div>
                    <div id="runtime-k-indicator" style="color: #00ffff; font-weight: bold; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                        <span style="color: #aaa;">Runtime k:</span> <span id="k-value-runtime">Not Started</span>
                    </div>
                    <div id="runtime-seed-indicator" style="color: #00ffff; font-weight: bold; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                        <span style="color: #aaa;">Session Seed:</span> <span id="seed-value-runtime">Not Started</span>
                    </div>
                    <div id="runtime-trial-indicator" style="color: #00ffff; font-weight: bold; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                        <span style="color: #aaa;">Current Trial:</span> <span id="trial-value-runtime">0/0</span>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 8px; background: rgba(233, 69, 96, 0.1); border-radius: 3px; font-size: 0.85rem; color: #ccc;">
                    <strong style="color: #e94560;">Note:</strong> These show ACTUAL runtime values, not UI selections. If Mode shows "0 (Standard)" but you selected Mode 1, there's a dropdown issue.
                </div>
            </div>
        </div>

        <div class="game-area">
            <div class="status" id="status">Preparing voice system...</div>
            <div class="premise-display" id="premise-display"></div>

            <div class="response-buttons">
                <button class="match-btn" id="match-btn" disabled>
                    MATCH<br><small>(Spacebar)</small>
                </button>
                <button class="no-match-btn" id="no-match-btn" disabled>
                    NO MATCH<br><small>(Enter)</small>
                </button>
            </div>

            <div class="feedback" id="feedback"></div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Trial</div>
                    <div class="stat-value" id="trial-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="accuracy">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Rolling Acc.</div>
                    <div class="stat-value" id="rolling-acc">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Omissions</div>
                    <div class="stat-value" id="omissions">0</div>
                </div>
            </div>
        </div>


        <div id="debug" hidden>
            <h3>Debug Panel - Last Premises</h3>
            <div id="debug-content"></div>
        </div>

        <div id="test-panel" class="test-panel" hidden>
            <h3>Test Results</h3>
            <div id="test-results"></div>
        </div>
    </main>

    <section id="dlgInstructions" role="dialog" aria-modal="true" aria-labelledby="instTitle" hidden>
        <header>
            <h2 id="instTitle">Imagi-World: Learn the Arc of Abstraction</h2>
            <p class="inst-brand-tagline"><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness.</p>
            <button id="instClose" aria-label="Close">‚úï</button>
        </header>

        <nav id="instTabs" aria-label="Tutorial Sections">
            <button data-tab="welcome" class="active">Welcome</button>
            <button data-tab="compass">Imagi-Compass</button>
            <button data-tab="anchor">Anchor &amp; Transform</button>
            <button data-tab="examples">Guided Examples</button>
            <button data-tab="practice">Sandbox Practice</button>
            <button data-tab="mastery">Mastery Path</button>
            <button data-tab="level2-dialectical">Level 2: Superposition</button>
            <button data-tab="level3-tensor">Level 3: Tensor</button>
            <button data-tab="level4-homology">Level 4: Homology</button>
            <button data-tab="level5-interface">Level 5: Interface</button>
            <button data-tab="davinci-method">Da Vinci does Imagi-World</button>
            <button data-tab="pitfalls">Pitfalls &amp; FAQ</button>
            <button data-tab="glossary">Glossary</button>
        </nav>

        <article id="instContent" tabindex="0" aria-live="polite"></article>

        <footer id="instFooter">
            <label class="inline">
                <input id="instReadAloud" type="checkbox" />
                Read this section aloud
            </label>
            <div class="spacer"></div>
            <button id="instPrev">‚Üê Previous</button>
            <button id="instNext">Next ‚Üí</button>
        </footer>
    </section>

    <script type="module">
        const RELATION_WORDS = { N: 'north of', NE: 'northeast of', E: 'east of', SE: 'southeast of', S: 'south of', SW: 'southwest of', W: 'west of', NW: 'northwest of' };
        const MATCH_AXES = ['N', 'S', 'E', 'W'];

        const ACCEPTANCE_ALPHA = 0.25;
        const ACCEPTANCE_BETA = 0.5;
        const FIRST_N_NOVELTY = 6;
        const HAMMING_WINDOW = 8;
        const NOVELTY_OVERRIDE_THRESHOLD = 30;
        const MAX_GENERATION_ATTEMPTS = 240;
        const conflictConfig = {
            foilRate: 0.35,
            foilTypesWeights: {
                ANCHOR_ONE: 0.20,
                PAIR_SWAP: 0.20,
                PARITY_OFF: 0.15,
                AXIS_ORTHO: 0.15,
                DERIVED_IN_ONE: 0.15,
                WINDOW_SHADOW: 0.15
            }
        };

        const NUM_TRIALS_KEY = 'numTrials';
        const LISTEN_ONLY_KEY = 'listenOnly';
        const numTrialsInput = document.getElementById('numTrialsInput');
        const numTrialsSlider = document.getElementById('numTrialsSlider');
        const numTrialsDisplay = document.getElementById('numTrialsDisplay');
        const listenOnlyToggle = document.getElementById('listenOnlyToggle');
        const listenOnlyHint = document.getElementById('listenOnlyHint');

        function loadListenOnly() {
            try {
                return localStorage.getItem(LISTEN_ONLY_KEY) === '1';
            } catch (err) {
                console.warn('Failed to load listen-only preference', err);
                return false;
            }
        }

        function persistListenOnly(on) {
            try {
                localStorage.setItem(LISTEN_ONLY_KEY, on ? '1' : '0');
            } catch (err) {
                console.warn('Failed to persist listen-only preference', err);
            }
            if (listenOnlyHint) {
                listenOnlyHint.hidden = !on;
            }
        }

        if (listenOnlyToggle) {
            const initListenOnly = loadListenOnly();
            listenOnlyToggle.checked = initListenOnly;
            persistListenOnly(initListenOnly);
            listenOnlyToggle.addEventListener('change', () => {
                persistListenOnly(listenOnlyToggle.checked);
            });
        }

        const TUTORIAL_SECTIONS = [
            {
                id: 'welcome',
                title: 'Welcome to Imagi-World',
                html: `
                    <h3>Welcome to Imagi-World</h3>
                    <p><strong>Imagi-World</strong> trains maximized imagination across the <strong>Arc of Abstraction</strong>. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness.</p>
                    <p>Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the <strong>Arc of Abstraction</strong> using the <strong>Imagi-Compass</strong>. North means <strong>up-shift</strong> to higher-order concepts, South means <strong>down-shift</strong> to concrete instances, East means <strong>analogue</strong> (same role/sibling concept), West means <strong>opposite</strong> (counterpart/foil).</p>
                    <p>The spatial logic remains strict; your analogies ride on top. This union‚Äîformal clarity plus creative projection‚Äîis our brand and our method.</p>
                    <p><strong>Outcome:</strong> by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.</p>
                `,
                speech: 'Welcome to Imagi-World. Imagi-World trains maximized imagination across the Arc of Abstraction. At its intersection with your lived experience lies the engine of creation, recognition, and extension of thought‚Äîyour route to deeper consciousness. Imagi-World is imagination with a steering wheel. You will learn to project your lived thoughts onto letters and then move them along the Arc of Abstraction using the Imagi-Compass. North means up-shift to higher-order concepts. South means down-shift to concrete instances. East means analogue, the same role or a sibling concept. West means opposite, the counterpart or foil. The spatial logic remains strict, and your analogies ride on top. This union, formal clarity plus creative projection, is our brand and our method. Outcome: by the end, you will anchor any symbol to a vivid mental seed and transform it consistently through multiple relational steps, even under time pressure.'
            },
            {
                id: 'compass',
                title: 'The Imagi-Compass',
                html: `
                    <h3>The Imagi-Compass</h3>
                    <ul>
                        <li><strong>North (‚Üë Up-shift):</strong> move to meta, greater scale, more general, more intense. "Candle ‚Üí Fireworks"; "Task ‚Üí Project ‚Üí Program."</li>
                        <li><strong>South (‚Üì Down-shift):</strong> move to instance, component, concrete, less intense. "Theory ‚Üí Example"; "System ‚Üí Tool ‚Üí Part."</li>
                        <li><strong>East (‚Üí Analogue):</strong> parallel function or sibling concept. "Candle ‚Üí Lantern"; "Fact ‚Üí Case study"; "Parent ‚Üí Guardian."</li>
                        <li><strong>West (‚Üê Opposite):</strong> antonym/counter-role. "Fact ‚Üî Fiction"; "Order ‚Üî Chaos"; "Light ‚Üî Darkness."</li>
                    </ul>
                    <p><strong>Rule:</strong> your analogical mapping must be <strong>self-consistent</strong> within a session. Reframes are allowed but must be acknowledged.</p>
                `,
                speech: 'The Imagi-Compass. North, the up-shift, moves to meta, to greater scale, to more general or more intense territory. Candle to fireworks. Task to project to program. South, the down-shift, moves to instance, to component, to concrete or less intense forms. Theory to example. System to tool to part. East, the analogue, is the parallel function or sibling concept. Candle to lantern. Fact to case study. Parent to guardian. West, the opposite, is the antonym or counter-role. Fact to fiction. Order to chaos. Light to darkness. Rule: your analogical mapping must be self-consistent within a session. Reframes are allowed but must be acknowledged.'
            },
            {
                id: 'anchor',
                title: 'Step-by-Step: Anchor & Transform',
                html: `
                    <h3>Step-by-Step: Anchor &amp; Transform</h3>
                    <ol>
                        <li><strong>Anchor</strong> one letter from the current premise to a real concept from your stream of consciousness (write it or think it). Example: <code>X := "Fact"</code>.</li>
                        <li><strong>Transform</strong> per atom:
                            <ul>
                                <li><code>Y is north of X</code> ‚Üí <code>Y := Up-shift(X)</code> ‚Üí "Theory".</li>
                                <li><code>Z is west of X</code> ‚Üí <code>Z := Opposite(X)</code> ‚Üí "Fiction".</li>
                                <li><code>R is south of Y</code> ‚Üí <code>R := Down-shift(Y)</code> ‚Üí "Example".</li>
                                <li><code>H is east of R</code> ‚Üí <code>H := Analogue(R)</code> ‚Üí "Case study".</li>
                            </ul>
                        </li>
                        <li><strong>Check coherence</strong>: does each transformed concept match its relational cue? If yes, commit this mapping to your session notes.</li>
                        <li><strong>Never bleed analogies into scoring</strong>: logic is graded by the formal engine; analogies are your training mirror.</li>
                    </ol>
                    <p><strong>Mantra:</strong> <strong>Anchor ‚Üí Transform ‚Üí Cohere ‚Üí Commit.</strong></p>
                `,
                speech: 'Step-by-Step: Anchor and Transform. One: Anchor one letter from the current premise to a real concept from your stream of consciousness, write it or think it. Example: X equals Fact. Two: Transform per atom. Y is north of X, so Y equals the up-shift of X, Theory. Z is west of X, so Z equals the opposite of X, Fiction. R is south of Y, so R equals the down-shift of Y, Example. H is east of R, so H equals the analogue of R, Case study. Three: Check coherence. Does each transformed concept match its relational cue? If yes, commit this mapping to your session notes. Four: Never bleed analogies into scoring. Logic is graded by the formal engine; analogies are your training mirror. Mantra: Anchor, Transform, Cohere, Commit.'
            },
            {
                id: 'examples',
                title: 'Guided Examples',
                html: `
                    <h3>Guided Examples</h3>
                    <p>The worked library loads in a moment. Use it to study beginner-friendly mappings across every compass move.</p>
                `,
                speech: 'Guided Examples. Explore the library of thirty worked analogies. Use the filter buttons to focus on single atoms, dual heads, chains, or full quartets. Each entry shows the premise, anchors, compass moves, the resulting mapping, and a quick rationale. Tap Speak summary to hear one in the same training voice.'
            },
            {
                id: 'practice',
                title: 'Sandbox Practice (Not Scored)',
                html: `
                    <h3>Sandbox Practice (Not Scored)</h3>
                    <ul>
                        <li>This is a safe studio. Load the <strong>latest premise</strong> (button "Load current premise"), or spawn a <strong>fresh training premise</strong> (button "Spawn practice premise").</li>
                        <li>Enter concepts for the letters; click <strong>Apply Relation Operations</strong> to auto-suggest analogues/opposites/up/down (you may override).</li>
                        <li>Use <strong>Commit to Journal</strong> to save your mapping snapshots (they do not affect your game score).</li>
                        <li>Toggle <strong>Read this section aloud</strong> for gentle narration using the same single voice the game uses.</li>
                    </ul>
                    <p><strong>Tip:</strong> strive for <strong>one-sentence explanations</strong> that justify your choices: "I chose <em>Theory</em> above <em>Fact</em> because it generalizes observations into predictive structure."</p>
                `,
                speech: 'Sandbox Practice, not scored. This is a safe studio. Load the latest premise with the button Load current premise, or spawn a fresh training premise with the button Spawn practice premise. Enter concepts for the letters; click Apply Relation Operations to auto-suggest analogues, opposites, up, or down shifts. You may override anything. Use Commit to Journal to save your mapping snapshots. They do not affect your game score. Toggle Read this section aloud for gentle narration using the same single voice the game uses. Tip: strive for one-sentence explanations that justify your choices, such as, I chose Theory above Fact because it generalizes observations into predictive structure.'
            },
            {
                id: 'mastery',
                title: 'Mastery: From Symbols to Schemas',
                html: `
                    <h3>Topology Mastery Path</h3>
                    <ul>
                        <li><strong>Mode 0 ‚Äî Standard / Manual:</strong> Traditional n-back with user-controlled k (1-5 atoms). Use the k-slider to adjust relational complexity. This is your baseline - master this before exploring topological modes.</li>
                        <li><strong>Level 1 ‚Äî Linear Chains:</strong> Multi-step reasoning with three atoms per premise. Example: "A is north of B, B is east of C". Trains sequential logical processing and chain-of-reasoning capacity (k=3 fixed).</li>
                        <li><strong>Level 2 ‚Äî Dialectical Superposition:</strong> One relationship with dual orthogonal constraints. Example: "A is north and west of B" means A relates to B via TWO perpendicular axes simultaneously. Trains parallel processing capacity (k=2 fixed).</li>
                        <li><strong>Level 3 ‚Äî Semantic Tensor:</strong> Cross-domain intersection where A = f(B) ‚à© g(C). Example: "A is north of B and east of C" - A exists at the tensor product of two transformations. Trains integration capacity (k=2 fixed).</li>
                        <li><strong>Level 4 ‚Äî System Homology:</strong> Meta-isomorphism detection comparing structural dynamics. Example: "(north of A) is east of (north of B)" - both domains transform identically. Trains second-order pattern recognition (k=3 fixed).</li>
                        <li><strong>Level 5 ‚Äî Complementary Interface:</strong> Heterogeneous integration assessing functional compatibility. Example: "(North-West of A) is west of (South-East of B)" - two divergent transformation paths interface. Trains systems thinking (k=5 fixed).</li>
                        <li><strong>Advanced Strategy ‚Äî Semantic Anchoring (Mental Technique):</strong> This is <strong>not a separate game mode</strong>‚Äîit's a powerful mental strategy you can apply to any level. Instead of manipulating abstract letters, you <strong>mentally anchor them to concrete concepts</strong> from your lived experience. <br><strong>How It Works (Purely Mental):</strong> (1) System shows: <code>N is north of J</code>. (2) You mentally anchor: J := "Fact". (3) You mentally transform: North(J‚ÜíN) = up-shift "Fact" ‚Üí "Theory". (4) You mentally map: N := "Theory". (5) In your head, the premise becomes "Theory is the higher abstraction of Fact". <br><strong>The Key:</strong> The system <strong>never sees</strong> your semantic anchors. They exist purely in your working memory. This maximizes g-load because YOUR imagination creates the entire semantic layer.</li>
                    </ul>
                    <p><strong>Mastery litmus:</strong> you can improvise <strong>new, coherent mappings</strong> at speed, across themes, while the logic engine remains satisfied‚Äîno contradictions, no shortcuts.</p>
                `,
                speech: 'Mastery: From Symbols to Schemas. Level one, Linear Chains, Multi-Step: Three or more atoms spanning two axes; maintain semantic integrity across the chain. Execute sequential transformations while preserving logical consistency. Level two, Dialectical Superposition, One Node, Two Vectors: Hold two orthogonal axes simultaneously on one relationship. Example: A is north and west of B means A relates to B via TWO perpendicular transformations at once, superposition of constraints, not sequential application. Trains parallel processing capacity. Level three, Semantic Tensor, Three Nodes, Intersection: Solve for the intersection of two orthogonal transformations. Example: A is north of B and east of C means A equals the intersection of the up-shift of B and the analogue of C, where north and east are independent operations. A exists at the tensor product of two vector spaces. Trains cross-domain integration. Level four, System Homology, Four Nodes, Meta-Isomorphism: Compare structural dynamics across domains. Example: north of A is east of north of B. Note both use north, revealing A and B undergo IDENTICAL transformations. You are detecting meta-structural equivalence, domains that respond identically to the same operations. Trains second-order pattern recognition. Level five, Complementary Interface, Six Nodes, Asymmetry: Assess functional compatibility of divergent processes. Example: North-West of A is West of South-East of B means two different transformation sequences, A to north to west versus B to south to east, produce endpoints that interface via a third relationship. Tests whether heterogeneous systems can integrate functionally. Trains cross-domain systems thinking. Advanced Strategy, Semantic Anchoring, Mental Technique: This is not a separate game mode, it is a powerful mental strategy you can apply to any level. Instead of manipulating abstract letters, you mentally anchor them to concrete concepts from your lived experience. Mastery litmus: you can improvise new, coherent mappings at speed, across themes, while the logic engine remains satisfied‚Äîno contradictions, no shortcuts.'
            },
            {
                id: 'pitfalls',
                title: 'Pitfalls & FAQ',
                html: `
                    <h3>Pitfalls &amp; FAQ</h3>
                    <dl>
                        <dt><strong>Q:</strong> Can I use the same word for East (analogue)?</dt>
                        <dd><strong>A:</strong> Prefer <strong>siblings</strong>, not duplicates. "Candle ‚Üí Lantern," not "Candle ‚Üí Candle."</dd>
                        <dt><strong>Q:</strong> My West choice feels too cartoonish.</dt>
                        <dd><strong>A:</strong> "Opposite" includes <strong>counter-role</strong> or <strong>antagonist</strong>, not just antonym. "Order ‚Üî Chaos," "Plan ‚Üî Improvisation."</dd>
                        <dt><strong>Q:</strong> What if my mapping breaks later?</dt>
                        <dd><strong>A:</strong> Use a <strong>Reframe</strong> action. Log it. Consistency matters more than stubbornness.</dd>
                        <dt><strong>Q:</strong> Do analogies change scoring?</dt>
                        <dd><strong>A:</strong> No. Scoring is formal. Analogies train your <strong>semantic agility</strong>.</dd>
                        <dt><strong>Q (Level 6):</strong> How do I know if a META premise is True or False?</dt>
                        <dd><strong>A:</strong> Deduce the hidden operator for each pair. Example: "North to South" = Up-shift‚ÜíDown-shift = <strong>Opposite (West)</strong>. "East to West" = Analogue‚ÜíOpposite = <strong>Opposite (West)</strong>. West = West ‚Üí <strong>True</strong>. If operators differ, it's False. If both are orthogonal (no relationship), it's True.</dd>
                        <dt><strong>Q (Level 6):</strong> What's an "orthogonal" relationship?</dt>
                        <dd><strong>A:</strong> No clear relationship exists. Example: North‚ÜíEast (Up-shift‚ÜíAnalogue) has no operator because they're perpendicular concepts. If <strong>both</strong> pairs are orthogonal, the premise is True (None = None).</dd>
                        <dt><strong>Q (Level 6):</strong> How does n-back matching work for META premises?</dt>
                        <dd><strong>A:</strong> Match on <strong>truth value</strong>, not operators. If n-back premise was True and current premise is True ‚Üí MATCH. If n-back was False and current is False ‚Üí MATCH. Different truth values ‚Üí NO MATCH.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> What if I can't think of a good semantic anchor?</dt>
                        <dd><strong>A:</strong> Use the directional concept as a guide. For North (Up-shift), think: mature‚Üíimmature, complex‚Üísimple, whole‚Üípart. For South (Down-shift), reverse it. For East (Analogue), think: siblings, parallel roles, same category. For West (Opposite), think: antonyms, counter-roles, complementary pairs.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Does it matter what semantic anchors I choose?</dt>
                        <dd><strong>A:</strong> Not to the system‚Äîit never sees them! Choose anchors that are <strong>vivid and memorable to YOU</strong>. The cognitive load comes from generating AND remembering YOUR specific mental anchors across n-back trials.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Should I use the same anchors throughout a session?</dt>
                        <dd><strong>A:</strong> It helps! If J := "Fact" in trial 1, keeping it as "Fact" throughout makes recall easier. But you can also challenge yourself by creating fresh anchors each trial.</dd>
                        <dt><strong>Q (Semantic Anchoring):</strong> Can I write down my semantic anchors?</dt>
                        <dd><strong>A:</strong> You can, but that defeats the purpose! The cognitive training comes from maintaining these anchors <strong>in working memory only</strong>. Writing them down is like using a calculator instead of doing mental math.</dd>
                    </dl>
                `,
                speech: 'Pitfalls and FAQ. Question: Can I use the same word for East, the analogue? Answer: Prefer siblings, not duplicates. Candle to Lantern, not Candle to Candle. Question: My West choice feels too cartoonish. Answer: Opposite includes counter-role or antagonist, not just antonym. Order to Chaos. Plan to Improvisation. Question: What if my mapping breaks later? Answer: Use a Reframe action. Log it. Consistency matters more than stubbornness. Question: Do analogies change scoring? Answer: No. Scoring is formal. Analogies train your semantic agility. Question, Level six: How do I know if a META premise is true or false? Answer: Deduce the hidden operator for each pair. Example: North to South equals Up-shift to Down-shift equals Opposite, West. East to West equals Analogue to Opposite equals Opposite, West. West equals West, so True. If operators differ, it is False. If both are orthogonal, no relationship, it is True. Question, Level six: What is an orthogonal relationship? Answer: No clear relationship exists. Example: North to East, Up-shift to Analogue, has no operator because they are perpendicular concepts. If both pairs are orthogonal, the premise is True, None equals None. Question, Level six: How does n-back matching work for META premises? Answer: Match on truth value, not operators. If n-back premise was True and current premise is True, MATCH. If n-back was False and current is False, MATCH. Different truth values, NO MATCH. Question, Level seven: What if I cannot think of a semantic pair? Answer: Use the concept hint shown in the modal. For North, Up-shift, think mature to immature, complex to simple. For South, reverse it. For East, think siblings, parallel roles. For West, think antonyms, counter-roles. Question, Level seven: Does it matter what semantic pairs I choose? Answer: Yes! They must match the operator concept. The system validates this. But within valid pairs, your choice is what matters. The cognitive load comes from generating and remembering your specific choices across n-back trials. Question, Level seven: Do I have to remember my semantic pairs from previous trials? Answer: Yes! That is the entire point. When evaluating n-back matches, you should recall what you anchored n trials ago. This generative working memory demand is what creates maximum g-load. Question, Level seven: Can I write down my semantic pairs? Answer: The system displays them with each premise, so you will see them. But for maximum training effect, try to recall them from memory first, then verify with the display.'
            },
            {
                id: 'glossary',
                title: 'Glossary',
                html: `
                    <h3>Glossary</h3>
                    <ul>
                        <li><strong>Arc of Abstraction:</strong> the mental continuum from concrete/particular to abstract/general.</li>
                        <li><strong>Up-shift / Down-shift:</strong> moves along the Arc (North/South).</li>
                        <li><strong>Analogue / Opposite:</strong> lateral moves preserving or inverting role (East/West).</li>
                        <li><strong>Anchor:</strong> your chosen seed concept for a letter.</li>
                        <li><strong>Compound mapping:</strong> a single letter carrying a composed phrase to satisfy multiple relations (e.g., "chaotic example").</li>
                        <li><strong>Reframe:</strong> deliberate change to an anchored concept, logged for consistency tracking.</li>
                        <li><strong>META_RELATIONAL premise (Level 6):</strong> a pure operator analogy comparing relationships between operators (e.g., "North to South as East to West"). No letters, only compass directions.</li>
                        <li><strong>Truth value:</strong> whether a META premise evaluates to True or False. True if both operator pairs deduce to the same relationship (or both orthogonal). False otherwise.</li>
                        <li><strong>Orthogonal relationship:</strong> when two operators have no clear relationship (neither same concept nor opposite). Example: Up-shift (North) to Analogue (East) = orthogonal.</li>
                        <li><strong>Deduced operator:</strong> the hidden relationship between two operators. North‚ÜíSouth (Up-shift‚ÜíDown-shift) deduces to West (Opposite).</li>
                        <li><strong>Semantic anchoring:</strong> a mental strategy where you anchor abstract letters to concrete concepts from your lived experience, then apply directional transformations. Example: J := "Fact", North(J‚ÜíN) = "Fact"‚Üí"Theory".</li>
                        <li><strong>Arc of Abstraction:</strong> the spectrum from concrete lived experience to abstract concepts. Semantic anchoring uses this arc to make abstract premises meaningful.</li>
                        <li><strong>Mental transformation:</strong> applying directional operators to your semantic anchors in your head. Example: South("Theory") = down-shift ‚Üí "Example".</li>
                        <li><strong>Compound operator (Level 7):</strong> a 2-operator sequence from 4 directions (N, S, E, W), creating 12 possible compounds (e.g., "north-west", "south-east"). Used in premises like "north-west is north of south-east".</li>
                    </ul>
                `,
                speech: 'Glossary. Arc of Abstraction: the mental continuum from concrete or particular to abstract or general. Up-shift and Down-shift: moves along the arc, north and south. Analogue and Opposite: lateral moves preserving or inverting role, east and west. Anchor: your chosen seed concept for a letter. Compound mapping: a single letter carrying a composed phrase to satisfy multiple relations, for example Chaotic example. Reframe: deliberate change to an anchored concept, logged for consistency tracking. META RELATIONAL premise, Level six: a pure operator analogy comparing relationships between operators, for example North to South as East to West. No letters, only compass directions. Truth value: whether a META premise evaluates to true or false. True if both operator pairs deduce to the same relationship, or both orthogonal. False otherwise. Orthogonal relationship: when two operators have no clear relationship, neither same concept nor opposite. Example: Up-shift North to Analogue East equals orthogonal. Deduced operator: the hidden relationship between two operators. North to South, Up-shift to Down-shift, deduces to West, Opposite. User semantics, Level seven: your own imagination-generated semantic pairs anchoring META operators to concrete concepts, for example North to South equals Teacher to Student. Generative anchoring: creating semantic pairs from imagination rather than selecting from provided options. Maximizes cognitive load. Semantic validation: checking that your generated semantic pair matches the operator concept, for example Teacher to Student must match North Up-shift concept.'
            },
            {
                id: 'level2-dialectical',
                title: 'Level 2: Dialectical Superposition',
                html: `
                    <h3>Level 2: Dialectical Superposition (Parallel Constraint Satisfaction)</h3>

                    <p><strong>Cognitive Goal:</strong> Parallel processing capacity - holding two orthogonal relationships simultaneously.</p>

                    <p><strong>Topology:</strong> 1 Node (shared Head and Tail), 2 Vectors (orthogonal axes)</p>

                    <p><strong>What You'll See:</strong></p>
                    <p class="premise-display" style="text-align: center; font-size: 1.2rem; color: #3498db; margin: 20px 0;">"A is north and west of B"</p>

                    <p><strong>What This Means:</strong></p>
                    <ul>
                        <li>Point A relates to point B via TWO axes at once</li>
                        <li>The axes are orthogonal (perpendicular): North + West, North + East, South + West, or South + East</li>
                        <li>This is NOT "A is north of B AND A is west of B" (two separate statements)</li>
                        <li>It's a single relationship with dual constraints: both must be true simultaneously</li>
                    </ul>

                    <p><strong>Why This Is Hard:</strong></p>
                    <p>Your brain must process two spatial dimensions in parallel without mixing them up. This trains the capacity for superposition - holding multiple properties of a single relationship simultaneously.</p>

                    <p><strong>Cross-Domain Example:</strong></p>
                    <p>"Evolutionary pressure is both a generalization of (North) AND an analogue to (West) market forces"</p>
                    <ul>
                        <li><strong>North (Generalization):</strong> Market forces are a specific instance of evolutionary pressure</li>
                        <li><strong>West (Analogue):</strong> Market forces and evolutionary pressure operate via similar mechanisms (selection, competition, adaptation)</li>
                        <li><strong>Domains traversed:</strong> Biology ‚Üí Economics ‚Üí Abstract causation ‚Üí Systems theory (4 domains)</li>
                    </ul>

                    <p><strong>Training Strategy:</strong></p>
                    <p>For each premise, ground BOTH axes in concrete examples. Don't just say "A is north and west of B" - force yourself to articulate what the North relationship means AND what the West relationship means independently, then verify they're compatible.</p>

                    <p><strong>How to Enable:</strong></p>
                    <p>Select <strong>Level 2: Dialectical Superposition</strong> from the Topology Mode dropdown in the controls panel. The k-slider will automatically lock to k=2 (two atoms per premise).</p>
                `,
                speech: 'Level two introduces dialectical superposition, where you hold two orthogonal relationships simultaneously. When you hear A is north and west of B, this means point A relates to point B via two perpendicular axes at the same time. This is not two separate statements, but a single relationship with dual constraints. Both must be true together. This trains your capacity for parallel processing and superposition, which is critical for holding multiple properties of complex systems in working memory. To practice effectively, ground each axis in a concrete example from different domains, then verify the two relationships are compatible. Select Level two Dialectical Superposition from the Topology Mode dropdown to enable this mode. The k-slider will automatically lock to k equals two.'
            },
            {
                id: 'level3-tensor',
                title: 'Level 3: Semantic Tensor',
                html: `
                    <h3>Level 3: Semantic Tensor (Cross-Domain Intersection)</h3>

                    <p><strong>Cognitive Goal:</strong> Cross-Domain Intersection - solving A = f(B) ‚à© g(C) where f and g are different transformations.</p>

                    <p><strong>Topology:</strong> 3 Nodes (one head A, two tails B and C), 2 Vectors (orthogonal axes)</p>

                    <p><strong>What You'll See:</strong></p>
                    <p class="premise-display" style="text-align: center; font-size: 1.2rem; color: #3498db; margin: 20px 0;">"A is north of B and east of C"</p>

                    <p><strong>What This Means:</strong></p>
                    <ul>
                        <li>One head (A) is the intersection of TWO transformations from different sources</li>
                        <li>A = f(B) ‚à© g(C) where f and g are orthogonal operations</li>
                        <li>Example: A is "north of B" (generalization from B) AND "east of C" (analogue from C)</li>
                        <li>This is tensor reasoning: A exists at the cross-product of two independent vector spaces</li>
                    </ul>

                    <p><strong>Why This Is Hard:</strong></p>
                    <p>Your brain must maintain simultaneous bindings from two orthogonal transformations converging on a single point. Unlike Level 2 (superposition of axes on one relationship), this is synthesis from multiple sources via different operations. You're solving for the intersection point.</p>

                    <p><strong>Cross-Domain Example:</strong></p>
                    <p>"Evolutionary algorithms (A) are a generalization of natural selection (B) AND an analogue to machine learning (C)"</p>
                    <ul>
                        <li><strong>North (B‚ÜíA):</strong> Natural selection (biological) ‚Üí Evolutionary algorithms (abstract computational framework)</li>
                        <li><strong>East (C‚ÜíA):</strong> Machine learning (statistical) ‚Üí Evolutionary algorithms (alternative optimization paradigm)</li>
                        <li><strong>Orthogonal axes:</strong> Vertical abstraction (biology‚Üícomputation) AND lateral analogy (statistics‚Üíoptimization)</li>
                        <li><strong>Domains traversed:</strong> Biology ‚Üí Computer Science ‚Üí Optimization Theory ‚Üí Statistics ‚Üí Abstract Computation (5 domains)</li>
                    </ul>

                    <p><strong>Training Strategy:</strong></p>
                    <p>For each premise, identify BOTH transformations independently. Ask: "What operation takes B to A?" (e.g., generalization). Then: "What operation takes C to A?" (e.g., lateral analogy). Verify the two operations are orthogonal (perpendicular, not the same axis). A is where these two transformations meet.</p>

                    <p><strong>How to Enable:</strong></p>
                    <p>Select <strong>Level 3: Semantic Tensor</strong> from the Topology Mode dropdown in the controls panel. The k-slider will automatically lock to k=2 (two atoms per premise).</p>
                `,
                speech: 'Level three introduces semantic tensor reasoning, where one head is the intersection of two orthogonal transformations from different sources. When you hear A is north of B and east of C, this means A equals f of B intersected with g of C, where f and g are different operations. For example, A is a generalization from B via the north axis, AND an analogue from C via the east axis. This is tensor reasoning: A exists at the cross-product of two independent vector spaces. You must hold two different transformations in mind simultaneously and identify the single point where they converge. To practice effectively, identify both transformations independently, verify they are orthogonal, then explain how A satisfies both conditions at once. Select Level three Semantic Tensor from the Topology Mode dropdown to enable this mode. The k-slider will automatically lock to k equals two.'
            },
            {
                id: 'level4-homology',
                title: 'Level 4: System Homology',
                html: `
                    <h3>Level 4: System Homology (Second-Order Isomorphism)</h3>

                    <p><strong>Cognitive Goal:</strong> Second-Order Isomorphism - comparing structural dynamics of two domains.</p>

                    <p><strong>Topology:</strong> 4-node graph with 2 visible anchors (A, B), 2 hidden derivatives (X, Y)</p>

                    <p><strong>What You'll See:</strong></p>
                    <p class="premise-display" style="text-align: center; font-size: 1.2rem; color: #3498db; margin: 20px 0;">"(north of A) is east of (north of B)"</p>

                    <p><strong>What This Means:</strong></p>
                    <ul>
                        <li>There are TWO HIDDEN NODES (let's call them X and Y) that aren't shown in the text</li>
                        <li><strong>X</strong> is the thing that is "north of A"</li>
                        <li><strong>Y</strong> is the thing that is "north of B" (NOTE: SAME transformation "north")</li>
                        <li>The premise states: <strong>X is east of Y</strong></li>
                        <li>You must mentally construct X and Y from the visible anchors (A and B)</li>
                    </ul>

                    <p><strong>Key Insight:</strong> When you see "(north of A) is east of (north of B)", the fact that BOTH use "north" reveals they undergo the SAME transformation. You're comparing how two different domains (A and B) respond to identical operations. This is meta-structural equivalence.</p>

                    <p><strong>Internal Graph Structure:</strong></p>
                    <ul>
                        <li>Atom 1: X ‚Üí A (X is north of A)</li>
                        <li>Atom 2: Y ‚Üí B (Y is north of B) ‚Üê SAME axis as X‚ÜíA</li>
                        <li>Atom 3: X ‚Üí Y (X is east of Y) ‚Üê Relationship between derivatives</li>
                    </ul>

                    <p><strong>Why This Is Hard:</strong></p>
                    <p>Your brain must track FOUR nodes (A, B, X, Y) but only TWO are explicitly named. Beyond algebraic variable solving, you're detecting meta-patterns: do A and B transform the same way? This is second-order pattern recognition - not just "what is the pattern?" but "do these two systems share the same transformation dynamics?"</p>

                    <p><strong>Cross-Domain Example:</strong></p>
                    <p>"(Generalization of quantum entanglement) is analogous to (Generalization of consciousness binding problem)"</p>
                    <ul>
                        <li><strong>A:</strong> Quantum entanglement (Physics)</li>
                        <li><strong>X:</strong> "Non-local correlation" (Generalization of A)</li>
                        <li><strong>B:</strong> Consciousness binding problem (Neuroscience)</li>
                        <li><strong>Y:</strong> "Distributed integration" (Generalization of B - SAME operation "generalize")</li>
                        <li><strong>Relationship:</strong> X is analogous to Y (both are abstractions operating at the same level)</li>
                        <li><strong>Meta-insight:</strong> Physics and Neuroscience undergo IDENTICAL abstraction patterns when generalized</li>
                        <li><strong>Domains traversed:</strong> Quantum Physics ‚Üí Abstract Correlation ‚Üí Neuroscience ‚Üí Systems Integration ‚Üí Meta-Theory ‚Üí Information Theory (6-8 domains)</li>
                    </ul>

                    <p><strong>Training Strategy:</strong></p>
                    <p>For each premise, explicitly name the hidden nodes. Then ask: "Did I apply the SAME transformation to both A and B?" If yes, you're witnessing system homology - structural equivalence across domains. Write down: "Let X = north of A = [example]. Let Y = north of B = [example]. Both use 'north', so A and B transform identically. Therefore X is east of Y means [their derivatives are analogous]."</p>

                    <p><strong>How to Enable:</strong></p>
                    <p>Select <strong>Level 4: System Homology</strong> from the Topology Mode dropdown in the controls panel. The k-slider will automatically lock to k=3 (three atoms per premise).</p>
                `,
                speech: 'Level four introduces system homology, where you compare structural dynamics across domains. When you hear north of A is east of north of B, note that both use north, the same transformation. There are two hidden nodes X and Y. X is whatever is north of A. Y is whatever is north of B. The fact that both use the same operator north reveals that A and B undergo identical transformations. You are detecting meta-structural equivalence: do these two systems respond the same way to the same operation? This is second-order pattern recognition. You must construct the hidden nodes, verify they use the same transformation, then evaluate the relationship between the derivatives. To practice effectively, explicitly name the hidden nodes, confirm they use the same axis, construct concrete examples for each, then explain how the cross-domain relationship reveals structural equivalence. Select Level four System Homology from the Topology Mode dropdown to enable this mode. The k-slider will automatically lock to k equals three.'
            },
            {
                id: 'level5-interface',
                title: 'Level 5: Complementary Interface',
                html: `
                    <h3>Level 5: Complementary Interface (Heterogeneous Integration)</h3>

                    <p><strong>Cognitive Goal:</strong> Functional fit assessment - do two divergent complex processes interface compatibly?</p>

                    <p><strong>Topology:</strong> 6 nodes, 2 asymmetric paths, 1 interface point</p>

                    <p><strong>What You'll See:</strong></p>
                    <p class="premise-display">"(North-West of A) is West of (South-East of B)"</p>

                    <p><strong>What This Means:</strong></p>
                    <ul>
                        <li>There are TWO COMPLEX PATHS with different transformations</li>
                        <li><strong>Path A:</strong> A ‚Üí (North) ‚Üí I‚ÇÅ ‚Üí (West) ‚Üí E‚ÇÅ</li>
                        <li><strong>Path B:</strong> B ‚Üí (South) ‚Üí I‚ÇÇ ‚Üí (East) ‚Üí E‚ÇÇ</li>
                        <li><strong>Interface:</strong> E‚ÇÅ relates to E‚ÇÇ (endpoints connect)</li>
                        <li>This tests whether divergent processes produce compatible outputs</li>
                    </ul>

                    <p><strong>Why This Is Hard:</strong></p>
                    <p>You're tracking 6 nodes (2 roots, 2 intermediates, 2 endpoints) and determining if two multi-step transformations produce compatible results. This is heterogeneous integration: systems that operate via different principles but must interface functionally.</p>

                    <p><strong>Cross-Domain Example:</strong></p>
                    <p>"(Generalization-then-Analogue of Quantum Computing) interfaces with (Specialization-then-Analogue of Neural Networks)"</p>
                    <ul>
                        <li><strong>Root A:</strong> Quantum Computing (domain 1)</li>
                        <li><strong>Path A:</strong> Generalize to "Parallel Superposition" ‚Üí Shift Analogue to "Distributed Processing"</li>
                        <li><strong>Endpoint E‚ÇÅ:</strong> "Distributed Processing" (quantum perspective)</li>
                        <li><strong>Root B:</strong> Neural Networks (domain 2)</li>
                        <li><strong>Path B:</strong> Specialize to "Gradient Descent" ‚Üí Shift Analogue to "Optimization Search"</li>
                        <li><strong>Endpoint E‚ÇÇ:</strong> "Optimization Search" (neural perspective)</li>
                        <li><strong>Interface Question:</strong> Does "Distributed Processing" (quantum) functionally connect with "Optimization Search" (neural)?</li>
                        <li><strong>Answer:</strong> YES - both endpoints describe search strategies in high-dimensional spaces. Hybrid quantum-neural architectures are viable.</li>
                    </ul>

                    <p><strong>Training Strategy:</strong></p>
                    <p>For each premise, trace both paths separately, identify the endpoints, then evaluate interface compatibility. Ask: "Do these endpoints speak the same language / serve compatible functions / produce interoperable outputs?"</p>

                    <p><strong>How to Enable:</strong></p>
                    <p>Select <strong>Level 5: Complementary Interface</strong> from the Topology Mode dropdown in the controls panel. The k-slider will automatically lock to k=5 (five atoms per premise).</p>
                `,
                speech: 'Level five introduces complementary interface reasoning, where you assess whether two divergent complex processes produce compatible outputs. When you hear north-west of A is west of south-east of B, there are two multi-step paths. Path A transforms A via north then west, producing endpoint E one. Path B transforms B via south then east, producing endpoint E two. The premise states that E one relates to E two via the interface axis. You must determine if these endpoints are functionally compatible despite originating from different transformation sequences. This trains heterogeneous integration capacity: the ability to determine if systems operating via different principles can interface successfully. This is critical for cross-disciplinary synthesis, technology integration, and systems design. Select Level five Complementary Interface from the Topology Mode dropdown to enable this mode. The k-slider will automatically lock to k equals five.'
            },
            {
                id: 'level6',
                title: 'Level 6: Meta-Relational Analogy',
                html: `
                    <h3>Level 6: Meta-Relational Analogy (The 'g' Leap)</h3>
                    <p>This is <strong>peak fluid intelligence training</strong>. Level 6 introduces a completely new premise type: <strong>pure operator analogies</strong>.</p>

                    <h4>What You'll See</h4>
                    <p>Instead of letter-based premises like "A is north of B", you'll see:</p>
                    <p style="text-align: center; font-size: 1.2rem; color: #3498db; margin: 20px 0;"><code>"North to South as East to West"</code></p>
                    <p>No letters. Just operators. This is a <strong>6th-order relational statement</strong>‚Äîan analogy of relations.</p>

                    <h4>How to Evaluate</h4>
                    <ol>
                        <li><strong>Map operators to concepts:</strong>
                            <ul>
                                <li>North = Up-shift</li>
                                <li>South = Down-shift</li>
                                <li>East = Analogue</li>
                                <li>West = Opposite</li>
                            </ul>
                        </li>
                        <li><strong>Deduce the relationship for each pair:</strong>
                            <ul>
                                <li>"North to South" = Up-shift ‚Üí Down-shift = <strong>Opposite (West)</strong></li>
                                <li>"East to West" = Analogue ‚Üí Opposite = <strong>Opposite (West)</strong></li>
                            </ul>
                        </li>
                        <li><strong>Compare the deduced operators:</strong>
                            <ul>
                                <li>West = West ‚Üí Premise is <strong>TRUE</strong></li>
                            </ul>
                        </li>
                    </ol>

                    <h4>Deduction Rules</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 10px; border: 1px solid #555;">From ‚Üí To</th>
                            <th style="padding: 10px; border: 1px solid #555;">Deduced Operator</th>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Up-shift ‚Üí Down-shift (N‚ÜíS)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Down-shift ‚Üí Up-shift (S‚ÜíN)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Analogue ‚Üí Opposite (E‚ÜíW)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Opposite ‚Üí Analogue (W‚ÜíE)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>West</strong> (Opposite)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Up-shift ‚Üí Up-shift (N‚ÜíN)</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>East</strong> (Analogue)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Any same ‚Üí same</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>East</strong> (Analogue)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid #555;">Up/Down ‚Üí Analogue/Opposite</td>
                            <td style="padding: 10px; border: 1px solid #555;"><strong>None</strong> (Orthogonal)</td>
                        </tr>
                    </table>

                    <h4>N-Back Matching</h4>
                    <p>Matches are based on <strong>truth value</strong>, not operators:</p>
                    <ul>
                        <li><strong>MATCH:</strong> Both TRUE or both FALSE</li>
                        <li><strong>NO MATCH:</strong> One TRUE, one FALSE</li>
                    </ul>

                    <h4>Practice Examples</h4>
                    <p><strong>Example 1:</strong> <code>North to East as South to West</code></p>
                    <ul>
                        <li>N‚ÜíE: Up-shift ‚Üí Analogue = <strong>None</strong> (orthogonal)</li>
                        <li>S‚ÜíW: Down-shift ‚Üí Opposite = <strong>None</strong> (orthogonal)</li>
                        <li>None = None ‚Üí <strong>TRUE</strong></li>
                    </ul>

                    <p><strong>Example 2:</strong> <code>North to South as North to East</code></p>
                    <ul>
                        <li>N‚ÜíS: Up-shift ‚Üí Down-shift = <strong>West</strong></li>
                        <li>N‚ÜíE: Up-shift ‚Üí Analogue = <strong>None</strong></li>
                        <li>West ‚â† None ‚Üí <strong>FALSE</strong></li>
                    </ul>

                    <p><strong>Example 3:</strong> <code>East to East as West to West</code></p>
                    <ul>
                        <li>E‚ÜíE: Analogue ‚Üí Analogue = <strong>East</strong></li>
                        <li>W‚ÜíW: Opposite ‚Üí Opposite = <strong>East</strong></li>
                        <li>East = East ‚Üí <strong>TRUE</strong></li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Select <strong>Level 6 (Meta-Relational - g-Leap)</strong> from the Logic Level dropdown in the controls panel before starting a session. <em>Note: This is the OLD Level 6, which has been replaced by the NEW Level 6 (Algebraic). This tutorial section is preserved for historical reference.</em></p>
                `,
                speech: 'Level Six: Meta-Relational Analogy, The g-Leap. This is the OLD Level six, which has been replaced by the NEW Level six Algebraic with hidden nodes. This tutorial section is preserved for historical reference. The OLD Level six introduced a completely new premise type: pure operator analogies. What You Will See: Instead of letter-based premises like A is north of B, you will see North to South as East to West. No letters, just operators. This is a sixth-order relational statement, an analogy of relations. How to Evaluate: Step one, Map operators to concepts. North equals Up-shift. South equals Down-shift. East equals Analogue. West equals Opposite. Step two, Deduce the relationship for each pair. North to South equals Up-shift to Down-shift equals Opposite, West. East to West equals Analogue to Opposite equals Opposite, West. Step three, Compare the deduced operators. West equals West, so the premise is TRUE. Deduction Rules: Up-shift to Down-shift, North to South, deduces to West, Opposite. Down-shift to Up-shift, South to North, deduces to West, Opposite. Analogue to Opposite, East to West, deduces to West, Opposite. Opposite to Analogue, West to East, deduces to West, Opposite. Any same to same deduces to East, Analogue. Up or Down to Analogue or Opposite deduces to None, Orthogonal. N-Back Matching: Matches are based on truth value, not operators. MATCH when both TRUE or both FALSE. NO MATCH when one TRUE and one FALSE.'
            },
            {
                id: 'level7',
                title: 'Level 7: Compound Operator Relational',
                html: `
                    <h3>Level 7: Compound Operator Relational (Maximum g-Load)</h3>
                    <p>This is the <strong>ultimate cognitive challenge</strong>‚Äîcombining abstract operator sequences, semantic anchoring, meta-relational reasoning, and working memory into a single unified task. Level 7 achieves <strong>7th-order reasoning</strong>.</p>

                    <h4>The Concept</h4>
                    <p>Level 7 premises look like this: <code>"north-west is north of south-east"</code></p>
                    <p>This combines:</p>
                    <ul>
                        <li><strong>Compound operators:</strong> "north-west" is a sequence of transformations (north, then west)</li>
                        <li><strong>Meta-relationships:</strong> The compound operators themselves are related by a meta-operator (north)</li>
                        <li><strong>Semantic anchoring:</strong> You mentally anchor and transform concepts through the sequences</li>
                        <li><strong>Abstract pairing:</strong> The two compound operators form a unified relational structure</li>
                    </ul>

                    <h4>How It Works (Purely Mental)</h4>
                    <p><strong>Example: "north-west is north of south-east"</strong></p>
                    <ol>
                        <li><strong>Pick a seed concept for left side:</strong> "Order"</li>
                        <li><strong>Apply north-west transformation:</strong>
                            <ul>
                                <li>North(Order) = up-shift ‚Üí "System" (generalization)</li>
                                <li>West(System) = opposite ‚Üí "Chaos" (counterpart)</li>
                                <li><strong>Result:</strong> north-west := "Chaos"</li>
                            </ul>
                        </li>
                        <li><strong>Pick a seed concept for right side:</strong> "Calm"</li>
                        <li><strong>Apply south-east transformation:</strong>
                            <ul>
                                <li>South(Calm) = down-shift ‚Üí "Stillness" (concrete instance)</li>
                                <li>East(Stillness) = analogue ‚Üí "Peace" (sibling concept)</li>
                                <li><strong>Result:</strong> south-east := "Peace"</li>
                            </ul>
                        </li>
                        <li><strong>Evaluate meta-relationship:</strong>
                            <ul>
                                <li>Is "Chaos" north of "Peace"?</li>
                                <li>Is Chaos a generalization of Peace?</li>
                                <li><strong>Your judgment:</strong> Perhaps... Chaos is a broader state that can contain peaceful moments?</li>
                            </ul>
                        </li>
                        <li><strong>Decide: MATCH or NO MATCH</strong> (based on your semantic model)</li>
                    </ol>

                    <h4>The 7th-Order Reasoning</h4>
                    <p>This achieves 7 layers of abstraction:</p>
                    <ol>
                        <li><strong>1st-order:</strong> Concrete concepts (Order, Calm, Chaos, Peace)</li>
                        <li><strong>2nd-order:</strong> Basic transformations (north = up-shift, west = opposite)</li>
                        <li><strong>3rd-order:</strong> Sequential composition (north-west = up-shift then opposite)</li>
                        <li><strong>4th-order:</strong> Compound transformations as entities (north-west becomes "Chaos")</li>
                        <li><strong>5th-order:</strong> Meta-relationships between entities (Chaos is north of Peace)</li>
                        <li><strong>6th-order:</strong> Abstract pairing (north-west and south-east form unified structure)</li>
                        <li><strong>7th-order:</strong> Self-generated semantic evaluation across n-back trials</li>
                    </ol>

                    <h4>k Parameter Controls Complexity</h4>
                    <p>The k slider controls <strong>number of compound atoms per premise</strong> (just like in atomic mode):</p>
                    <ul>
                        <li><strong>k=1:</strong> Single compound atom (e.g., "north-west is south of east-north")</li>
                        <li><strong>k=2:</strong> Two compound atoms (e.g., "north-west is south of east-north; north-west is east of south-west")</li>
                        <li><strong>k=3:</strong> Three compound atoms</li>
                        <li><strong>k=4:</strong> Four compound atoms</li>
                    </ul>
                    <p>Note: Compound operators are <strong>always 2 operators</strong> (like "north-west"). Higher k creates multi-atom premises where compound operators appear in multiple relationships.</p>

                    <h4>N-Back Matching</h4>
                    <p>Because there's no formal truth value (evaluation is semantic), matching works differently:</p>
                    <ul>
                        <li>You make a judgment: MATCH or NO MATCH (based on your mental model)</li>
                        <li>System tracks YOUR judgment</li>
                        <li>N trials later, you must <strong>recall YOUR previous judgment</strong></li>
                        <li>If current and n-back both MATCH ‚Üí correct response is MATCH</li>
                        <li>If both NO MATCH ‚Üí correct response is MATCH</li>
                        <li>If one MATCH and one NO MATCH ‚Üí correct response is NO MATCH</li>
                    </ul>

                    <h4>Why This is Maximum g-Load</h4>
                    <p>Level 7 combines ALL cognitive demands simultaneously:</p>
                    <ol>
                        <li><strong>Sequential transformation:</strong> Apply 2-4 operators in sequence</li>
                        <li><strong>Semantic anchoring:</strong> Generate mental concepts for seeds</li>
                        <li><strong>Working memory:</strong> Maintain transformation state across steps</li>
                        <li><strong>Meta-reasoning:</strong> Evaluate relationships between compound results</li>
                        <li><strong>Abstract pairing:</strong> Unified relational structure (not separate examples)</li>
                        <li><strong>Subjective judgment:</strong> No formal answer‚Äîtrust your mental model</li>
                        <li><strong>N-back recall:</strong> Remember YOUR judgments across trials</li>
                    </ol>

                    <h4>Tips for Success</h4>
                    <ul>
                        <li><strong>Visualize the transformations:</strong> Actually imagine each step (Order‚ÜíSystem‚ÜíChaos)</li>
                        <li><strong>Use vivid seeds:</strong> Pick concrete concepts you can mentally manipulate</li>
                        <li><strong>Trust your intuition:</strong> There's no "correct" answer‚Äîyour semantic model is what matters</li>
                        <li><strong>Be consistent:</strong> Use similar seed types to maintain coherence</li>
                        <li><strong>Track your pattern:</strong> Notice if you tend to say MATCH or NO MATCH more often</li>
                    </ul>

                    <h4>How to Enable</h4>
                    <p>Select <strong>Level 7 (Compound Operators)</strong> from the Logic Level dropdown in the controls panel before starting a session.</p>

                    <p><strong>Recommended settings for maximum challenge:</strong> n=5, k=4 (5-back with 4 compound atoms per premise)</p>
                `,
                speech: 'Level Seven: Compound Operator Relational, Maximum g-Load. This is the ultimate cognitive challenge, combining abstract operator sequences, semantic anchoring, meta-relational reasoning, and working memory into a single unified task. Level seven achieves seventh-order reasoning. The Concept: Level seven premises look like this: north-west is north of south-east. This combines compound operators like north-west which is a sequence of exactly two transformations, meta-relationships where compound operators are related by a meta-operator, semantic anchoring where you mentally anchor and transform concepts through sequences, and abstract pairing where the two compound operators form a unified relational structure. How It Works, Purely Mental: Example: north-west is north of south-east. Step one, Pick a seed concept for left side: Order. Step two, Apply north-west transformation: North of Order equals up-shift to System. West of System equals opposite to Chaos. Result: north-west equals Chaos. Step three, Pick a seed concept for right side: Calm. Step four, Apply south-east transformation: South of Calm equals down-shift to Stillness. East of Stillness equals analogue to Peace. Result: south-east equals Peace. Step five, Evaluate meta-relationship: Is Chaos north of Peace? Is Chaos a generalization of Peace? Your judgment decides. Step six, Decide: MATCH or NO MATCH based on your semantic model. Why This is Maximum g-Load: Level seven combines all cognitive demands simultaneously. Sequential transformation: apply two operators in sequence for each compound. Semantic anchoring: generate mental concepts for seeds. Working memory: maintain transformation state across steps. Meta-reasoning: evaluate relationships between compound results. Abstract pairing: unified relational structure, not separate examples. Subjective judgment: no formal answer, trust your mental model. N-back recall: remember your judgments across trials. How to Enable: Select Level seven Compound Operators from the Logic Level dropdown in the controls panel before starting a session. Recommended settings for maximum challenge: n equals five, k equals four, five-back with four compound atoms per premise.'
            },
            {
                id: 'davinci-method',
                title: 'Da Vinci does Imagi-World',
                html: `
                    <h3>Da Vinci does Imagi-World</h3>

                    <p>Leonardo da Vinci's genius was not handling complexity‚Äîit was <strong>seeing connections across domains</strong>. This tutorial teaches you to apply his cross-domain synthesis method to <strong>every level</strong> of Imagi-World, from Level 1 to Level 9.</p>

                    <h4>The Core Principle: Cross-Domain Transformation</h4>
                    <p>Da Vinci didn't just study birds‚Äîhe studied birds to design flying machines. He didn't just paint‚Äîhe studied optics to perfect sfumato. <strong>Every transformation crossed domains.</strong></p>

                    <p><strong>You can do this at ANY level:</strong></p>
                    <ul>
                        <li><strong>Level 1:</strong> Single atoms ‚Üí 2-3 domain jumps</li>
                        <li><strong>Level 3:</strong> Chains ‚Üí 4-5 domain jumps</li>
                        <li><strong>Level 6:</strong> Meta-relational ‚Üí 6-8 domain jumps</li>
                        <li><strong>Level 9:</strong> Triple compounds ‚Üí 8-12 domain jumps</li>
                    </ul>

                    <h4>Level 1: Da Vinci Solves "X is north of Y"</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Example 1:</strong> Y := "Bird wing feather" (Ornithology) ‚Üí North ‚Üí X := "Mechanical pen nib" (Engineering/Writing Instruments)</p>
                        <p style="margin-left: 20px; color: #aaa;">Da Vinci's connection: In Codex Atlanticus, da Vinci sketched bird feathers alongside pen designs, recognizing that both use flexible vanes/tines to control flow‚Äîair for feathers, ink for nibs. The generalization is "flexible flow control mechanisms." Domain jump: Ornithology ‚Üí Engineering. Total: <strong>2 radically different domains</strong>.</p>

                        <p style="margin-top: 16px;"><strong>Example 2:</strong> Y := "Water mill wheel" (Hydraulic Engineering) ‚Üí South ‚Üí X := "Human heart valve" (Cardiovascular Anatomy)</p>
                        <p style="margin-left: 20px; color: #aaa;">Da Vinci's connection: Da Vinci's anatomical drawings (c. 1513) show heart valves modeled after mill wheel mechanics‚Äîboth prevent backflow through rhythmic opening/closing. The specification is "one-way flow gate." Domain jump: Hydraulic Engineering ‚Üí Medicine. Total: <strong>2 completely different domains</strong>.</p>

                        <p style="margin-top: 16px; color: #8b00ff;"><strong>Level 1 domain count: 4 unique fields traversed in simple premises‚Äîbut now with TRUE cross-domain leaps, not subdomain drift.</strong></p>
                    </div>

                    <h4>Level 2: Da Vinci Solves "X is north of Y is east of Z"</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Cross-domain chain:</strong> Z := "Snail shell spiral" (Malacology/Biology) ‚Üí North ‚Üí Y := "Golden ratio mathematics" (Geometry) ‚Üí East ‚Üí X := "Cathedral dome architecture" (Civil Engineering/Architecture)</p>
                        <p style="margin-left: 20px; color: #aaa;">Da Vinci's connection: Da Vinci measured snail shells, extracted the œÜ (phi) ratio, and applied it to architectural proportions in his church designs. Three radically different domains crossed in one chain: Biology ‚Üí Mathematics ‚Üí Architecture. Total: <strong>3 completely different domains</strong>.</p>

                        <p style="margin-top: 16px;"><strong>Historical note:</strong> Da Vinci's notebooks (Codex Madrid II) contain sketches of nautilus shells with geometric overlays, demonstrating his recognition that biological growth patterns encode universal mathematical proportions applicable to human architecture.</p>
                    </div>

                    <h4>Level 3: Da Vinci Solves Multi-Atom Chains</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Four-concept cross-domain chain:</strong></p>
                        <p>A := "Eagle embryo wing bud" (Embryology) ‚Üí North ‚Üí B := "Hydraulic piston expansion" (Mechanical Engineering) ‚Üí East ‚Üí C := "Organ pipe bellows" (Music/Acoustics) ‚Üí South ‚Üí D := "Respiratory diaphragm" (Human Anatomy)</p>
                        <p style="margin-left: 20px; color: #aaa;">
                            1. Wing bud ‚Üí Hydraulic piston (biological tissue growth generalized to mechanical expansion principle)<br>
                            2. Hydraulic piston ‚Üí Organ bellows (mechanical analogue: both are pressure-driven expansion chambers)<br>
                            3. Organ bellows ‚Üí Diaphragm (musical instrument specified to its biological counterpart)<br>
                            Domain progression: Embryology ‚Üí Engineering ‚Üí Music ‚Üí Anatomy. Total: <strong>4 radically different domains</strong>.
                        </p>

                        <p style="margin-top: 16px; color: #2ecc71;"><strong>Da Vinci actually did this:</strong> His anatomical notebooks (Windsor Collection, c. 1510-1513) show embryonic development studies alongside hydraulic machines. He designed organ bellows for musical instruments while simultaneously dissecting human lungs. He recognized expansion/contraction as a universal principle across biology, engineering, music, and medicine.</p>
                    </div>

                    <h4>Level 6: Da Vinci Solves Meta-Relational "g-Leap"</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Premise:</strong> "West to North as South to East"</p>

                        <p><strong>Left pair (West to North):</strong></p>
                        <p style="margin-left: 20px;">West := "Marble block" (Geology/Materials) ‚Üí North := "Imprisoned sculpture" (Artistic Vision/Philosophy)<br>
                        <span style="color: #aaa;">Marble block is the physical opposite of revealed form (raw vs. finished). Sculpture is the abstract artistic vision (Michelangelo's concept: the statue exists within the stone, waiting to be freed). Transformation: Material opposition ‚Üí Generalized abstraction. Hidden operator: <strong>Opposite then generalize = West-to-North compound</strong>.</span></p>

                        <p style="margin-top: 12px;"><strong>Right pair (South to East):</strong></p>
                        <p style="margin-left: 20px;">South := "Water flow" (Fluid Dynamics/Physics) ‚Üí East := "Musical harmony propagation" (Acoustics/Music Theory)<br>
                        <span style="color: #aaa;">Water flow is the concrete physical manifestation of wave propagation. Musical harmony is its acoustic analogue (both involve rhythmic periodic motion through a medium). Transformation: Specify to material example ‚Üí Find sonic parallel. Hidden operator: <strong>Specify then find analogue = South-to-East compound</strong>.</span></p>

                        <p style="margin-top: 12px;"><strong>Meta-analysis:</strong> Does (West‚ÜíNorth) = (South‚ÜíEast)? <strong>NO.</strong> The premise is FALSE.</p>
                        <p style="margin-left: 20px; color: #aaa;">Domains traversed: Geology, Artistic Philosophy, Fluid Dynamics, Music Theory, Meta-Logic. Total: <strong>5 domains</strong> to evaluate one meta-relational premise. This is the "g-Leap"‚Äîgeneralizing about generalizations across radically different fields.</p>

                        <p style="margin-top: 16px;"><strong>Da Vinci's actual work:</strong> In his Treatise on Painting and Codex Leicester, da Vinci compared solid material transformation (sculpture from stone) to fluid dynamics (water shaping landscapes) to sound propagation (acoustic waves). He recognized these as parallel transformation patterns across art, physics, and music‚Äîthe exact meta-relational thinking Level 6 demands.</p>

                        <p style="margin-top: 16px; color: #8b00ff;"><strong>Level 6 demands 6-8 domain jumps</strong> when you semantically anchor both operator pairs and analyze their meta-relationship across radically different fields.</p>
                    </div>

                    <h4>Level 7: Da Vinci Solves Compound Operators</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Premise:</strong> "north-south is east of east-west"</p>

                        <p><strong>Left compound (north-south):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Telescope lens" (Optics/Astronomy)<br>
                            ‚Üí Apply North: "Human eye anatomy" (Vision Science/Physiology)<br>
                            ‚Üí Apply South: "Painting perspective technique" (Art/Renaissance Technique)<br>
                            Result: <strong>"Painting perspective technique"</strong> (3 domains: Optics ‚Üí Physiology ‚Üí Art)
                        </p>

                        <p style="margin-top: 12px;"><strong>Right compound (east-west):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Ship sail" (Maritime Engineering/Navigation)<br>
                            ‚Üí Apply East: "Bird wing" (Ornithology/Flight Mechanics)<br>
                            ‚Üí Apply West: "Wind pattern analysis" (Meteorology/Atmospheric Science)<br>
                            Result: <strong>"Wind pattern analysis"</strong> (3 domains: Maritime Engineering ‚Üí Ornithology ‚Üí Meteorology)
                        </p>

                        <p style="margin-top: 12px;"><strong>Meta-relation:</strong> Is "Painting perspective technique" east (analogue) of "Wind pattern analysis"?</p>
                        <p style="margin-left: 20px; color: #aaa;">YES‚ÄîDa Vinci's insight: Both are systems for mapping invisible forces onto visible surfaces. Perspective painting captures spatial depth (3D‚Üí2D optical projection). Wind analysis captures air currents (invisible flow‚Üívisible effects). Both translate hidden structure into perceivable form through geometric/observational methods.</p>

                        <p style="margin-top: 16px; color: #2ecc71;"><strong>Level 7 total: 6 domains</strong> (Optics, Physiology, Art, Maritime Engineering, Ornithology, Meteorology)</p>

                        <p style="margin-top: 12px;"><strong>Historical validation:</strong> Da Vinci's Treatise on Painting directly connects telescope optics to eye anatomy to develop perspective laws. His studies of bird flight (Codex on Flight) explicitly compare sail mechanics to wing aerodynamics. Both transformation chains appear in his actual notebooks.</p>
                    </div>

                    <h4>Level 8: Da Vinci Solves 8-Direction Diagonals</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Premise:</strong> "northeast-southwest is north of southeast-northwest"</p>

                        <p><strong>Left compound (northeast-southwest):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Violin string vibration" (Acoustics/Music Theory)<br>
                            ‚Üí Apply NE (elevated analogue): "Light wave propagation" (Optics/Physics)<br>
                            ‚Üí Apply SW (material opposite): "Marble quarry silence" (Geology/Architecture)<br>
                            Result: <strong>"Marble quarry silence"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Right compound (southeast-northwest):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed := "Flowing river current" (Hydrology/Fluid Dynamics)<br>
                            ‚Üí Apply SE (concrete analogue): "Blood vessel circulation" (Cardiovascular Medicine)<br>
                            ‚Üí Apply NW (abstract opposite): "Contemplative stillness meditation" (Philosophy/Contemplative Practice)<br>
                            Result: <strong>"Contemplative stillness meditation"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Meta-relation:</strong> Is "Marble quarry silence" north of "Contemplative stillness meditation"?</p>
                        <p style="margin-left: 20px; color: #aaa;">NO‚ÄîFALSE. Contemplative meditation is the generalized (abstract) form of intentional silence. Marble quarry is the material (concrete) instance of passive silence. The meditation is north of the quarry, not vice versa. The premise is FALSE‚Äîforcing you to recognize the abstraction hierarchy across these radically different domains.</p>

                        <p style="margin-top: 16px; color: #8b00ff;"><strong>Level 8 total: 7 domains</strong> (Acoustics, Optics, Geology, Hydrology, Medicine, Philosophy, Contemplative Practice). This is Renaissance-level synthesis.</p>

                        <p style="margin-top: 16px;"><strong>Historical note:</strong> Da Vinci studied violin string vibrations in Manuscript H (c. 1494), compared wave propagation across sound/light in his optics treatise, analyzed marble quarry stone selection for architecture (notes on Duomo di Milano), compared river flow to blood in Codex Leicester, and advocated meditative observation in his painting instructions. He explicitly connected acoustic waves to light waves to material properties to fluid dynamics to contemplative practice‚Äîall seven domains unified.</p>
                    </div>

                    <h4>Level 9: Da Vinci's Peak‚ÄîTriple-Nested Compounds</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Example from DaVinci_Does_9.md:</strong></p>
                        <p><strong>Premise:</strong> "SE-E-SW is northeast of E-NNE-SSW"</p>

                        <p><strong>Left compound (SE-E-SW):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed: "Bird wing" (Ornithology)<br>
                            ‚Üí SE: "Human arm anatomy" (Human Anatomy)<br>
                            ‚Üí E: "Mechanical lever" (Engineering)<br>
                            ‚Üí SW: "Hydraulic piston" (Hydraulic Engineering)<br>
                            <strong>Result: "Hydraulic piston"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Right compound (E-NNE-SSW):</strong></p>
                        <p style="margin-left: 20px;">
                            Seed: "Flowing river" (Hydrology)<br>
                            ‚Üí E: "Bloodstream" (Cardiovascular Anatomy)<br>
                            ‚Üí NNE: "Musical harmony propagation" (Music Theory/Acoustics)<br>
                            ‚Üí SSW: "Stone quarry silence" (Geology/Architecture)<br>
                            <strong>Result: "Stone quarry silence"</strong>
                        </p>

                        <p style="margin-top: 12px;"><strong>Meta-relation:</strong> Is "Hydraulic piston" northeast of "Stone quarry silence"?</p>
                        <p style="margin-left: 20px; color: #aaa;">
                            <strong>Da Vinci's analysis:</strong> Both represent states of potential energy. The piston contains pressurized water ready to release force (dynamic potential). The quarry contains stone ready to be shaped into architecture (material potential). The piston is the abstract elevated analogue‚Äîgeneralized potential (northeast = abstract + analogue). <strong>TRUE‚ÄîMATCH.</strong>
                        </p>

                        <p style="margin-top: 16px; color: #e67e22; font-weight: bold;">Level 9 total: 8 unique domains (Ornithology, Human Anatomy, Mechanical Engineering, Hydraulic Engineering, Hydrology, Cardiovascular Anatomy, Music Theory, Geology/Architecture)</p>

                        <p style="margin-top: 12px; color: #2ecc71;"><strong>Historical validation:</strong> Every transformation above appears in Leonardo's actual notebooks:</p>
                        <ul style="margin-left: 20px; color: #aaa; margin-top: 8px;">
                            <li>Bird wing ‚Üí Human arm: Codex on Flight of Birds (comparative anatomy)</li>
                            <li>Arm ‚Üí Lever: Codex Arundel (biomechanics)</li>
                            <li>Lever ‚Üí Hydraulic: Codex Leicester (solid to fluid mechanics)</li>
                            <li>River ‚Üí Blood: Anatomical drawings (c. 1513)</li>
                            <li>Blood ‚Üí Music: Treatise on sound (pulse as tempo)</li>
                            <li>Music ‚Üí Stone: Architectural designs (acoustic mass vs. resonance)</li>
                        </ul>
                    </div>

                    <h4>Da Vinci's 10 Principles for Cross-Domain Synthesis</h4>
                    <ol>
                        <li><strong>Start concrete, not abstract:</strong> "Thunder cracking oak" not "kinetic energy transfer"</li>
                        <li><strong>Force domain jumps:</strong> Every transformation must cross fields (Biology ‚Üí Engineering, not Biology ‚Üí Biology)</li>
                        <li><strong>Use sensory anchors:</strong> You must be able to see, hear, touch, smell it (even if abstract, ground it first)</li>
                        <li><strong>Study comparatively:</strong> Bird wing = human arm = mechanical lever (find the pattern)</li>
                        <li><strong>Invert for insight:</strong> Solid ‚Üí Fluid, Structure ‚Üí Chaos, Presence ‚Üí Absence</li>
                        <li><strong>Track analogies rigorously:</strong> River = blood = sound waves = light rays (same propagation principle)</li>
                        <li><strong>Hold multiple domains simultaneously:</strong> Physics + Art + Engineering in working memory at once</li>
                        <li><strong>Find underlying patterns:</strong> Spirals in shells, water vortices, hair, galaxies (same mathematics)</li>
                        <li><strong>Cross-pollinate relentlessly:</strong> Use architecture insights for anatomy, anatomy for painting, painting for optics</li>
                        <li><strong>Document connections:</strong> Build your personal knowledge graph (Leonardo's 13,000 notebook pages)</li>
                    </ol>

                    <h4>Building Your Domain Vocabulary</h4>
                    <p>Da Vinci actively worked across <strong>50+ domains</strong>. Start with 10-15, expand to 30+ over time:</p>

                    <table style="width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 0.85rem;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 8px; border: 1px solid #555; text-align: left;">Category</th>
                            <th style="padding: 8px; border: 1px solid #555; text-align: left;">Domains (Beginner Set)</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Natural Sciences</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Physics, Chemistry, Biology, Astronomy, Geology, Meteorology</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Engineering</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Mechanical, Hydraulic, Civil, Architecture, Optics, Acoustics</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Arts</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Painting, Sculpture, Music Theory, Literature, Calligraphy</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Human Sciences</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Anatomy, Psychology, Medicine, Philosophy, Theology</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Mathematics</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Geometry, Algebra, Logic, Statistics</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;"><strong>Practical Arts</strong></td>
                            <td style="padding: 8px; border: 1px solid #555;">Agriculture, Viticulture, Metallurgy, Textiles, Navigation</td>
                        </tr>
                    </table>

                    <p style="color: #aaa; margin-top: 12px;"><strong>Advanced domains (Level 8-9):</strong> Neuroscience, Thermodynamics, Ecology, Cosmology, Epistemology, Symbolic Logic, Game Theory, Cognitive Science, Information Theory, Cryptography, Jurisprudence, Political Science, Economics, Anthropology, Linguistics</p>

                    <h4>Practice Progression Timeline</h4>
                    <div class="sandbox-journal" style="background: rgba(22, 33, 62, 0.8); padding: 16px; margin: 16px 0;">
                        <p><strong>Week 1-2: Level 1-3 Foundation</strong> (2-3 domains per trial)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Build core vocabulary across 10-15 domains</li>
                            <li>Practice single transformations (Apple ‚Üí Fruit, Pigment ‚Üí Ultramarine)</li>
                            <li>Master concrete-to-abstract and abstract-to-concrete jumps</li>
                            <li>Document your transformations (journal format)</li>
                            <li>Goal: 90% accuracy, 5-second response time</li>
                        </ul>

                        <p style="margin-top: 16px;"><strong>Week 3-4: Level 4-6 Cross-Field Synthesis</strong> (4-6 domains)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Force domain jumps on every transformation</li>
                            <li>Chain three concepts across different fields</li>
                            <li>Begin meta-relational reasoning (operator analysis)</li>
                            <li>Expand vocabulary to 20-25 domains</li>
                            <li>Goal: Fluent cross-pollination, no same-domain chains</li>
                        </ul>

                        <p style="margin-top: 16px;"><strong>Week 5-8: Level 7-8 Renaissance Thinking</strong> (6-8 domains)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Execute compound transformations (two sequential operators)</li>
                            <li>Invent diagonal operator meanings (NE, SE, SW, NW)</li>
                            <li>Maintain 8-direction semantic consistency across trials</li>
                            <li>Master vocabulary of 30+ domains</li>
                            <li>Study historical cross-domain thinkers (da Vinci, Goethe, Feynman)</li>
                            <li>Goal: Simultaneous multi-domain reasoning, rapid switching</li>
                        </ul>

                        <p style="margin-top: 16px;"><strong>Week 9+: Level 9 Da Vinci Mastery</strong> (8-12 domains)</p>
                        <ul style="margin-left: 20px; color: #aaa;">
                            <li>Triple-nested transformation chains (three sequential operators)</li>
                            <li>16-direction fine-grained operator system</li>
                            <li>Traverse 8+ domains in single premise</li>
                            <li>Active vocabulary: 40-50 domains, passive: 60+</li>
                            <li>Read da Vinci's notebooks for inspiration (Codex Leicester, Codex Arundel)</li>
                            <li>Goal: Peak fluid intelligence, universal pattern recognition</li>
                        </ul>
                    </div>

                    <h4>Comparing Levels: Domain Traversal Counts</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9rem;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 8px; border: 1px solid #555;">Level</th>
                            <th style="padding: 8px; border: 1px solid #555;">Premise Type</th>
                            <th style="padding: 8px; border: 1px solid #555;">Typical Domains</th>
                            <th style="padding: 8px; border: 1px solid #555;">Example</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 1</td>
                            <td style="padding: 8px; border: 1px solid #555;">Single atom</td>
                            <td style="padding: 8px; border: 1px solid #555;">2</td>
                            <td style="padding: 8px; border: 1px solid #555;">Bird feather (Ornithology) ‚Üí Pen nib (Engineering)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 2</td>
                            <td style="padding: 8px; border: 1px solid #555;">Two atoms</td>
                            <td style="padding: 8px; border: 1px solid #555;">3</td>
                            <td style="padding: 8px; border: 1px solid #555;">Snail shell ‚Üí Golden ratio ‚Üí Cathedral dome</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 3</td>
                            <td style="padding: 8px; border: 1px solid #555;">Multi-atom chains</td>
                            <td style="padding: 8px; border: 1px solid #555;">4</td>
                            <td style="padding: 8px; border: 1px solid #555;">Eagle embryo ‚Üí Hydraulic piston ‚Üí Organ bellows ‚Üí Diaphragm</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 4-5</td>
                            <td style="padding: 8px; border: 1px solid #555;">Complex chains + foils</td>
                            <td style="padding: 8px; border: 1px solid #555;">4-6</td>
                            <td style="padding: 8px; border: 1px solid #555;">Similar to Level 3, more atoms</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 6</td>
                            <td style="padding: 8px; border: 1px solid #555;">Meta-relational (g-Leap)</td>
                            <td style="padding: 8px; border: 1px solid #555;">5-8</td>
                            <td style="padding: 8px; border: 1px solid #555;">Analyzing operator relationships across domains</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 7</td>
                            <td style="padding: 8px; border: 1px solid #555;">Compound operators</td>
                            <td style="padding: 8px; border: 1px solid #555;">6-8</td>
                            <td style="padding: 8px; border: 1px solid #555;">Order ‚Üí Hierarchy ‚Üí Manager (3 domains √ó 2 compounds)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 8</td>
                            <td style="padding: 8px; border: 1px solid #555;">8-direction diagonals</td>
                            <td style="padding: 8px; border: 1px solid #555;">6-9</td>
                            <td style="padding: 8px; border: 1px solid #555;">Electricity ‚Üí Neural ‚Üí Meditation (NE-SW chain)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Level 9</td>
                            <td style="padding: 8px; border: 1px solid #555;">Triple-nested 16-direction</td>
                            <td style="padding: 8px; border: 1px solid #555;">8-12</td>
                            <td style="padding: 8px; border: 1px solid #555;">Bird wing ‚Üí Arm ‚Üí Lever ‚Üí Hydraulic piston (4 domains √ó 2 compounds)</td>
                        </tr>
                    </table>

                    <h4>The Da Vinci Mindset: Simultaneous Multi-Domain Awareness</h4>
                    <p>When Leonardo looked at a bird, he saw:</p>
                    <ul style="margin-left: 20px; color: #aaa;">
                        <li><strong>Anatomy:</strong> Bone structure, muscle attachment, feather arrangement</li>
                        <li><strong>Physics:</strong> Lift, drag, thrust, air pressure differential</li>
                        <li><strong>Engineering:</strong> Wing as lever, body as aerodynamic form</li>
                        <li><strong>Mathematics:</strong> Wing-beat frequency, glide ratios, turning radius</li>
                        <li><strong>Painting:</strong> Light on feathers, color gradients, motion blur</li>
                        <li><strong>Philosophy:</strong> Freedom, transcendence, escape from earth</li>
                    </ul>
                    <p style="margin-top: 12px;"><strong>All simultaneously.</strong> This is Level 1 applied with da Vinci consciousness.</p>

                    <h4>Your Challenge: Cross-Domain from Trial One</h4>
                    <p style="color: #fff; background: rgba(139, 0, 255, 0.2); padding: 12px; border-left: 4px solid #8b00ff; margin: 20px 0;">
                        <strong>Do not wait for Level 9 to think like da Vinci.</strong><br><br>
                        On your very next Level 1 trial, when you see "X is north of Y":<br>
                        <strong>1.</strong> Anchor Y to something concrete from a specific domain (e.g., "Chisel" from Sculpture)<br>
                        <strong>2.</strong> Force a domain jump for X (e.g., "Tool" from Engineering, not "Sculpture tool")<br>
                        <strong>3.</strong> Document: "Chisel (Sculpture) ‚Üí Tool (Engineering) = 2 domains"<br><br>
                        You just did da Vinci-level cross-domain synthesis. At Level 1. In 3 seconds.
                    </p>

                    <h4>Historical Validation: Da Vinci's Actual Cross-Domain Jumps</h4>
                    <p>These transformations appear verbatim in Leonardo's notebooks:</p>
                    <table style="width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 0.85rem;">
                        <tr style="background: rgba(52, 152, 219, 0.2);">
                            <th style="padding: 8px; border: 1px solid #555;">Transformation</th>
                            <th style="padding: 8px; border: 1px solid #555;">Domains</th>
                            <th style="padding: 8px; border: 1px solid #555;">Source</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Bird wing ‚Üí Human arm ‚Üí Lever</td>
                            <td style="padding: 8px; border: 1px solid #555;">Ornithology ‚Üí Anatomy ‚Üí Engineering</td>
                            <td style="padding: 8px; border: 1px solid #555;">Codex on Flight (c. 1505)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">River flow ‚Üí Blood circulation</td>
                            <td style="padding: 8px; border: 1px solid #555;">Hydrology ‚Üí Cardiovascular Anatomy</td>
                            <td style="padding: 8px; border: 1px solid #555;">Anatomical Studies (c. 1513)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Water vortex ‚Üí Hair spiral ‚Üí Shell spiral</td>
                            <td style="padding: 8px; border: 1px solid #555;">Fluid Dynamics ‚Üí Art ‚Üí Malacology</td>
                            <td style="padding: 8px; border: 1px solid #555;">Codex Leicester (c. 1508)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Eye lens ‚Üí Camera obscura ‚Üí Painting perspective</td>
                            <td style="padding: 8px; border: 1px solid #555;">Anatomy ‚Üí Optics ‚Üí Art</td>
                            <td style="padding: 8px; border: 1px solid #555;">Manuscript D (c. 1508)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Hammer on anvil ‚Üí Thunder ‚Üí Cannon blast</td>
                            <td style="padding: 8px; border: 1px solid #555;">Metallurgy ‚Üí Meteorology ‚Üí Military Engineering</td>
                            <td style="padding: 8px; border: 1px solid #555;">Codex Atlanticus (c. 1490)</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Lute string vibration ‚Üí Air column resonance</td>
                            <td style="padding: 8px; border: 1px solid #555;">Music Theory ‚Üí Acoustics</td>
                            <td style="padding: 8px; border: 1px solid #555;">Manuscript H (c. 1494)</td>
                        </tr>
                    </table>

                    <h4>Final Insight: The Unity of Knowledge</h4>
                    <p style="color: #aaa;">Leonardo's ultimate discovery was that <strong>all knowledge is connected</strong>. Physics, biology, art, music, engineering‚Äîthese are not isolated islands. They are different languages describing the same underlying patterns.</p>

                    <p style="color: #aaa; margin-top: 12px;">When you force cross-domain transformations in Imagi-World, you're not just playing a memory game. You're <strong>training the cognitive architecture of genius</strong>‚Äîthe ability to see the One in the Many, to recognize that:</p>

                    <ul style="margin-left: 20px; color: #aaa;">
                        <li>A bird wing and a hydraulic piston both embody lever mechanics</li>
                        <li>A river and a bloodstream both demonstrate fluid transport networks</li>
                        <li>A spiral shell and a galaxy both follow logarithmic growth</li>
                        <li>A painting and a mathematical proof both reveal hidden truth</li>
                    </ul>

                    <p style="color: #fff; background: rgba(46, 204, 113, 0.2); padding: 12px; border-left: 4px solid #2ecc71; margin: 20px 0; font-weight: bold;">
                        "Once you have tasted flight, you will forever walk the earth with your eyes turned skyward, for there you have been, and there you will always long to return." ‚ÄîLeonardo da Vinci
                    </p>

                    <p style="color: #8b00ff; font-weight: bold; margin-top: 20px;">Da Vinci did not wait for complexity to think cross-domain. He saw a bird and thought of painting, anatomy, engineering, philosophy‚Äîsimultaneously. You can do this at Level 1. Start now.</p>
                `,
                speech: 'Da Vinci does Imagi-World. Leonardo da Vinci\'s genius was not handling complexity, it was seeing connections across domains. This tutorial teaches you to apply his cross-domain synthesis method to every level of Imagi-World, from Level One to Level Nine. The Core Principle: Cross-Domain Transformation. Da Vinci didn\'t just study birds, he studied birds to design flying machines. He didn\'t just paint, he studied optics to perfect sfumato. Every transformation crossed domains. You can do this at any level. Level One: single atoms lead to two to three domain jumps. Level Three: chains lead to four to five domain jumps. Level Six: meta-relational leads to six to eight domain jumps. Level Nine: triple compounds lead to eight to twelve domain jumps. Level One: Da Vinci Solves X is north of Y. Example One: Y equals Bird wing feather from Ornithology, north to X equals Mechanical pen nib from Engineering and Writing Instruments. Da Vinci\'s connection: In Codex Atlanticus, da Vinci sketched bird feathers alongside pen designs, recognizing that both use flexible vanes or tines to control flow, air for feathers, ink for nibs. The generalization is flexible flow control mechanisms. Domain jump from Ornithology to Engineering. Total: two radically different domains. Example Two: Y equals Water mill wheel from Hydraulic Engineering, south to X equals Human heart valve from Cardiovascular Anatomy. Da Vinci\'s connection: Da Vinci\'s anatomical drawings, circa fifteen thirteen, show heart valves modeled after mill wheel mechanics. Both prevent backflow through rhythmic opening and closing. The specification is one-way flow gate. Domain jump from Hydraulic Engineering to Medicine. Total: two completely different domains. Level One domain count: four unique fields traversed in simple premises, but now with true cross-domain leaps, not subdomain drift. Level Two: Da Vinci Solves X is north of Y is east of Z. Cross-domain chain: Z equals Snail shell spiral from Malacology and Biology, north to Y equals Golden ratio mathematics from Geometry, east to X equals Cathedral dome architecture from Civil Engineering and Architecture. Da Vinci\'s connection: Da Vinci measured snail shells, extracted the phi ratio, and applied it to architectural proportions in his church designs. Three radically different domains crossed in one chain: Biology to Mathematics to Architecture. Total: three completely different domains. Historical note: Da Vinci\'s notebooks, Codex Madrid the Second, contain sketches of nautilus shells with geometric overlays, demonstrating his recognition that biological growth patterns encode universal mathematical proportions applicable to human architecture. Level Three: Da Vinci Solves Multi-Atom Chains. Four-concept cross-domain chain: A equals Eagle embryo wing bud from Embryology, north to B equals Hydraulic piston expansion from Mechanical Engineering, east to C equals Organ pipe bellows from Music and Acoustics, south to D equals Respiratory diaphragm from Human Anatomy. One: Wing bud to Hydraulic piston, biological tissue growth generalized to mechanical expansion principle. Two: Hydraulic piston to Organ bellows, mechanical analogue, both are pressure-driven expansion chambers. Three: Organ bellows to Diaphragm, musical instrument specified to its biological counterpart. Domain progression: Embryology to Engineering to Music to Anatomy. Total: four radically different domains. Da Vinci actually did this. His anatomical notebooks, Windsor Collection, circa fifteen ten to fifteen thirteen, show embryonic development studies alongside hydraulic machines. He designed organ bellows for musical instruments while simultaneously dissecting human lungs. He recognized expansion and contraction as a universal principle across biology, engineering, music, and medicine. Level Six: Da Vinci Solves Meta-Relational g-Leap. Premise: West to North as South to East. Left pair, West to North: West equals Marble block from Geology and Materials, north to Imprisoned sculpture from Artistic Vision and Philosophy. Marble block is the physical opposite of revealed form, raw versus finished. Sculpture is the abstract artistic vision, Michelangelo\'s concept: the statue exists within the stone, waiting to be freed. Transformation: Material opposition to Generalized abstraction. Hidden operator: Opposite then generalize equals West-to-North compound. Right pair, South to East: South equals Water flow from Fluid Dynamics and Physics, east to Musical harmony propagation from Acoustics and Music Theory. Water flow is the concrete physical manifestation of wave propagation. Musical harmony is its acoustic analogue, both involve rhythmic periodic motion through a medium. Transformation: Specify to material example then find sonic parallel. Hidden operator: Specify then find analogue equals South-to-East compound. Meta-analysis: Does West-to-North equal South-to-East? No. The premise is false. Domains traversed: Geology, Artistic Philosophy, Fluid Dynamics, Music Theory, Meta-Logic. Total: five domains to evaluate one meta-relational premise. This is the g-Leap, generalizing about generalizations across radically different fields. Da Vinci\'s actual work: In his Treatise on Painting and Codex Leicester, da Vinci compared solid material transformation, sculpture from stone, to fluid dynamics, water shaping landscapes, to sound propagation, acoustic waves. He recognized these as parallel transformation patterns across art, physics, and music, the exact meta-relational thinking Level Six demands. Level Six demands six to eight domain jumps when you semantically anchor both operator pairs and analyze their meta-relationship across radically different fields. Level Seven: Da Vinci Solves Compound Operators. Premise: north-south is east of east-west. Left compound, north-south: Seed equals Telescope lens from Optics and Astronomy, apply North to Human eye anatomy from Vision Science and Physiology, apply South to Painting perspective technique from Art and Renaissance Technique. Result: Painting perspective technique. Three domains: Optics to Physiology to Art. Right compound, east-west: Seed equals Ship sail from Maritime Engineering and Navigation, apply East to Bird wing from Ornithology and Flight Mechanics, apply West to Wind pattern analysis from Meteorology and Atmospheric Science. Result: Wind pattern analysis. Three domains: Maritime Engineering to Ornithology to Meteorology. Meta-relation: Is Painting perspective technique east, or analogue, of Wind pattern analysis? Yes. Da Vinci\'s insight: Both are systems for mapping invisible forces onto visible surfaces. Perspective painting captures spatial depth, three-dimensional to two-dimensional optical projection. Wind analysis captures air currents, invisible flow to visible effects. Both translate hidden structure into perceivable form through geometric and observational methods. Level Seven total: six domains: Optics, Physiology, Art, Maritime Engineering, Ornithology, Meteorology. Historical validation: Da Vinci\'s Treatise on Painting directly connects telescope optics to eye anatomy to develop perspective laws. His studies of bird flight, Codex on Flight, explicitly compare sail mechanics to wing aerodynamics. Both transformation chains appear in his actual notebooks. Level Eight: Da Vinci Solves Eight-Direction Diagonals. Premise: northeast-southwest is north of southeast-northwest. Left compound, northeast-southwest: Seed equals Violin string vibration from Acoustics and Music Theory, apply NE, elevated analogue, to Light wave propagation from Optics and Physics, apply SW, material opposite, to Marble quarry silence from Geology and Architecture. Result: Marble quarry silence. Right compound, southeast-northwest: Seed equals Flowing river current from Hydrology and Fluid Dynamics, apply SE, concrete analogue, to Blood vessel circulation from Cardiovascular Medicine, apply NW, abstract opposite, to Contemplative stillness meditation from Philosophy and Contemplative Practice. Result: Contemplative stillness meditation. Meta-relation: Is Marble quarry silence north of Contemplative stillness meditation? No, false. Contemplative meditation is the generalized, abstract, form of intentional silence. Marble quarry is the material, concrete, instance of passive silence. The meditation is north of the quarry, not vice versa. The premise is false, forcing you to recognize the abstraction hierarchy across these radically different domains. Level Eight total: seven domains: Acoustics, Optics, Geology, Hydrology, Medicine, Philosophy, Contemplative Practice. This is Renaissance-level synthesis. Historical note: Da Vinci studied violin string vibrations in Manuscript H, circa fourteen ninety-four, compared wave propagation across sound and light in his optics treatise, analyzed marble quarry stone selection for architecture, notes on Duomo di Milano, compared river flow to blood in Codex Leicester, and advocated meditative observation in his painting instructions. He explicitly connected acoustic waves to light waves to material properties to fluid dynamics to contemplative practice. All seven domains unified. Level Nine: Da Vinci\'s Peak, Triple-Nested Compounds. Example from DaVinci_Does_Nine document. Premise: SE-E-SW is northeast of E-NNE-SSW. Left compound, SE-E-SW: Seed is Bird wing from Ornithology, SE to Human arm anatomy from Human Anatomy, E to Mechanical lever from Engineering, SW to Hydraulic piston from Hydraulic Engineering. Result: Hydraulic piston. Right compound, E-NNE-SSW: Seed is Flowing river from Hydrology, E to Bloodstream from Cardiovascular Anatomy, NNE to Musical harmony propagation from Music Theory and Acoustics, SSW to Stone quarry silence from Geology and Architecture. Result: Stone quarry silence. Meta-relation: Is Hydraulic piston northeast of Stone quarry silence? Da Vinci\'s analysis: Both represent states of potential energy. The piston contains pressurized water ready to release force, dynamic potential. The quarry contains stone ready to be shaped into architecture, material potential. The piston is the abstract elevated analogue, generalized potential. Northeast equals abstract plus analogue. True, match. Level Nine total: eight unique domains: Ornithology, Human Anatomy, Mechanical Engineering, Hydraulic Engineering, Hydrology, Cardiovascular Anatomy, Music Theory, Geology and Architecture. Historical validation: Every transformation above appears in Leonardo\'s actual notebooks. Bird wing to Human arm: Codex on Flight of Birds, comparative anatomy. Arm to Lever: Codex Arundel, biomechanics. Lever to Hydraulic: Codex Leicester, solid to fluid mechanics. River to Blood: Anatomical drawings, circa fifteen thirteen. Blood to Music: Treatise on sound, pulse as tempo. Music to Stone: Architectural designs, acoustic mass versus resonance. Da Vinci\'s Ten Principles for Cross-Domain Synthesis. One: Start concrete, not abstract. Thunder cracking oak, not kinetic energy transfer. Two: Force domain jumps. Every transformation must cross fields. Biology to Engineering, not Biology to Biology. Three: Use sensory anchors. You must be able to see, hear, touch, smell it. Even if abstract, ground it first. Four: Study comparatively. Bird wing equals human arm equals mechanical lever. Find the pattern. Five: Invert for insight. Solid to Fluid, Structure to Chaos, Presence to Absence. Six: Track analogies rigorously. River equals blood equals sound waves equals light rays. Same propagation principle. Seven: Hold multiple domains simultaneously. Physics plus Art plus Engineering in working memory at once. Eight: Find underlying patterns. Spirals in shells, water vortices, hair, galaxies. Same mathematics. Nine: Cross-pollinate relentlessly. Use architecture insights for anatomy, anatomy for painting, painting for optics. Ten: Document connections. Build your personal knowledge graph. Leonardo\'s thirteen thousand notebook pages. Building Your Domain Vocabulary. Da Vinci actively worked across fifty plus domains. Start with ten to fifteen, expand to thirty plus over time. The tutorial includes a table categorizing domains: Natural Sciences include Physics, Chemistry, Biology, Astronomy, Geology, Meteorology. Engineering includes Mechanical, Hydraulic, Civil, Architecture, Optics, Acoustics. Arts include Painting, Sculpture, Music Theory, Literature, Calligraphy. Human Sciences include Anatomy, Psychology, Medicine, Philosophy, Theology. Mathematics includes Geometry, Algebra, Logic, Statistics. Practical Arts include Agriculture, Viticulture, Metallurgy, Textiles, Navigation. Advanced domains for Level eight to nine include Neuroscience, Thermodynamics, Ecology, Cosmology, Epistemology, Symbolic Logic, Game Theory, Cognitive Science, Information Theory, Cryptography, Jurisprudence, Political Science, Economics, Anthropology, Linguistics. Practice Progression Timeline. Week one to two: Level one to three Foundation, two to three domains per trial. Build core vocabulary across ten to fifteen domains. Practice single transformations. Master concrete-to-abstract and abstract-to-concrete jumps. Document your transformations in journal format. Goal: ninety percent accuracy, five-second response time. Week three to four: Level four to six Cross-Field Synthesis, four to six domains. Force domain jumps on every transformation. Chain three concepts across different fields. Begin meta-relational reasoning, operator analysis. Expand vocabulary to twenty to twenty-five domains. Goal: Fluent cross-pollination, no same-domain chains. Week five to eight: Level seven to eight Renaissance Thinking, six to eight domains. Execute compound transformations, two sequential operators. Invent diagonal operator meanings: NE, SE, SW, NW. Maintain eight-direction semantic consistency across trials. Master vocabulary of thirty plus domains. Study historical cross-domain thinkers like da Vinci, Goethe, Feynman. Goal: Simultaneous multi-domain reasoning, rapid switching. Week nine plus: Level nine Da Vinci Mastery, eight to twelve domains. Triple-nested transformation chains, three sequential operators. Sixteen-direction fine-grained operator system. Traverse eight plus domains in single premise. Active vocabulary: forty to fifty domains, passive: sixty plus. Read da Vinci\'s notebooks for inspiration: Codex Leicester, Codex Arundel. Goal: Peak fluid intelligence, universal pattern recognition. The Da Vinci Mindset: Simultaneous Multi-Domain Awareness. When Leonardo looked at a bird, he saw: Anatomy, bone structure, muscle attachment, feather arrangement. Physics, lift, drag, thrust, air pressure differential. Engineering, wing as lever, body as aerodynamic form. Mathematics, wing-beat frequency, glide ratios, turning radius. Painting, light on feathers, color gradients, motion blur. Philosophy, freedom, transcendence, escape from earth. All simultaneously. This is Level One applied with da Vinci consciousness. Your Challenge: Cross-Domain from Trial One. Do not wait for Level Nine to think like da Vinci. On your very next Level One trial, when you see X is north of Y: One, anchor Y to something concrete from a specific domain, for example, Chisel from Sculpture. Two, force a domain jump for X, for example, Tool from Engineering, not Sculpture tool. Three, document: Chisel from Sculpture to Tool from Engineering equals two domains. You just did da Vinci-level cross-domain synthesis. At Level One. In three seconds. Historical Validation: Da Vinci\'s Actual Cross-Domain Jumps. These transformations appear verbatim in Leonardo\'s notebooks. Bird wing to Human arm to Lever: Ornithology to Anatomy to Engineering, from Codex on Flight, circa fifteen oh five. River flow to Blood circulation: Hydrology to Cardiovascular Anatomy, from Anatomical Studies, circa fifteen thirteen. Water vortex to Hair spiral to Shell spiral: Fluid Dynamics to Art to Malacology, from Codex Leicester, circa fifteen oh eight. Eye lens to Camera obscura to Painting perspective: Anatomy to Optics to Art, from Manuscript D, circa fifteen oh eight. Hammer on anvil to Thunder to Cannon blast: Metallurgy to Meteorology to Military Engineering, from Codex Atlanticus, circa fourteen ninety. Lute string vibration to Air column resonance: Music Theory to Acoustics, from Manuscript H, circa fourteen ninety-four. Final Insight: The Unity of Knowledge. Leonardo\'s ultimate discovery was that all knowledge is connected. Physics, biology, art, music, engineering, these are not isolated islands. They are different languages describing the same underlying patterns. When you force cross-domain transformations in Imagi-World, you\'re not just playing a memory game. You\'re training the cognitive architecture of genius, the ability to see the One in the Many, to recognize that: A bird wing and a hydraulic piston both embody lever mechanics. A river and a bloodstream both demonstrate fluid transport networks. A spiral shell and a galaxy both follow logarithmic growth. A painting and a mathematical proof both reveal hidden truth. Quote from Leonardo da Vinci: Once you have tasted flight, you will forever walk the earth with your eyes turned skyward, for there you have been, and there you will always long to return. Da Vinci did not wait for complexity to think cross-domain. He saw a bird and thought of painting, anatomy, engineering, philosophy, simultaneously. You can do this at Level One. Start now.'
            },
            {
                id: 'walkthrough-n2-10',
                title: 'n-Back-2: 10-Trial Walkthrough',
                html: '',
                render: (mount) => renderWalkthroughN2(mount),
                speech: walkthroughN2SpeechText()
            }
        ];

        let guidedExamplesRoot = null;

        function renderGuidedExamples() {
            const mount = document.getElementById('instContent');
            if (!mount) return;

            if (guidedExamplesRoot && mount.dataset.examplesLoaded === '1') {
                mount.innerHTML = '';
                mount.appendChild(guidedExamplesRoot);
                return;
            }

            const examples = getBeginnerExamples();
            const container = document.createElement('div');
            container.id = 'guidedExamples';

            const heading = document.createElement('h3');
            heading.textContent = 'Guided Examples';
            container.appendChild(heading);

            const intro = document.createElement('p');
            intro.textContent = 'Study thirty beginner-friendly mappings. Anchor each letter, follow the compass moves, and confirm the resulting mapping with the provided rationale.';
            container.appendChild(intro);

            const filters = document.createElement('div');
            filters.id = 'examplesFilters';
            filters.innerHTML = `
                <strong>Filter:</strong>
                <button data-f="all" class="active">All</button>
                <button data-f="single">Single-atom</button>
                <button data-f="double-same-head">Two-atom (same head)</button>
                <button data-f="double-dual-head">Two-atom (dual heads)</button>
                <button data-f="triple-chain">Three-atom chains</button>
                <button data-f="quad">Four-atom sets</button>
            `;
            container.appendChild(filters);

            const list = document.createElement('ol');
            list.id = 'examplesList';
            container.appendChild(list);

            function renderList(filter = 'all') {
                list.innerHTML = '';
                examples
                    .filter(ex => filter === 'all' ? true : ex.level === filter)
                    .forEach(ex => {
                        const li = document.createElement('li');
                        li.className = `ex ex-${ex.level}`;
                        li.innerHTML = `
                            <h4>Ex ${ex.id}. ${ex.theme}</h4>
                            <p><strong>Premise:</strong> ${ex.premise}</p>
                            <p><strong>Anchors:</strong> ${ex.anchors.map(([L, c]) => `${L} := "${c}"`).join('; ')}</p>
                            <p><strong>Transforms:</strong> ${ex.transforms.join(' ‚Ä¢ ')}</p>
                            <p><strong>Resulting mapping:</strong> ${ex.mapping.map(([L, c]) => `${L} ‚Üí "${c}"`).join('; ')}</p>
                            <p><em>Why it works:</em> ${ex.rationale}</p>
                            <div class="exActions">
                                <button data-speak="${ex.id}">Speak summary</button>
                                <button data-copy="${ex.id}">Copy to clipboard</button>
                            </div>
                        `;
                        list.appendChild(li);
                    });
            }

            renderList('all');

            container.addEventListener('click', (event) => {
                const button = event.target.closest('button');
                if (!button) return;
                const filter = button.dataset.f;
                if (filter) {
                    container.querySelectorAll('#examplesFilters button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    renderList(filter);
                    return;
                }
                if (button.dataset.speak) {
                    const id = parseInt(button.dataset.speak, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        speakOnce(summarizeExample(example));
                    }
                }
                if (button.dataset.copy) {
                    const id = parseInt(button.dataset.copy, 10);
                    const example = examples.find(x => x.id === id);
                    if (example) {
                        const summary = summarizeExample(example);
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            navigator.clipboard.writeText(summary).catch(() => {
                                window.prompt('Copy this example summary:', summary);
                            });
                        } else {
                            window.prompt('Copy this example summary:', summary);
                        }
                    }
                }
            });

            function summarizeExample(ex) {
                const line1 = `Premise: ${ex.premise}`;
                const line2 = `Anchors: ${ex.anchors.map(([L, c]) => `${L} equals ${c}`).join('; ')}.`;
                const line3 = `Mapping: ${ex.mapping.map(([L, c]) => `${L} to ${c}`).join('; ')}.`;
                return `${line1} ${line2} ${line3}`;
            }

            mount.innerHTML = '';
            mount.appendChild(container);
            mount.dataset.examplesLoaded = '1';
            guidedExamplesRoot = container;
        }

        function getBeginnerExamples() {
            return [
                // --- Single-atom (10) ---
                { id:1, level:"single", theme:"Learning ‚Äî Up-shift",
                  premise:"N is north of J.",
                  anchors:[["J","Fact"]],
                  transforms:["North(J‚ÜíN): up-shift Fact ‚Üí Theory"],
                  mapping:[["J","Fact"],["N","Theory"]],
                  rationale:"North is higher abstraction; Theory stands above Fact."
                },
                { id:2, level:"single", theme:"Biology ‚Äî Down-shift",
                  premise:"B is south of A.",
                  anchors:[["A","Animal"]],
                  transforms:["South(A‚ÜíB): down-shift Animal ‚Üí Dog"],
                  mapping:[["A","Animal"],["B","Dog"]],
                  rationale:"South is more specific; Dog is an instance of Animal."
                },
                { id:3, level:"single", theme:"Illumination ‚Äî Analogue",
                  premise:"C is east of D.",
                  anchors:[["D","Candle"]],
                  transforms:["East(D‚ÜíC): analogue of Candle ‚Üí Lantern"],
                  mapping:[["D","Candle"],["C","Lantern"]],
                  rationale:"East is same-role/sibling; Lantern parallels Candle."
                },
                { id:4, level:"single", theme:"Order/Chaos ‚Äî Opposite",
                  premise:"E is west of F.",
                  anchors:[["F","Order"]],
                  transforms:["West(F‚ÜíE): opposite of Order ‚Üí Chaos"],
                  mapping:[["F","Order"],["E","Chaos"]],
                  rationale:"West is counterpart; Chaos opposes Order."
                },
                { id:5, level:"single", theme:"Technology ‚Äî Up-shift",
                  premise:"G is north of H.",
                  anchors:[["H","Program"]],
                  transforms:["North(H‚ÜíG): Program ‚Üí Platform"],
                  mapping:[["H","Program"],["G","Platform"]],
                  rationale:"Platform generalizes programs; higher on the Arc."
                },
                { id:6, level:"single", theme:"Music ‚Äî Down-shift",
                  premise:"I is south of K.",
                  anchors:[["K","Song"]],
                  transforms:["South(K‚ÜíI): Song ‚Üí Verse"],
                  mapping:[["K","Song"],["I","Verse"]],
                  rationale:"Verse is a component of a Song."
                },
                { id:7, level:"single", theme:"Navigation ‚Äî Analogue",
                  premise:"L is east of M.",
                  anchors:[["M","Map"]],
                  transforms:["East(M‚ÜíL): Map ‚Üí Chart"],
                  mapping:[["M","Map"],["L","Chart"]],
                  rationale:"Chart is a sibling format to Map."
                },
                { id:8, level:"single", theme:"Emotion ‚Äî Opposite",
                  premise:"P is west of O.",
                  anchors:[["O","Calm"]],
                  transforms:["West(O‚ÜíP): Calm ‚Üí Agitation"],
                  mapping:[["O","Calm"],["P","Agitation"]],
                  rationale:"Agitation is the counter-state of Calm."
                },
                { id:9, level:"single", theme:"Finance ‚Äî Up-shift",
                  premise:"Q is north of R.",
                  anchors:[["R","Expense"]],
                  transforms:["North(R‚ÜíQ): Expense ‚Üí Budget"],
                  mapping:[["R","Expense"],["Q","Budget"]],
                  rationale:"Budget organizes expenses; higher level."
                },
                { id:10, level:"single", theme:"Astronomy ‚Äî Down-shift",
                  premise:"T is south of S.",
                  anchors:[["S","Galaxy"]],
                  transforms:["South(S‚ÜíT): Galaxy ‚Üí Star"],
                  mapping:[["S","Galaxy"],["T","Star"]],
                  rationale:"A Star is a constituent of a Galaxy."
                },

                // --- Two-atom: same head (8) ---
                { id:11, level:"double-same-head", theme:"Theory & Order ‚Äî Compound",
                  premise:"Z is south of J; Z is west of P.",
                  anchors:[["J","Theory"],["P","Order"]],
                  transforms:["South(J‚ÜíZ): Theory ‚Üí Example","West(P‚ÜíZ): Order ‚Üí Chaos (compound: Chaotic example)"],
                  mapping:[["J","Theory"],["P","Order"],["Z","Chaotic example"]],
                  rationale:"Z must satisfy both; a 'Chaotic example' fits down-shift and opposition."
                },
                { id:12, level:"double-same-head", theme:"Writing ‚Äî Paragraph role",
                  premise:"A is north of B; A is east of C.",
                  anchors:[["B","Sentence"],["C","Section"]],
                  transforms:["North(B‚ÜíA): Sentence ‚Üí Paragraph","East(C‚ÜíA): Section ‚Üí Paragraph (sibling)"],
                  mapping:[["B","Sentence"],["C","Section"],["A","Paragraph"]],
                  rationale:"Paragraph stands above a Sentence and parallels a Section in function."
                },
                { id:13, level:"double-same-head", theme:"Physics ‚Äî Heat vs Cold",
                  premise:"D is south of C; D is west of E.",
                  anchors:[["C","Energy"],["E","Cold"]],
                  transforms:["South(C‚ÜíD): Energy ‚Üí Heat","West(E‚ÜíD): Cold ‚Üí Heat"],
                  mapping:[["C","Energy"],["E","Cold"],["D","Heat"]],
                  rationale:"Heat is a specific form of Energy and the counter to Cold."
                },
                { id:14, level:"double-same-head", theme:"Light ‚Äî Coherent mapping",
                  premise:"H is east of I; H is north of J.",
                  anchors:[["I","Lamp"],["J","Flame"]],
                  transforms:["East(I‚ÜíH): Lamp ‚Üí Lantern","North(J‚ÜíH): Flame ‚Üí Lantern (higher containment)"],
                  mapping:[["I","Lamp"],["J","Flame"],["H","Lantern"]],
                  rationale:"Lantern is a sibling of Lamp, and stands above Flame as container/assembly."
                },
                { id:15, level:"double-same-head", theme:"Ethics ‚Äî Lying as behavior",
                  premise:"K is west of L; K is south of M.",
                  anchors:[["L","Truth"],["M","Behavior"]],
                  transforms:["West(L‚ÜíK): Truth ‚Üí Lie","South(M‚ÜíK): Behavior ‚Üí Lie"],
                  mapping:[["L","Truth"],["M","Behavior"],["K","Lie"]],
                  rationale:"A Lie opposes Truth and is a specific Behavior."
                },
                { id:16, level:"double-same-head", theme:"Literature ‚Äî Forms",
                  premise:"N is east of O; N is south of P.",
                  anchors:[["O","Novel"],["P","Literature"]],
                  transforms:["East(O‚ÜíN): Novel ‚Üí Short story","South(P‚ÜíN): Literature ‚Üí Short story"],
                  mapping:[["O","Novel"],["P","Literature"],["N","Short story"]],
                  rationale:"Short story is a sibling to Novel and a specific of Literature."
                },
                { id:17, level:"double-same-head", theme:"Civics ‚Äî Regulation vs Anarchy",
                  premise:"Q is north of R; Q is west of S.",
                  anchors:[["R","Procedure"],["S","Anarchy"]],
                  transforms:["North(R‚ÜíQ): Procedure ‚Üí Policy","West(S‚ÜíQ): Anarchy ‚Üí Policy"],
                  mapping:[["R","Procedure"],["S","Anarchy"],["Q","Policy"]],
                  rationale:"Policy sits above Procedure and opposes Anarchy's absence of rules."
                },
                { id:18, level:"double-same-head", theme:"Roles ‚Äî Medicine",
                  premise:"T is east of U; T is west of V.",
                  anchors:[["U","Doctor"],["V","Patient"]],
                  transforms:["East(U‚ÜíT): Doctor ‚Üí Physician","West(V‚ÜíT): Patient ‚Üí Physician (counter-role)"],
                  mapping:[["U","Doctor"],["V","Patient"],["T","Physician"]],
                  rationale:"Physician is a synonym/analogue of Doctor and the counter-role to Patient."
                },

                // --- Two-atom: dual heads (6) ---
                { id:19, level:"double-dual-head", theme:"Data & Tools",
                  premise:"W is north of X; Y is east of Z.",
                  anchors:[["X","Data"],["Z","Hammer"]],
                  transforms:["North(X‚ÜíW): Data ‚Üí Information","East(Z‚ÜíY): Hammer ‚Üí Tool"],
                  mapping:[["X","Data"],["W","Information"],["Z","Hammer"],["Y","Tool"]],
                  rationale:"Information abstracts Data; Tool parallels Hammer."
                },
                { id:20, level:"double-dual-head", theme:"Order & Nature",
                  premise:"A is west of B; C is south of D.",
                  anchors:[["B","Order"],["D","Tree"]],
                  transforms:["West(B‚ÜíA): Order ‚Üí Chaos","South(D‚ÜíC): Tree ‚Üí Branch"],
                  mapping:[["B","Order"],["A","Chaos"],["D","Tree"],["C","Branch"]],
                  rationale:"Chaos opposes Order; Branch is part of Tree."
                },
                { id:21, level:"double-dual-head", theme:"Transport & Cities",
                  premise:"E is east of F; G is north of H.",
                  anchors:[["F","Ship"],["H","Town"]],
                  transforms:["East(F‚ÜíE): Ship ‚Üí Boat (sibling craft)","North(H‚ÜíG): Town ‚Üí City"],
                  mapping:[["F","Ship"],["E","Boat"],["H","Town"],["G","City"]],
                  rationale:"Boat parallels Ship; City stands above Town."
                },
                { id:22, level:"double-dual-head", theme:"Light & Art",
                  premise:"I is west of J; K is east of L.",
                  anchors:[["J","Light"],["L","Poem"]],
                  transforms:["West(J‚ÜíI): Light ‚Üí Darkness","East(L‚ÜíK): Poem ‚Üí Song (sibling artform)"],
                  mapping:[["J","Light"],["I","Darkness"],["L","Poem"],["K","Song"]],
                  rationale:"Darkness is the counter-state to Light; Song parallels Poem."
                },
                { id:23, level:"double-dual-head", theme:"Systems & Life",
                  premise:"M is south of N; O is west of P.",
                  anchors:[["N","System"],["P","Life"]],
                  transforms:["South(N‚ÜíM): System ‚Üí Module","West(P‚ÜíO): Life ‚Üí Death"],
                  mapping:[["N","System"],["M","Module"],["P","Life"],["O","Death"]],
                  rationale:"Module is a part of a System; Death opposes Life."
                },
                { id:24, level:"double-dual-head", theme:"Food & Geography",
                  premise:"Q is east of R; S is south of T.",
                  anchors:[["R","Breakfast"],["T","Continent"]],
                  transforms:["East(R‚ÜíQ): Breakfast ‚Üí Brunch (analogue)","South(T‚ÜíS): Continent ‚Üí Country"],
                  mapping:[["R","Breakfast"],["Q","Brunch"],["T","Continent"],["S","Country"]],
                  rationale:"Brunch parallels Breakfast; Country is within a Continent."
                },

                // --- Three-atom chains (4) ---
                { id:25, level:"triple-chain", theme:"Logic ‚Äî Counterexample path",
                  premise:"A is south of B; C is east of A; D is west of C.",
                  anchors:[["B","Theory"]],
                  transforms:["South(B‚ÜíA): Theory ‚Üí Example","East(A‚ÜíC): Example ‚Üí Case study","West(C‚ÜíD): Case study ‚Üí Counterexample"],
                  mapping:[["B","Theory"],["A","Example"],["C","Case study"],["D","Counterexample"]],
                  rationale:"A down; C lateral sibling; D as foil to C‚Äîconsistent chain."
                },
                { id:26, level:"triple-chain", theme:"Projects ‚Äî Work breakdown",
                  premise:"E is north of F; G is south of E; H is east of G.",
                  anchors:[["F","Task"]],
                  transforms:["North(F‚ÜíE): Task ‚Üí Project","South(E‚ÜíG): Project ‚Üí Subtask","East(G‚ÜíH): Subtask ‚Üí Work item"],
                  mapping:[["F","Task"],["E","Project"],["G","Subtask"],["H","Work item"]],
                  rationale:"Up then down then sideways within the same work hierarchy."
                },
                { id:27, level:"triple-chain", theme:"Deception ‚Äî Roles",
                  premise:"I is west of J; K is north of I; L is east of K.",
                  anchors:[["J","Truth"]],
                  transforms:["West(J‚ÜíI): Truth ‚Üí Lie","North(I‚ÜíK): Lie ‚Üí Deception strategy","East(K‚ÜíL): Deception strategy ‚Üí Ruse"],
                  mapping:[["J","Truth"],["I","Lie"],["K","Deception strategy"],["L","Ruse"]],
                  rationale:"Counter-role, then abstraction, then sibling tactic."
                },
                { id:28, level:"triple-chain", theme:"Design ‚Äî Deliverables",
                  premise:"M is east of N; O is north of M; P is south of O.",
                  anchors:[["N","Sketch"]],
                  transforms:["East(N‚ÜíM): Sketch ‚Üí Outline","North(M‚ÜíO): Outline ‚Üí Design","South(O‚ÜíP): Design ‚Üí Wireframe"],
                  mapping:[["N","Sketch"],["M","Outline"],["O","Design"],["P","Wireframe"]],
                  rationale:"Analogue within drafting, then up to Design, then down to a specific artifact."
                },

                // --- Four-atom (2) ---
                { id:29, level:"quad", theme:"Learning ‚Äî Full weave",
                  premise:"H is east of R; Y is north of X; R is south of Y; Z is west of X.",
                  anchors:[["X","Fact"]],
                  transforms:[
                    "North(X‚ÜíY): Fact ‚Üí Theory",
                    "South(Y‚ÜíR): Theory ‚Üí Example",
                    "East(R‚ÜíH): Example ‚Üí Case study",
                    "West(X‚ÜíZ): Fact ‚Üí Fiction"
                  ],
                  mapping:[["X","Fact"],["Y","Theory"],["R","Example"],["H","Case study"],["Z","Fiction"]],
                  rationale:"Classic quartet: up from Fact, down to Example, lateral to Case study, counter to Fiction."
                },
                { id:30, level:"quad", theme:"Education ‚Äî Pedagogy weave",
                  premise:"A is west of D; B is north of A; C is east of B; D is south of C.",
                  anchors:[["A","Play"],["B","Pedagogy"],["C","Andragogy"]],
                  transforms:[
                    "Given A=Play; West requires D to be its structured counterpart ‚Üí Lesson",
                    "North(A‚ÜíB): Play ‚Üí Pedagogy (framework above)",
                    "East(B‚ÜíC): Pedagogy ‚Üí Andragogy (sibling adult-learning)",
                    "South(C‚ÜíD): Andragogy ‚Üí Lesson (specific instructional unit)"
                  ],
                  mapping:[["A","Play"],["B","Pedagogy"],["C","Andragogy"],["D","Lesson"]],
                  rationale:"Play vs Lesson as counter-styles; Pedagogy above Play; Andragogy as sibling to Pedagogy; Lesson as a concrete unit under Andragogy."
                }
            ];
        }

        function walkthroughN2SpeechText() {
            return [
                'n-back two, ten trial walkthrough.',
                'Algorithm reminder: symbol, map a thought, transform by the operation, pair letter and thought, repeat across atoms, recall and update prior pairings when letters return.',
                'Theme: illumination and understanding.',
                'Anchors: J equals Candle; D equals Fireworks; X equals Observation; Y equals Generalization; Z equals Anomaly.',
                'Trial one: D is north of J. Trial two: Z is west of X; Z is south of Y.',
                'Trial three: J is south of D. Match with trial one.',
                'Trial four: X is east of Z; Y is north of Z. Match with trial two.',
                'Trial five: D is east of J. No match with trial three.',
                'Trial six: Z is west of X; Z is south of Y. Match with trial four.',
                'Trial seven: J is west of D. Match with trial five.',
                'Trial eight: X is east of Z. No match with trial six.',
                'Trial nine: D is east of J. Match with trial seven.',
                'Trial ten: Z is west of X. Match with trial eight.',
                'When a letter returns, reuse its concept and update by the new relation; keep coherence across trials.'
            ].join(' ');
        }

        function renderWalkthroughN2(mount = document.getElementById('instContent')) {
            if (!mount) return;

            const html = `
            <div id="walkthroughN2" class="inst-section">
                <h3>n-Back-2: 10-Trial Walkthrough</h3>

                <p class="brandline"><strong>Imagi-World trains maximized imagination across the Arc of Abstraction.</strong> You map lived concepts onto letters and move them North/South/East/West while the logic engine keeps relations exact.</p>

                <h4>Quick Algorithm (repeat this every premise)</h4>
                <ol class="algo">
                    <li><strong>Symbol ‚Üí</strong> Note the letter(s) in the current premise.</li>
                    <li><strong>Map a thought ‚Üí</strong> Anchor each new letter to a vivid concept (your stream of consciousness).</li>
                    <li><strong>Transform ‚Üí</strong> Apply the premise operation to that concept: North = up-shift (more general/intense); South = down-shift (more specific/concrete); East = analogue/sibling; West = opposite/counter-role.</li>
                    <li><strong>Pairing ‚Üí</strong> Record the resulting <em>letter ‚Üî thought</em> pairing for this trial.</li>
                    <li><strong>Rinse/Repeat ‚Üí</strong> For multi-atom premises, repeat for each relation in the utterance (semicolon = tiny pause).</li>
                    <li><strong>Recall & Update ‚Üí</strong> When a letter reappears later, reuse its prior mapping and <em>update</em> it by the new relation (e.g., if K is north of J, then when P is above K you can infer new context linking P and J, too).</li>
                </ol>

                <h4>Theme for this walkthrough</h4>
                <p>We use a coherent theme: <em>Illumination &amp; Understanding</em>. First-time anchors:</p>
                <ul class="anchors">
                    <li>J := Candle (steady light)</li>
                    <li>D := Fireworks (intense/brief light)</li>
                    <li>X := Observation (raw sighting)</li>
                    <li>Y := Generalization (above observations)</li>
                    <li>Z := Anomaly (foil to a typical observation)</li>
                </ul>

                <h4>Ten Trials at n-Back-2 (MATCH means current ‚â° trial t‚àí2 under allowed inversions)</h4>

                <ol class="trials">
                    <li>
                        <p><strong>Trial 1 ‚Äî Premise:</strong> D is north of J.</p>
                        <p><strong>Mapping:</strong> J=Candle; North ‚Üí D=Fireworks (up-shift intensity).</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 2 ‚Äî Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> X=Observation; Y=Generalization; West ‚Üí Z=Anomaly (foil to typical observation); South from Y confirms Z is specific.</p>
                        <p><strong>n-back-2:</strong> No comparison yet.</p>
                    </li>
                    <li>
                        <p><strong>Trial 3 ‚Äî Premise:</strong> J is south of D.</p>
                        <p><strong>Mapping:</strong> Reuse J=Candle, D=Fireworks; South means Candle is less intense than Fireworks.</p>
                        <p><strong>n-back-2 vs Trial 1:</strong> <span class="match">MATCH</span> (inverse: D north of J ‚Üî J south of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 4 ‚Äî Premise:</strong> X is east of Z; Y is north of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Y, Z; East: Observation is a sibling to Anomaly; North: Generalization above Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 2:</strong> <span class="match">MATCH</span> (Z west of X ‚Üî X east of Z; Z south of Y ‚Üî Y north of Z).</p>
                    </li>
                    <li>
                        <p><strong>Trial 5 ‚Äî Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; East: both are light sources (analogue). Optionally note D as "burst light".</p>
                        <p><strong>n-back-2 vs Trial 3:</strong> <span class="nomatch">NO MATCH</span> (Trial 3 was South; axis mismatch, not an allowed inversion).</p>
                    </li>
                    <li>
                        <p><strong>Trial 6 ‚Äî Premise:</strong> Z is west of X; Z is south of Y.</p>
                        <p><strong>Mapping:</strong> Same structure as Trial 2; reuse without re-anchoring.</p>
                        <p><strong>n-back-2 vs Trial 4:</strong> <span class="match">MATCH</span> (inverse pair of atoms holds).</p>
                    </li>
                    <li>
                        <p><strong>Trial 7 ‚Äî Premise:</strong> J is west of D.</p>
                        <p><strong>Mapping:</strong> Reuse J, D; West: Candle as counter to Fireworks (steady vs fleeting).</p>
                        <p><strong>n-back-2 vs Trial 5:</strong> <span class="match">MATCH</span> (D east of J ‚Üî J west of D).</p>
                    </li>
                    <li>
                        <p><strong>Trial 8 ‚Äî Premise:</strong> X is east of Z.</p>
                        <p><strong>Mapping:</strong> Reuse X, Z; East: Observation as sibling to Anomaly.</p>
                        <p><strong>n-back-2 vs Trial 6:</strong> <span class="nomatch">NO MATCH</span> (parity mismatch: k=1 vs k=2).</p>
                    </li>
                    <li>
                        <p><strong>Trial 9 ‚Äî Premise:</strong> D is east of J.</p>
                        <p><strong>Mapping:</strong> Reuse D, J; analogue relation sustained.</p>
                        <p><strong>n-back-2 vs Trial 7:</strong> <span class="match">MATCH</span> (inverse of Trial 7).</p>
                    </li>
                    <li>
                        <p><strong>Trial 10 ‚Äî Premise:</strong> Z is west of X.</p>
                        <p><strong>Mapping:</strong> Reuse Z, X; West: Anomaly as foil to Observation.</p>
                        <p><strong>n-back-2 vs Trial 8:</strong> <span class="match">MATCH</span> (inverse of Trial 8).</p>
                    </li>
                </ol>

                <h4>When the same letter returns: do this</h4>
                <ul class="returns">
                    <li><strong>Reuse</strong> the original concept; don't re-anchor.</li>
                    <li><strong>Check</strong> the new relation versus that concept (N up, S down, E analogue, W opposite).</li>
                    <li>If a letter must satisfy two relations, use a <em>compound nuance</em> ("chaotic example", "burst light") while keeping identity.</li>
                    <li><strong>Reframe</strong> only if the old choice breaks consistency across trials; if you reframe, note it.</li>
                    <li><strong>Infer context across letters:</strong> if K is north of J and P is above K, then P sits above J as well (transitively in your mental map). Keep your analogies coherent with such inferences while remembering the game's logical engine remains the final judge of matches.</li>
                </ul>

                <p class="closing"><strong>Mantra:</strong> Anchor ‚Üí Transform ‚Üí Cohere ‚Üí Commit ‚Üí Recall ‚Üí Update.</p>

                <div class="actions">
                    <button id="walkthroughN2Speak">Read this walkthrough aloud</button>
                    <button id="walkthroughN2Copy">Copy walkthrough text</button>
                </div>
            </div>
            `;

            mount.innerHTML = html;

            const speakBtn = mount.querySelector('#walkthroughN2Speak');
            const copyBtn = mount.querySelector('#walkthroughN2Copy');

            if (speakBtn) {
                speakBtn.addEventListener('click', () => {
                    if (typeof speakOnce === 'function') {
                        speakOnce(walkthroughN2SpeechText());
                    }
                });
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    const source = mount.querySelector('#walkthroughN2');
                    if (!source) return;
                    const text = source.innerText.trim();
                    try {
                        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                            await navigator.clipboard.writeText(text);
                        } else {
                            window.prompt('Copy this walkthrough text:', text);
                        }
                    } catch (err) {
                        console.warn('Clipboard write failed', err);
                        window.prompt('Copy this walkthrough text:', text);
                    }
                });
            }
        }

        (function registerWalkthroughN2Tab() {
            const tabs = document.getElementById('instTabs');
            if (!tabs) return;
            if (tabs.querySelector('button[data-tab="walkthrough-n2-10"]')) {
                return;
            }
            const btn = document.createElement('button');
            btn.textContent = 'n-Back-2: 10-Trial Walkthrough';
            btn.setAttribute('data-tab', 'walkthrough-n2-10');
            tabs.appendChild(btn);
        })();

        async function speakOnce(text) {
            if (!text) return;
            if (!engine || !engine.voice || !engine.voice.voiceReady) return;
            if (typeof engine.voice.cancelAndWait === 'function') {
                await engine.voice.cancelAndWait();
            }
            engine.voice.speak(text, engine.voice.sessionToken);
        }

        const SANDBOX_TRANSFORMS = {
            N: {
                forward: (value) => `Up-shift(${value})`,
                reverse: (value) => `Down-shift(${value})`
            },
            S: {
                forward: (value) => `Down-shift(${value})`,
                reverse: (value) => `Up-shift(${value})`
            },
            E: {
                forward: (value) => `Analogue(${value})`,
                reverse: (value) => `Analogue(${value})`
            },
            W: {
                forward: (value) => `Opposite(${value})`,
                reverse: (value) => `Opposite(${value})`
            }
        };

        const AdvancePolicy = Object.freeze({ ACTIVE: 'active', LISTEN: 'listen' });
        let session = null;

        function makeEpoch() {
            const cryptoSource = (typeof crypto !== 'undefined' && crypto?.getRandomValues)
                ? crypto.getRandomValues(new Uint32Array(1))[0]
                : Date.now();
            const random = Math.floor(Math.random() * 1e9);
            return (cryptoSource ^ random) >>> 0;
        }

        function newSession(engine) {
            return {
                epoch: makeEpoch(),
                numTrials: engine.applyNumTrialsFromUI(),
                trialIndex: 0,
                policy: loadListenOnly() ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                abort: new AbortController(),
                trialToken: 0,
                phaseToken: 0,
                omissions: 0
            };
        }

        function valid(sess, trialToken, phaseToken) {
            // CRITICAL FIX: More defensive validation with detailed logging
            if (!session) {
                // Don't log this - it's normal during session transitions
                return false;
            }
            if (!sess) {
                console.warn('valid() failed: sess parameter is null/undefined');
                return false;
            }
            if (sess.epoch !== session.epoch) {
                // Don't log this - it's normal when a new session starts
                return false;
            }
            if (trialToken !== session.trialToken) {
                console.warn(`valid() failed: trialToken mismatch - expected ${session.trialToken}, got ${trialToken}`);
                return false;
            }
            if (phaseToken && phaseToken !== session.phaseToken) {
                // Don't log phase mismatches - they're common during async operations
                return false;
            }
            if (sess.abort && sess.abort.signal && sess.abort.signal.aborted) {
                // Don't log this - it's normal when session is being stopped
                return false;
            }
            return true;
        }

        const SpeechGate = {
            trialSpeakId: 0,
            inFlight: false,
            explicitRepeatPhase: 0,
            flightToken: null
        };

        function resetSpeechGateForTrial() {
            SpeechGate.trialSpeakId += 1;
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
        }

        function noteExplicitRepeat() {
            SpeechGate.explicitRepeatPhase += 1;
        }

        const TTSMon = { starts: 0, ends: 0 };

        function instrumentUtterance(utterance) {
            if (!utterance || typeof utterance.addEventListener !== 'function') {
                return;
            }
            utterance.addEventListener('start', () => { TTSMon.starts += 1; });
            utterance.addEventListener('end', () => { TTSMon.ends += 1; });
        }

        if (typeof window !== 'undefined') {
            window.SpeechGate = SpeechGate;
            window.TTSMon = TTSMon;
        }

        const Timer = (() => {
            let id = 0;
            const live = new Map();

            function clear(timerId) {
                const entry = live.get(timerId);
                if (!entry) return;
                clearTimeout(entry.handle);
                live.delete(timerId);
            }

            function set(label, ms, trialToken, signal, cb) {
                const timerId = ++id;
                const handle = setTimeout(() => {
                    live.delete(timerId);
                    // Always call callback - validation should be done by caller if needed
                    if (cb) cb();
                }, ms);
                live.set(timerId, { handle, label, trialToken, started: performance.now() });
                if (signal) {
                    signal.addEventListener('abort', () => clear(timerId), { once: true });
                }
                return timerId;
            }

            function cancelAll() {
                for (const entry of live.values()) {
                    clearTimeout(entry.handle);
                }
                live.clear();
            }

            return { set, clear, cancelAll, live };
        })();

        let heartbeat = null;

        function clearHeartbeat() {
            if (heartbeat) {
                clearInterval(heartbeat);
                heartbeat = null;
            }
        }

        function loadNumTrials() {
            const v = parseInt(localStorage.getItem(NUM_TRIALS_KEY) || '20', 10);
            const clamped = Math.min(10000, Math.max(1, isNaN(v) ? 20 : v));
            numTrialsInput.value = String(clamped);
            numTrialsSlider.value = String(Math.min(500, clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            return clamped;
        }

        function persistNumTrials(v) {
            const clamped = Math.min(10000, Math.max(1, v | 0));
            localStorage.setItem(NUM_TRIALS_KEY, String(clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            if (clamped <= 500) numTrialsSlider.value = String(clamped);
            numTrialsInput.value = String(clamped);
            return clamped;
        }

        numTrialsInput.addEventListener('change', () => {
            const value = parseInt(numTrialsInput.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        numTrialsSlider.addEventListener('input', () => {
            const value = parseInt(numTrialsSlider.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        const initialNumTrials = loadNumTrials();

        function sessionDefaults() {
            return {
                state: "STOPPED",
                trialIndex: 0,
                numTrials: initialNumTrials,
                seedSession: null,
                n: parseInt(document.getElementById('n-slider').value, 10),
                k: parseInt(document.getElementById('k-slider').value, 10),
                secondsPerTrial: parseFloat(document.getElementById('spt-slider').value)
            };
        }


        function cryptoRandom32() {
            if (window.crypto && window.crypto.getRandomValues) {
                const arr = new Uint32Array(1);
                window.crypto.getRandomValues(arr);
                return arr[0] >>> 0;
            }

            let x = Date.now() ^ Math.floor(Math.random() * 0xffffffff);
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            return x >>> 0;
        }

        function fnv1aHash(parts) {
            let hash = 0x811c9dc5;
            for (const part of parts) {
                const value = (part >>> 0);
                hash ^= value;
                hash = Math.imul(hash, 0x01000193);
            }
            return hash >>> 0;
        }

        class Mulberry32 {
            constructor(seed) {
                this.state = seed >>> 0;
            }

            next() {
                let t = this.state += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }

            shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            weightedChoice(items, weights) {
                const cumulative = [];
                let total = 0;
                for (const weight of weights) {
                    total += weight;
                    cumulative.push(total);
                }
                const r = this.next() * total;
                for (let i = 0; i < cumulative.length; i++) {
                    if (r <= cumulative[i]) return items[i];
                }
                return items[items.length - 1];
            }

            nextBetween(min, max) {
                return min + (max - min) * this.next();
            }
        }

        class SeedManager {
            constructor() {
                this.runCounterKey = 'relational-nback-run-counter';
                this.seedKey = 'relational-nback-last-seed';
                this.lockKey = 'relational-nback-lock-seed';
                this.sessionSeed = null;
                this.runCounter = this.loadRunCounter();
            }

            loadRunCounter() {
                const raw = localStorage.getItem(this.runCounterKey);
                const parsed = raw ? parseInt(raw, 10) : 0;
                return Number.isFinite(parsed) ? parsed : 0;
            }

            getLockPreference() {
                return localStorage.getItem(this.lockKey) === 'true';
            }

            setLockPreference(lock) {
                localStorage.setItem(this.lockKey, lock ? 'true' : 'false');
            }

            incrementRunCounter() {
                this.runCounter += 1;
                localStorage.setItem(this.runCounterKey, String(this.runCounter));
                return this.runCounter;
            }

            generateSessionSeed(lockSeed) {
                if (lockSeed) {
                    const existing = localStorage.getItem(this.seedKey);
                    if (existing) {
                        this.sessionSeed = parseInt(existing, 10) >>> 0;
                        return this.sessionSeed;
                    }
                }

                const counter = this.incrementRunCounter();
                const random = cryptoRandom32();
                const salt = Date.now() >>> 0;
                const seed = fnv1aHash([counter, random, salt]);
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
                return seed;
            }

            persistSessionSeed(seed) {
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
            }
        }

        class DisjointSet {
            constructor(elements = []) {
                this.parent = new Map();
                this.rank = new Map();
                elements.forEach(e => this.makeSet(e));
            }

            makeSet(x) {
                if (!this.parent.has(x)) {
                    this.parent.set(x, x);
                    this.rank.set(x, 0);
                }
            }

            find(x) {
                if (!this.parent.has(x)) {
                    this.makeSet(x);
                }
                const parent = this.parent.get(x);
                if (parent !== x) {
                    const root = this.find(parent);
                    this.parent.set(x, root);
                    return root;
                }
                return x;
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX === rootY) return rootX;

                const rankX = this.rank.get(rootX) || 0;
                const rankY = this.rank.get(rootY) || 0;

                if (rankX < rankY) {
                    this.parent.set(rootX, rootY);
                    return rootY;
                } else if (rankX > rankY) {
                    this.parent.set(rootY, rootX);
                    return rootX;
                } else {
                    this.parent.set(rootY, rootX);
                    this.rank.set(rootX, rankX + 1);
                    return rootX;
                }
            }

            getSets() {
                const result = new Map();
                for (const key of this.parent.keys()) {
                    const root = this.find(key);
                    if (!result.has(root)) {
                        result.set(root, new Set());
                    }
                    result.get(root).add(key);
                }
                return result;
            }
        }

        class Atom {
            constructor(axis, head, tail) {
                this.axis = axis;
                this.head = head;
                this.tail = tail;
            }

            equals(other) {
                return this.axis === other.axis && this.head === other.head && this.tail === other.tail;
            }

            toString() {
                return `${this.head} is ${RELATION_WORDS[this.axis]} ${this.tail}`;
            }

            toKey() {
                return `${this.axis},${this.head},${this.tail}`;
            }

            static invert(atom) {
                const invMap = { N: 'S', S: 'N', E: 'W', W: 'E', NE: 'SW', SW: 'NE', SE: 'NW', NW: 'SE' };
                return new Atom(invMap[atom.axis], atom.tail, atom.head);
            }
        }

        class Premise {
            constructor(config) {
                if (Array.isArray(config)) {
                    // ATOMIC premise path (default and legacy)
                    // Can also be DIALECTIC, TENSOR, or HOMOLOGY based on structure
                    this.type = 'ATOMIC';
                    this.atoms = [...config].sort((a, b) => {
                        if (a.axis !== b.axis) return a.axis.localeCompare(b.axis);
                        if (a.head !== b.head) return a.head.localeCompare(b.head);
                        return a.tail.localeCompare(b.tail);
                    });
                    this.meta = null;
                    this.semanticPairs = null;

                    // Auto-detect DIALECTIC premise (2 atoms, same head/tail, different orthogonal axes)
                    if (config.length === 2 &&
                        config[0].head === config[1].head &&
                        config[0].tail === config[1].tail &&
                        config[0].axis !== config[1].axis) {
                        const axes = [config[0].axis, config[1].axis].sort();
                        // Check for orthogonal pairs (not opposites)
                        const orthogonalPairs = [['E','N'], ['E','S'], ['N','W'], ['S','W']];
                        if (orthogonalPairs.some(pair => axes[0] === pair[0] && axes[1] === pair[1])) {
                            this.type = 'DIALECTIC';
                        }
                    }

                    // Auto-detect TENSOR (Semantic Tensor) premise (2 atoms, same head, DIFFERENT orthogonal axes, different tails)
                    if (config.length === 2 &&
                        config[0].head === config[1].head &&
                        config[0].axis !== config[1].axis &&
                        config[0].tail !== config[1].tail) {
                        this.type = 'TENSOR';
                    }

                    // Auto-detect HOMOLOGY (System Homology) premise (3 atoms with hidden nodes)
                    // Structure: X‚ÜíA, Y‚ÜíB, X‚ÜíY where X,Y are hidden nodes (uppercase beyond normal range or special markers)
                    if (config.length === 3) {
                        const letters = new Set();
                        config.forEach(a => { letters.add(a.head); letters.add(a.tail); });
                        // If we have 4 unique letters and specific structure, mark as HOMOLOGY
                        // This is detected via metadata set during generation
                        // For now, leave as ATOMIC unless explicitly set
                    }
                } else if (config && config.type === 'META_RELATIONAL') {
                    // DEPRECATED (January 2025): META_RELATIONAL is the OLD Level 6 (operator analogies)
                    // Replaced by HOMOLOGY (NEW Level 6 with hidden nodes)
                    // This code path is preserved for backward compatibility but is no longer accessible via UI
                    // The OLD Level 6 can only be accessed by manually setting type='META_RELATIONAL'
                    this.type = 'META_RELATIONAL';
                    this.atoms = [];  // Always ensure atoms is an array (empty for META)

                    // Validate META operators
                    const validOps = ['North', 'South', 'East', 'West'];
                    const p = config.p || [];

                    // Must be even number (pairs) and at least 4 (minimum 2 pairs for analogy)
                    if (!Array.isArray(p) || p.length < 4 || p.length % 2 !== 0) {
                        console.error('Invalid META premise: operators must be even array with min 4', p);
                        throw new Error(`Invalid META premise: expected even count >= 4, got ${p.length}`);
                    }

                    // Verify all operators are valid
                    const invalid = p.filter(op => !validOps.includes(op));
                    if (invalid.length > 0) {
                        console.error('Invalid META operators:', invalid);
                        throw new Error(`Invalid META operators: ${invalid.join(', ')}`);
                    }

                    // Note: Operators CAN repeat for k>2 (e.g., "North to South as North to East")

                    this.meta = {
                        p: [...p]  // Clone array
                    };
                } else {
                    console.error('Invalid Premise constructor argument:', config);
                    throw new Error('Invalid Premise constructor argument');
                }

                try {
                    this.features = this.computeFeatures();
                } catch (err) {
                    console.error('Failed to compute features for premise:', err);
                    // Provide default features to prevent crashes
                    this.features = {
                        lettersSet: new Set(),
                        degreeVector: new Map(),
                        skeletonIsoSignature: this.type.includes('META') ? 'META_ISO' : 'ERROR',
                        atomAxisProfile: new Map()
                    };
                }
            }

            // Method to explicitly set type (for HOMOLOGY and INTERFACE premises where auto-detection is insufficient)
            setType(type) {
                // DEPRECATED: META_RELATIONAL is the OLD Level 6 (operator analogies like "N to S as E to W")
                // It has been replaced by HOMOLOGY (NEW Level 6 with hidden nodes)
                // META_RELATIONAL is preserved for backward compatibility but is no longer accessible via UI
                const validTypes = ['ATOMIC', 'DIALECTIC', 'TENSOR', 'HOMOLOGY', 'INTERFACE', 'META_RELATIONAL'];
                if (validTypes.includes(type)) {
                    this.type = type;
                }
            }

            // Method to store hidden node metadata for HOMOLOGY premises
            setHomologyMetadata(visibleNodes, hiddenNodes) {
                this.homologyMeta = {
                    visible: visibleNodes,
                    hidden: hiddenNodes
                };
            }

            // Method to store metadata for INTERFACE premises
            setInterfaceMetadata(metadata) {
                // metadata: { roots, intermediates, endpoints, pathA, pathB, interfaceAxis }
                this.interfaceMeta = metadata;
            }

            getLetters() {
                if (this.type === 'META_RELATIONAL') {
                    return new Set(this.meta.p);
                }
                const letters = new Set();
                this.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            computeFeatures() {
                if (this.type === 'META_RELATIONAL') {
                    return {
                        lettersSet: this.getLetters(),
                        degreeVector: new Map(),
                        skeletonIsoSignature: 'META_ISO',
                        atomAxisProfile: new Map()
                    };
                }

                const lettersSet = new Set();
                const degreeVector = new Map();
                const axisProfile = new Map();
                const indexMap = {
                    N: [0, 1],
                    S: [2, 3],
                    E: [4, 5],
                    W: [6, 7]
                };

                const ensureVector = (letter) => {
                    if (!degreeVector.has(letter)) {
                        degreeVector.set(letter, [0, 0, 0, 0, 0, 0, 0, 0]);
                    }
                    return degreeVector.get(letter);
                };

                this.atoms.forEach(atom => {
                    lettersSet.add(atom.head);
                    lettersSet.add(atom.tail);

                    const [outIdx, inIdx] = indexMap[atom.axis];
                    const headVec = ensureVector(atom.head);
                    headVec[outIdx] += 1;
                    const tailVec = ensureVector(atom.tail);
                    tailVec[inIdx] += 1;

                    axisProfile.set(atom.axis, (axisProfile.get(atom.axis) || 0) + 1);
                });

                return {
                    lettersSet,
                    degreeVector,
                    skeletonIsoSignature: this.isoSignature(),
                    atomAxisProfile: axisProfile
                };
            }

            getFeatures() {
                return this.features;
            }

            atomKeys() {
                if (this.type === 'META_RELATIONAL') {
                    return [this.toKey()];
                }
                return this.atoms.map(atom => atom.toKey());
            }

            toKey() {
                if (this.type === 'META_RELATIONAL') {
                    return `META:${this.meta.p.join(',')}`;
                }
                return this.atomKeys().join('|');
            }

            toString() {
                if (this.type === 'META_RELATIONAL') {
                    const ops = this.meta.p;
                    const pairs = [];
                    for (let i = 0; i < ops.length; i += 2) {
                        pairs.push(`${ops[i]} to ${ops[i + 1]}`);
                    }
                    return pairs.join(' as ');
                }

                // DIALECTIC: "A is North and West of B"
                if (this.type === 'DIALECTIC' && this.atoms.length === 2) {
                    const a = this.atoms[0];
                    // Extract direction words WITHOUT "of" suffix to prevent grammatical redundancy
                    // Input: ['north of', 'west of'] ‚Üí Output: ['north', 'west'] ‚Üí "north and west of B"
                    const directions = this.atoms.map(atom => {
                        const fullRelation = RELATION_WORDS[atom.axis] || atom.axis;
                        // Remove " of" from the end of each direction word
                        return fullRelation.replace(/ of$/, '');
                    }).join(' and ');
                    // Add "of" ONCE at the end for correct grammar
                    return `${a.head} is ${directions} of ${a.tail}`;
                }

                // TENSOR (Semantic Tensor): "A is north of B and east of C"
                if (this.type === 'TENSOR' && this.atoms.length === 2) {
                    const head = this.atoms[0].head;
                    const axis1 = RELATION_WORDS[this.atoms[0].axis] || this.atoms[0].axis;
                    const tail1 = this.atoms[0].tail;
                    const axis2 = RELATION_WORDS[this.atoms[1].axis] || this.atoms[1].axis;
                    const tail2 = this.atoms[1].tail;
                    return `${head} is ${axis1} ${tail1} and ${axis2} ${tail2}`;
                }

                // HOMOLOGY (System Homology): "(North of A) is East of (North of B)"
                // This reveals meta-structural equivalence between domains
                if (this.type === 'HOMOLOGY' && this.atoms.length === 3 && this.homologyMeta) {
                    const visibleNodes = this.homologyMeta.visible || [];
                    const hiddenNodes = this.homologyMeta.hidden || [];

                    // Find the atoms connecting to visible nodes (X‚ÜíA and Y‚ÜíB)
                    const atom1 = this.atoms.find(a => visibleNodes.includes(a.tail));
                    const atom2 = this.atoms.find(a => visibleNodes.includes(a.tail) && a !== atom1);
                    // Find the atom connecting hidden nodes (X‚ÜíY)
                    const atom3 = this.atoms.find(a => !visibleNodes.includes(a.tail) && !visibleNodes.includes(a.head));

                    if (atom1 && atom2 && atom3) {
                        const dir1 = RELATION_WORDS[atom1.axis] || atom1.axis;
                        const dir2 = RELATION_WORDS[atom2.axis] || atom2.axis;
                        const dir3 = RELATION_WORDS[atom3.axis] || atom3.axis;
                        return `(${dir1} ${atom1.tail}) is ${dir3} (${dir2} ${atom2.tail})`;
                    }
                }

                // INTERFACE (Complementary Interface): "(Path1 of Root1) is Interface of (Path2 of Root2)"
                // Example: "(North-West of A) is West of (South-East of B)"
                if (this.type === 'INTERFACE') {
                    if (!this.interfaceMeta) {
                        // Fallback if metadata missing
                        return this.atoms.map(a => `${a.head} is ${RELATION_WORDS[a.axis]} ${a.tail}`).join('; ');
                    }

                    const meta = this.interfaceMeta;
                    const [rootA, rootB] = meta.roots;
                    const interfaceAxisWord = RELATION_WORDS[meta.interfaceAxis];

                    // Convert axis codes to full words and capitalize properly
                    const pathA_word1 = RELATION_WORDS[meta.pathA.axis1].replace(' of', ''); // "north"
                    const pathA_word2 = RELATION_WORDS[meta.pathA.axis2].replace(' of', ''); // "west"
                    const pathADescriptor = `${pathA_word1.charAt(0).toUpperCase() + pathA_word1.slice(1)}-${pathA_word2.charAt(0).toUpperCase() + pathA_word2.slice(1)}`;

                    const pathB_word1 = RELATION_WORDS[meta.pathB.axis1].replace(' of', ''); // "south"
                    const pathB_word2 = RELATION_WORDS[meta.pathB.axis2].replace(' of', ''); // "east"
                    const pathBDescriptor = `${pathB_word1.charAt(0).toUpperCase() + pathB_word1.slice(1)}-${pathB_word2.charAt(0).toUpperCase() + pathB_word2.slice(1)}`;

                    // Format: "(PathA of RootA) is InterfaceAxis of (PathB of RootB)"
                    return `(${pathADescriptor} of ${rootA}) is ${interfaceAxisWord} (${pathBDescriptor} of ${rootB})`;
                }

                // Default ATOMIC rendering
                return this.atoms.map(a => a.toString()).join('; ');
            }

            toNaturalSpeech() {
                if (this.type === 'META_RELATIONAL') {
                    const ops = this.meta.p;
                    const pairs = [];
                    for (let i = 0; i < ops.length; i += 2) {
                        pairs.push(`${ops[i]} to ${ops[i + 1]}`);
                    }
                    return pairs.join('... as ') + '.';
                }

                // DIALECTIC: "A is north and west of B"
                if (this.type === 'DIALECTIC' && this.atoms.length === 2) {
                    const a = this.atoms[0];
                    const directions = this.atoms.map(atom => RELATION_WORDS[atom.axis] || atom.axis).join(' and ');
                    return `${a.head} is ${directions} ${a.tail}.`;
                }

                // TENSOR (Semantic Tensor): "A is north of B and east of C"
                if (this.type === 'TENSOR' && this.atoms.length === 2) {
                    const head = this.atoms[0].head;
                    const axis1 = RELATION_WORDS[this.atoms[0].axis] || this.atoms[0].axis;
                    const tail1 = this.atoms[0].tail;
                    const axis2 = RELATION_WORDS[this.atoms[1].axis] || this.atoms[1].axis;
                    const tail2 = this.atoms[1].tail;
                    return `${head} is ${axis1} ${tail1} and ${axis2} ${tail2}.`;
                }

                // HOMOLOGY: "north of A is east of south of B"
                if (this.type === 'HOMOLOGY' && this.atoms.length === 3 && this.homologyMeta) {
                    const visibleNodes = this.homologyMeta.visible || [];

                    // Find the atoms
                    const atom1 = this.atoms.find(a => visibleNodes.includes(a.tail));
                    const atom2 = this.atoms.find(a => visibleNodes.includes(a.tail) && a !== atom1);
                    const atom3 = this.atoms.find(a => !visibleNodes.includes(a.tail) && !visibleNodes.includes(a.head));

                    if (atom1 && atom2 && atom3) {
                        const dir1 = RELATION_WORDS[atom1.axis] || atom1.axis;
                        const dir2 = RELATION_WORDS[atom2.axis] || atom2.axis;
                        const dir3 = RELATION_WORDS[atom3.axis] || atom3.axis;
                        return `${dir1} ${atom1.tail} is ${dir3} ${dir2} ${atom2.tail}.`;
                    }
                }

                // INTERFACE: "north-west of A is west of south-east of B"
                if (this.type === 'INTERFACE') {
                    if (!this.interfaceMeta) {
                        return this.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('. ') + '.';
                    }

                    const meta = this.interfaceMeta;
                    const [rootA, rootB] = meta.roots;
                    const interfaceAxisWord = RELATION_WORDS[meta.interfaceAxis];

                    // Convert axis codes to full words (lowercase for speech)
                    const pathA_word1 = RELATION_WORDS[meta.pathA.axis1].replace(' of', ''); // "north"
                    const pathA_word2 = RELATION_WORDS[meta.pathA.axis2].replace(' of', ''); // "west"
                    const pathAWords = `${pathA_word1}-${pathA_word2}`;

                    const pathB_word1 = RELATION_WORDS[meta.pathB.axis1].replace(' of', ''); // "south"
                    const pathB_word2 = RELATION_WORDS[meta.pathB.axis2].replace(' of', ''); // "east"
                    const pathBWords = `${pathB_word1}-${pathB_word2}`;

                    return `${pathAWords} of ${rootA} is ${interfaceAxisWord} ${pathBWords} of ${rootB}.`;
                }

                // Default ATOMIC rendering
                return this.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ') + '.';
            }

            mirrorKey() {
                if (this.type === 'META_RELATIONAL') {
                    // For META premises, canonical form is the sorted version
                    const key1 = this.toKey();
                    const reversed = [...this.meta.p].reverse();
                    const key2 = `META:${reversed.join(',')}`;
                    return key1 < key2 ? key1 : key2;
                }
                const canonicalAtoms = this.atoms.map(atom => {
                    const inverted = Atom.invert(atom);
                    const current = `${atom.axis}|${atom.head}|${atom.tail}`;
                    const flipped = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return current < flipped ? current : flipped;
                }).sort();
                return canonicalAtoms.join('|');
            }

            isoSignature() {
                if (this.type === 'META_RELATIONAL') {
                    return 'META_ISO';
                }
                const letterMap = new Map();
                let nextCharCode = 'a'.charCodeAt(0);
                const normalized = this.atoms.map(atom => {
                    if (!letterMap.has(atom.head)) {
                        letterMap.set(atom.head, String.fromCharCode(nextCharCode++));
                    }
                    if (!letterMap.has(atom.tail)) {
                        letterMap.set(atom.tail, String.fromCharCode(nextCharCode++));
                    }
                    const headNorm = letterMap.get(atom.head);
                    const tailNorm = letterMap.get(atom.tail);
                    const normalizedAtom = new Atom(atom.axis, headNorm, tailNorm);
                    const inverted = Atom.invert(normalizedAtom);
                    const keyCurrent = `${normalizedAtom.axis}|${normalizedAtom.head}|${normalizedAtom.tail}`;
                    const keyInv = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return keyCurrent < keyInv ? keyCurrent : keyInv;
                });
                return normalized.sort().join('|');
            }
        }

        class NoveltyManager {
            constructor(windowSize = HAMMING_WINDOW, firstN = FIRST_N_NOVELTY) {
                this.windowSize = windowSize;
                this.firstN = firstN;
                this.seenExact = new Set();
                this.seenMirror = new Set();
                this.seenIso = new Set();
                this.history = [];
            }

            buildSignatures(premise) {
                return {
                    exact: premise.toKey(),
                    mirror: premise.mirrorKey(),
                    iso: premise.isoSignature(),
                    atoms: premise.atomKeys()
                };
            }

            computeHamming(atoms) {
                if (this.history.length === 0) return this.windowSize;
                const freq1 = this.buildFrequencyMap(atoms);
                let total = 0;
                const limit = Math.min(this.windowSize, this.history.length);
                for (let i = 0; i < limit; i++) {
                    const other = this.history[this.history.length - 1 - i];
                    const freq2 = other.frequency;
                    const allKeys = new Set([...freq1.keys(), ...freq2.keys()]);
                    let diff = 0;
                    allKeys.forEach(key => {
                        diff += Math.abs((freq1.get(key) || 0) - (freq2.get(key) || 0));
                    });
                    total += diff;
                }
                return total / limit;
            }

            buildFrequencyMap(atoms) {
                const freq = new Map();
                atoms.forEach(key => {
                    freq.set(key, (freq.get(key) || 0) + 1);
                });
                return freq;
            }

            evaluate(premise, signatures, trialIndex) {
                const exactHit = this.seenExact.has(signatures.exact);
                if (exactHit) {
                    return {
                        blocked: true,
                        reason: 'exact-repeat',
                        penalty: Infinity,
                        noveltyScores: { exact: 1, mirror: 0, iso: 0, hamming: 0 }
                    };
                }

                const mirrorHit = this.seenMirror.has(signatures.mirror);
                const isoHit = this.seenIso.has(signatures.iso);
                const hamming = this.computeHamming(signatures.atoms);

                const noveltyScores = {
                    exact: mirrorHit ? 1 : 0,
                    mirror: mirrorHit ? 1 : 0,
                    iso: isoHit ? 1 : 0,
                    hamming
                };

                if (trialIndex < this.firstN && (mirrorHit || isoHit)) {
                    return {
                        blocked: true,
                        reason: 'novelty-mode',
                        penalty: Infinity,
                        noveltyScores
                    };
                }

                let penalty = 0;
                if (mirrorHit) penalty += 1;
                if (isoHit) penalty += 2;

                return {
                    blocked: false,
                    penalty,
                    noveltyScores
                };
            }

            register(signatures) {
                this.seenExact.add(signatures.exact);
                this.seenMirror.add(signatures.mirror);
                this.seenIso.add(signatures.iso);
                this.history.push({
                    signature: signatures.exact,
                    frequency: this.buildFrequencyMap(signatures.atoms)
                });
                if (this.history.length > this.windowSize) {
                    this.history.shift();
                }
            }

            reset() {
                this.seenExact.clear();
                this.seenMirror.clear();
                this.seenIso.clear();
                this.history = [];
            }
        }

        class LetterPoolManager {
            constructor(allLetters, rng, usageTracker) {
                this.allLetters = allLetters;
                this.rng = rng;
                this.usageTracker = usageTracker;
                this.currentPool = [];
            }

            getUsage(letter) {
                const usage = this.usageTracker.get(letter);
                if (!usage) return 0;
                return usage.head + usage.tail;
            }

            sampleLetters(count, candidates = this.allLetters) {
                const available = candidates.filter(l => !this.currentPool.includes(l));
                const selection = [];
                const pool = [...available];
                while (selection.length < count && pool.length > 0) {
                    const weights = pool.map(letter => 1 / (1 + this.getUsage(letter)));
                    const choice = this.rng.weightedChoice(pool, weights);
                    selection.push(choice);
                    const index = pool.indexOf(choice);
                    pool.splice(index, 1);
                }
                return selection;
            }

            nextPool(k, options = {}) {
                const { expand = false } = options;
                const min = k + 1;
                const max = Math.min(6, 2 * k + 2);
                const targetSize = Math.max(min, Math.min(max, (this.currentPool.length || min) + (expand ? 1 : 0)));

                if (this.currentPool.length === 0) {
                    const letters = this.rng.shuffle(this.allLetters).slice(0, targetSize);
                    this.currentPool = letters;
                    return this.currentPool;
                }

                const drift = expand ? 0.5 : this.rng.nextBetween(0.3, 0.5);
                const keepCount = Math.max(min, Math.round(targetSize * (1 - drift)));
                const orderedByUsage = [...this.currentPool].sort((a, b) => this.getUsage(a) - this.getUsage(b));
                const keep = orderedByUsage.slice(0, keepCount);
                const needed = targetSize - keep.length;
                const candidates = this.allLetters.filter(letter => !keep.includes(letter));
                const additions = this.sampleLetters(needed, candidates);
                this.currentPool = this.rng.shuffle([...keep, ...additions]);
                return this.currentPool;
            }
        }

        function collectLetters(atoms) {
            const set = new Set();
            atoms.forEach(atom => {
                set.add(atom.head);
                set.add(atom.tail);
            });
            return set;
        }

        function addEdge(map, from, to) {
            if (!map.has(from)) {
                map.set(from, new Set());
            }
            map.get(from).add(to);
        }

        function topologicalAssign(nodes, edges) {
            const indegree = new Map();
            nodes.forEach(node => indegree.set(node, 0));
            edges.forEach((targets, source) => {
                targets.forEach(target => {
                    indegree.set(target, (indegree.get(target) || 0) + 1);
                });
            });

            const queue = [];
            indegree.forEach((degree, node) => {
                if (degree === 0) queue.push(node);
            });

            const order = [];
            while (queue.length > 0) {
                const node = queue.shift();
                order.push(node);
                const neighbors = edges.get(node);
                if (!neighbors) continue;
                neighbors.forEach(neighbor => {
                    indegree.set(neighbor, indegree.get(neighbor) - 1);
                    if (indegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            if (order.length !== nodes.length) {
                return { cycle: true, values: new Map() };
            }

            const values = new Map();
            order.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
                const base = values.get(node);
                const neighbors = edges.get(node);
                if (!neighbors) return;
                neighbors.forEach(neighbor => {
                    const current = values.get(neighbor) || 0;
                    const candidate = Math.max(current, base + 1);
                    values.set(neighbor, candidate);
                });
            });

            nodes.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
            });

            return { cycle: false, values };
        }

        function buildReachability(nodes, edges) {
            const reach = new Map();
            nodes.forEach(node => {
                const visited = new Set();
                const stack = [node];
                while (stack.length) {
                    const current = stack.pop();
                    const neighbors = edges.get(current);
                    if (!neighbors) continue;
                    neighbors.forEach(next => {
                        if (!visited.has(next)) {
                            visited.add(next);
                            stack.push(next);
                        }
                    });
                }
                reach.set(node, visited);
            });
            return reach;
        }

        class ConstraintSolver {
            isDialecticalPremise(atoms) {
                // Detect dialectical premises: 2 atoms, same head/tail pair, orthogonal axes
                if (atoms.length !== 2) return false;
                const atom1 = atoms[0];
                const atom2 = atoms[1];
                const samePair = (atom1.head === atom2.head && atom1.tail === atom2.tail);
                const orthogonal = this.areOrthogonal(atom1.axis, atom2.axis);
                return samePair && orthogonal;
            }

            areOrthogonal(axis1, axis2) {
                // Check if two axes are orthogonal (one vertical, one horizontal)
                const vertical = new Set(['N', 'S']);
                const horizontal = new Set(['E', 'W']);
                return (vertical.has(axis1) && horizontal.has(axis2)) ||
                       (horizontal.has(axis1) && vertical.has(axis2));
            }

            analyze(allAtoms) {
                // DIALECTICAL BYPASS: Skip union-find collision checking for dialectical premises
                // Dialectical premises (2 atoms, same head/tail, orthogonal axes) are geometrically valid
                // but trigger false-positive collisions in the union-find phase.
                // Example: [N, A, B] + [W, A, B] means "A is north and west of B" (valid)
                // but union-find interprets this as A.y === B.y (from W) AND A.y > B.y (from N) (contradiction)
                if (this.isDialecticalPremise(allAtoms)) {
                    console.log('[ConstraintSolver] Dialectical premise detected - bypassing union-find validation');

                    const letters = collectLetters(allAtoms);
                    const coordinates = new Map();

                    // Extract the head and tail from the atoms
                    const head = allAtoms[0].head;
                    const tail = allAtoms[0].tail;

                    // Assign coordinates that satisfy both orthogonal relations
                    // For any orthogonal pair of axes, we can place head at (0,1) and tail at (1,0)
                    // This guarantees:
                    // - If N relation: head.y > tail.y ‚úì (1 > 0)
                    // - If S relation: head.y < tail.y ‚úì (1 < 0 would need swap)
                    // - If E relation: head.x > tail.x ‚úì (0 > 1 would need swap)
                    // - If W relation: head.x < tail.x ‚úì (0 < 1)

                    // Determine coordinate assignment based on axes
                    const atom1 = allAtoms[0];
                    const atom2 = allAtoms[1];

                    let headX = 0, headY = 0, tailX = 0, tailY = 0;

                    // Process first atom
                    if (atom1.axis === 'N') {
                        headY = 1; tailY = 0;
                    } else if (atom1.axis === 'S') {
                        headY = 0; tailY = 1;
                    } else if (atom1.axis === 'E') {
                        headX = 1; tailX = 0;
                    } else if (atom1.axis === 'W') {
                        headX = 0; tailX = 1;
                    }

                    // Process second atom (orthogonal)
                    if (atom2.axis === 'N') {
                        headY = 1; tailY = 0;
                    } else if (atom2.axis === 'S') {
                        headY = 0; tailY = 1;
                    } else if (atom2.axis === 'E') {
                        headX = 1; tailX = 0;
                    } else if (atom2.axis === 'W') {
                        headX = 0; tailX = 1;
                    }

                    coordinates.set(head, { x: headX, y: headY });
                    coordinates.set(tail, { x: tailX, y: tailY });

                    console.log('[ConstraintSolver] Dialectical premise validated successfully:', {
                        atoms: allAtoms.map(a => `${a.axis}: ${a.head}->${a.tail}`),
                        coordinates: Array.from(coordinates.entries()).map(([letter, coord]) => `${letter}:(${coord.x},${coord.y})`)
                    });

                    return {
                        ok: true,
                        coordinates,
                        ufX: new DisjointSet(letters),
                        ufY: new DisjointSet(letters),
                        graphX: new Map(),
                        graphY: new Map(),
                        nodesX: Array.from(letters),
                        nodesY: Array.from(letters)
                    };
                }

                // ORIGINAL LOGIC continues below for non-dialectical premises
                const letters = collectLetters(allAtoms);
                const ufX = new DisjointSet(letters);
                const ufY = new DisjointSet(letters);

                const graphX = new Map();
                const graphY = new Map();

                for (const atom of allAtoms) {
                    if (atom.axis === 'N' || atom.axis === 'S') {
                        ufX.union(atom.head, atom.tail);
                    } else {
                        ufY.union(atom.head, atom.tail);
                    }
                }

                for (const atom of allAtoms) {
                    if (atom.axis === 'N') {
                        const lesser = ufY.find(atom.tail);
                        const greater = ufY.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'S') {
                        const lesser = ufY.find(atom.head);
                        const greater = ufY.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'E') {
                        const lesser = ufX.find(atom.tail);
                        const greater = ufX.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    } else if (atom.axis === 'W') {
                        const lesser = ufX.find(atom.head);
                        const greater = ufX.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    }
                }

                const nodesX = Array.from(new Set([...graphX.keys(), ...Array.from(graphX.values()).flat()]));
                ufX.parent.forEach((_, letter) => nodesX.push(ufX.find(letter)));
                const uniqueNodesX = Array.from(new Set(nodesX));

                const nodesY = Array.from(new Set([...graphY.keys(), ...Array.from(graphY.values()).flat()]));
                ufY.parent.forEach((_, letter) => nodesY.push(ufY.find(letter)));
                const uniqueNodesY = Array.from(new Set(nodesY));

                const assignX = topologicalAssign(uniqueNodesX, graphX);
                if (assignX.cycle) {
                    return { ok: false, reason: 'horizontal-cycle' };
                }

                const assignY = topologicalAssign(uniqueNodesY, graphY);
                if (assignY.cycle) {
                    return { ok: false, reason: 'vertical-cycle' };
                }

                const coordinates = new Map();
                letters.forEach(letter => {
                    const xRep = ufX.find(letter);
                    const yRep = ufY.find(letter);
                    const x = assignX.values.get(xRep) || 0;
                    const y = assignY.values.get(yRep) || 0;
                    coordinates.set(letter, { x, y });
                });

                return {
                    ok: true,
                    coordinates,
                    ufX,
                    ufY,
                    graphX,
                    graphY,
                    nodesX: uniqueNodesX,
                    nodesY: uniqueNodesY
                };
            }

            evaluate(windowAtoms, candidateAtoms) {
                return this.analyze([...windowAtoms, ...candidateAtoms]);
            }
        }

        class EquivalenceEngine {
            constructor(transitivityEnabled = false) {
                this.transitivityEnabled = transitivityEnabled;
            }

            setTransitivity(enabled) {
                this.transitivityEnabled = enabled;
            }

            /**
             * Detects if a premise uses compound operators (Level 7-8).
             * Compound operators contain hyphens (e.g., "NE-SW", "N-S").
             * @param {Premise} premise - The premise to check
             * @returns {boolean} True if premise contains compound operators
             */
            isCompoundOperatorPremise(premise) {
                // META premises never use compound operators
                if (!premise || premise.type === 'META_RELATIONAL') {
                    return false;
                }

                // Check if any atom has compound operators in head or tail
                if (!premise.atoms || premise.atoms.length === 0) {
                    return false;
                }

                return premise.atoms.some(atom =>
                    (atom.head && atom.head.includes('-')) ||
                    (atom.tail && atom.tail.includes('-'))
                );
            }

            lettersOf(premise) {
                const letters = new Set();

                // META premises don't have atoms in the same way
                if (premise.type === 'META_RELATIONAL') {
                    if (premise.meta && premise.meta.p) {
                        premise.meta.p.forEach(op => letters.add(op));
                    }
                    return letters;
                }

                // ATOMIC premises
                if (premise.atoms && Array.isArray(premise.atoms)) {
                    premise.atoms.forEach(atom => {
                        if (atom && atom.head && atom.tail) {
                            letters.add(atom.head);
                            letters.add(atom.tail);
                        }
                    });
                }
                return letters;
            }

            computeInvertibleMapping(atomsA, atomsB) {
                const mapping = [];
                const used = new Set();

                const search = (index) => {
                    if (index === atomsA.length) return true;
                    for (let j = 0; j < atomsB.length; j++) {
                        if (used.has(j)) continue;
                        if (atomsA[index].equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: false });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                        const inverted = Atom.invert(atomsA[index]);
                        if (inverted.equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: true });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                    }
                    return false;
                };

                const ok = search(0);
                return ok ? mapping.slice() : null;
            }

            analyzeMidWindow(midAtoms) {
                if (!midAtoms || midAtoms.length === 0) {
                    return { ok: false };
                }
                const solver = new ConstraintSolver();
                const analysis = solver.analyze(midAtoms);
                if (!analysis.ok) {
                    return { ok: false };
                }
                const reachX = buildReachability(analysis.nodesX, analysis.graphX);
                const reachY = buildReachability(analysis.nodesY, analysis.graphY);
                return { ok: true, analysis, reachX, reachY };
            }

            isDerivableFromMid(atom, midInfo) {
                if (!midInfo.ok) return false;
                const { analysis, reachX, reachY } = midInfo;
                if (atom.axis === 'N') {
                    const lesser = analysis.ufY.find(atom.tail);
                    const greater = analysis.ufY.find(atom.head);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'S') {
                    const lesser = analysis.ufY.find(atom.head);
                    const greater = analysis.ufY.find(atom.tail);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'E') {
                    const lesser = analysis.ufX.find(atom.tail);
                    const greater = analysis.ufX.find(atom.head);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'W') {
                    const lesser = analysis.ufX.find(atom.head);
                    const greater = analysis.ufX.find(atom.tail);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                return false;
            }

            Equivalent(premA, premB, windowAtoms = [], midAtoms = []) {
                const atomsA = premA.atoms;
                const atomsB = premB.atoms;

                if (atomsA.length !== atomsB.length) {
                    return { ok: false, reason: 'parity' };
                }

                const mapping = this.computeInvertibleMapping(atomsA, atomsB);
                // Allow non-invertible mapping if Transitivity is on, to enable A->C derivable from A->B
                if (!mapping && !this.transitivityEnabled) {
                    return { ok: false, reason: 'mapping' };
                }

                // CRITICAL: Detect compound operator premises (Levels 7-8)
                // Compound operators are abstract units that don't obey spatial semantics
                const isCompoundA = this.isCompoundOperatorPremise(premA);
                const isCompoundB = this.isCompoundOperatorPremise(premB);
                const isCompoundOperatorPair = isCompoundA || isCompoundB;

                // Shared anchors check: SKIP for compound operators (Levels 7-8)
                // Compound operators like "NE-SW" and "SW-NE" are different symbols
                // but may represent equivalent abstract relations - they don't share "letters"
                // in the spatial sense, so the anchors check is semantically invalid.
                if (!isCompoundOperatorPair) {
                    // Only perform shared anchors check for Levels 1-6
                    const lettersA = this.lettersOf(premA);
                    const lettersB = this.lettersOf(premB);
                    const shared = new Set();
                    lettersA.forEach(letter => {
                        if (lettersB.has(letter)) {
                            shared.add(letter);
                        }
                    });
                    if (shared.size < 2) {
                        return { ok: false, reason: 'anchors' };
                    }
                }

                // Constraint solver: SKIP for compound operators (Levels 7-8)
                // The ConstraintSolver enforces spatial consistency (N/S/E/W axes).
                // Compound operators are abstract symbols without spatial semantics,
                // so constraint solving produces meaningless results and false rejections.
                if (!isCompoundOperatorPair) {
                    // Only perform constraint solving for Levels 1-6
                    const solver = new ConstraintSolver();
                    const satResult = solver.analyze([...windowAtoms, ...atomsA, ...atomsB]);
                    if (!satResult.ok) {
                        return { ok: false, reason: 'sat' };
                    }
                }

                // Compute shared letters for certificate (even if we skipped anchors check)
                const lettersA = this.lettersOf(premA);
                const lettersB = this.lettersOf(premB);
                const shared = new Set();
                lettersA.forEach(letter => {
                    if (lettersB.has(letter)) {
                        shared.add(letter);
                    }
                });

                const midInfo = this.analyzeMidWindow(midAtoms);
                if (midInfo.ok) {
                    for (const atom of [...atomsA, ...atomsB]) {
                        if (this.isDerivableFromMid(atom, midInfo) || this.isDerivableFromMid(Atom.invert(atom), midInfo)) {
                            return {
                                ok: false,
                                reason: 'mid-window-derivable',
                                mapping,
                                sharedLetters: Array.from(shared),
                                midWindowDerivable: true
                            };
                        }
                    }
                }

                return {
                    ok: true,
                    type: 'invertible',
                    mapping,
                    sharedLetters: Array.from(shared),
                    midWindowDerivable: false
                };
            }

            /**
             * Detects if a premise is dialectical type (Mode 1).
             * Dialectical premises: 2 atoms, same head/tail pair, orthogonal axes
             * Example: [N, A, B] + [W, A, B] = "A is North and West of B"
             * @param {Premise} premise - The premise to check
             * @returns {boolean} True if premise is dialectical type
             */
            isDialecticalPremise(premise) {
                // Detect dialectical premises: 2 atoms, same head/tail pair, orthogonal axes
                // Example: [N, A, B] + [W, A, B] = "A is North and West of B"
                if (!premise || !premise.atoms || premise.atoms.length !== 2) return false;

                const a1 = premise.atoms[0];
                const a2 = premise.atoms[1];

                // Check if both atoms use the same letter pair (same head and same tail)
                const samePair = (a1.head === a2.head && a1.tail === a2.tail);

                // Check if axes are orthogonal (one vertical N/S, one horizontal E/W)
                const vertical = new Set(['N', 'S']);
                const horizontal = new Set(['E', 'W']);
                const orthogonal = (vertical.has(a1.axis) && horizontal.has(a2.axis)) ||
                                  (horizontal.has(a1.axis) && vertical.has(a2.axis));

                return samePair && orthogonal;
            }

            computeCertificate(nBackPremise, candidatePremise, midAtoms, windowAtoms = []) {
                if (!nBackPremise) {
                    return { match: false, reason: 'no-nback' };
                }

                if (nBackPremise.toKey() === candidatePremise.toKey()) {
                    return { match: false, reason: 'identity' };
                }

                // ============================================================================
                // DIALECTICAL EQUIVALENCE CHECK
                // ============================================================================
                // Two dialectical premises match if they share the same orthogonal axis pair.
                // Example: [N, A, B] + [W, A, B] matches [N, X, Y] + [W, X, Y]
                // Example: [N, A, B] + [W, A, B] does NOT match [N, X, Y] + [E, X, Y]
                //
                // Rationale: Dialectical premises have only 2 letters (head + tail), so the
                // standard "shared anchors ‚â• 2" equivalence check doesn't apply. Instead,
                // we check if both premises use the same orthogonal axis pair.
                // ============================================================================

                const nBackDialectical = this.isDialecticalPremise(nBackPremise);
                const candidateDialectical = this.isDialecticalPremise(candidatePremise);

                if (nBackDialectical && candidateDialectical) {
                    console.log('[EquivalenceEngine] DIALECTICAL MODE: Both premises are dialectical type');

                    // Extract axes from both premises and normalize to sorted order
                    // This ensures [N, W] and [W, N] are treated as equivalent
                    const nBackAxes = [nBackPremise.atoms[0].axis, nBackPremise.atoms[1].axis].sort().join('-');
                    const candidateAxes = [candidatePremise.atoms[0].axis, candidatePremise.atoms[1].axis].sort().join('-');

                    console.log('[EquivalenceEngine] Comparing orthogonal pairs:', {
                        nBack: nBackAxes,
                        candidate: candidateAxes,
                        nBackAtoms: nBackPremise.atoms.map(a => `${a.axis}:${a.head}->${a.tail}`),
                        candidateAtoms: candidatePremise.atoms.map(a => `${a.axis}:${a.head}->${a.tail}`)
                    });

                    if (nBackAxes === candidateAxes) {
                        console.log('[EquivalenceEngine] ‚úì DIALECTICAL MATCH - Same orthogonal pair:', nBackAxes);
                        return {
                            match: true,
                            certificate: `DIALECTICAL_EQUIVALENCE:${nBackAxes}`,
                            reason: `Both dialectical premises use ${nBackAxes} orthogonal pair`,
                            midWindowDerivable: false
                        };
                    } else {
                        console.log('[EquivalenceEngine] ‚úó DIALECTICAL NO-MATCH - Different orthogonal pairs:', nBackAxes, 'vs', candidateAxes);
                        return {
                            match: false,
                            certificate: null,
                            reason: `Dialectical mismatch: ${nBackAxes} vs ${candidateAxes}`,
                            midWindowDerivable: false
                        };
                    }
                }

                // If only one premise is dialectical, they cannot match
                // (dialectical vs atomic is a type mismatch)
                if (nBackDialectical || candidateDialectical) {
                    const dialecticalType = nBackDialectical ? 'n-back' : 'candidate';
                    console.log(`[EquivalenceEngine] TYPE MISMATCH: ${dialecticalType} is dialectical, other is atomic - cannot match`);
                    return {
                        match: false,
                        certificate: null,
                        reason: `Premise type mismatch: one dialectical, one atomic`,
                        midWindowDerivable: false
                    };
                }

                // ============================================================================
                // STANDARD EQUIVALENCE LOGIC (for non-dialectical premises)
                // ============================================================================
                // Continue with existing computeCertificate() logic below...

                // Router: dispatch based on premise type
                if (nBackPremise.type !== candidatePremise.type) {
                    return { match: false, reason: 'type-mismatch' };
                }

                if (nBackPremise.type === 'META_RELATIONAL') {
                    return this.computeMetaEquivalence(nBackPremise, candidatePremise);
                }

                // ATOMIC premise path (legacy)
                const result = this.Equivalent(nBackPremise, candidatePremise, windowAtoms, midAtoms || []);
                if (!result.ok) {
                    const response = { match: false, reason: result.reason };
                    if (result.reason === 'mid-window-derivable' || result.midWindowDerivable) {
                        response.midWindowDerivable = true;
                        if (this.transitivityEnabled) {
                            return {
                                match: true,
                                certificate: {
                                    type: 'transitive-closure',
                                    mapping: result.mapping || [],
                                    sharedLetters: result.sharedLetters || [],
                                    parity: true,
                                    midWindowDerivable: true
                                },
                                midWindowDerivable: true
                            };
                        }
                    }
                    return response;
                }

                const certificate = {
                    type: result.type,
                    mapping: result.mapping,
                    sharedLetters: result.sharedLetters,
                    parity: true,
                    midWindowDerivable: false
                };

                return { match: true, certificate, midWindowDerivable: false };
            }


            deduceImpliedOperator(p1, p2) {
                // Robust validation
                if (typeof p1 !== 'string' || typeof p2 !== 'string') {
                    console.error('deduceImpliedOperator: invalid input types', p1, p2);
                    return null;
                }

                // Maps compass operator names to their concepts
                const CONCEPT_MAP = {
                    'North': 'Up-shift',
                    'South': 'Down-shift',
                    'East': 'Analogue',
                    'West': 'Opposite'
                };

                const c1 = CONCEPT_MAP[p1];
                const c2 = CONCEPT_MAP[p2];

                if (!c1 || !c2) {
                    console.warn('deduceImpliedOperator: unknown operators', p1, p2);
                    return null;
                }

                // Same concept = Analogue (East)
                if (c1 === c2) {
                    return 'East';
                }

                // Opposite concepts = West
                const opposites = [
                    ['Up-shift', 'Down-shift'],
                    ['Down-shift', 'Up-shift'],
                    ['Analogue', 'Opposite'],
                    ['Opposite', 'Analogue']
                ];

                for (const [a, b] of opposites) {
                    if (c1 === a && c2 === b) {
                        return 'West';
                    }
                }

                // Orthogonal pairs (Up/Down with Analogue/Opposite) = null
                return null;
            }

            getMetaTruthValue(premise) {
                // Robust validation
                if (!premise || premise.type !== 'META_RELATIONAL') {
                    console.error('getMetaTruthValue: not a META premise', premise);
                    return 'INVALID';
                }

                if (!premise.meta || !Array.isArray(premise.meta.p)) {
                    console.error('getMetaTruthValue: invalid META structure', premise.meta);
                    return 'INVALID';
                }

                const operators = premise.meta.p;
                const length = operators.length;

                // Must be even number (pairs) and at least 4 (minimum 2 pairs for analogy)
                if (length < 4 || length % 2 !== 0) {
                    console.error('getMetaTruthValue: invalid operator count', length);
                    return 'INVALID';
                }

                try {
                    const numPairs = length / 2;
                    const deducedOperators = [];

                    // Deduce implied operator for each pair
                    for (let i = 0; i < numPairs; i++) {
                        const p0 = operators[i * 2];
                        const p1 = operators[i * 2 + 1];
                        const deduced = this.deduceImpliedOperator(p0, p1);
                        deducedOperators.push(deduced);
                    }

                    // Check if all deduced operators are the same
                    const firstOp = deducedOperators[0];
                    const allSame = deducedOperators.every(op => {
                        // null === null is true (orthogonal pairs)
                        // 'West' === 'West' is true
                        // null === 'West' is false
                        return op === firstOp;
                    });

                    return allSame;  // Returns true or false
                } catch (err) {
                    console.error('getMetaTruthValue: exception', err, premise);
                    return 'INVALID';
                }
            }

            // DEPRECATED (January 2025): This method supports the OLD Level 6 (META_RELATIONAL)
            // The OLD Level 6 used operator analogies like "North to South as East to West"
            // It has been replaced by the NEW Level 6 (ALGEBRAIC with hidden nodes)
            // This method is preserved for backward compatibility but is no longer accessible via UI
            computeMetaEquivalence(nBackPremise, candidatePremise) {
                // Defensive validation
                if (!nBackPremise || !candidatePremise) {
                    console.error('computeMetaEquivalence: null premise', { nBackPremise, candidatePremise });
                    return { match: false, reason: 'null-premise' };
                }

                if (nBackPremise.type !== 'META_RELATIONAL' || candidatePremise.type !== 'META_RELATIONAL') {
                    console.error('computeMetaEquivalence: not META premises', {
                        nBackType: nBackPremise.type,
                        candidateType: candidatePremise.type
                    });
                    return { match: false, reason: 'type-mismatch' };
                }

                try {
                    const truthA = this.getMetaTruthValue(nBackPremise);
                    const truthB = this.getMetaTruthValue(candidatePremise);

                    if (truthA === 'INVALID' || truthB === 'INVALID') {
                        console.warn('computeMetaEquivalence: invalid truth value', { truthA, truthB });
                        return { match: false, reason: 'meta-invalid' };
                    }

                    // 6th-order match: truth values must be equal
                    const match = (truthA === truthB);

                    return {
                        match,
                        certificate: match ? {
                            type: 'meta',
                            truthA,
                            truthB,
                            nBackOperators: nBackPremise.meta.p,
                            candidateOperators: candidatePremise.meta.p
                        } : null,
                        midWindowDerivable: false,
                        reason: match ? 'truth-match' : 'truth-mismatch'
                    };
                } catch (err) {
                    console.error('computeMetaEquivalence: exception', err);
                    return { match: false, reason: 'exception', error: err.message };
                }
            }

        }

        class MatchPlanner {
            constructor(rng) {
                this.rng = rng;
                this.schedule = [];
                this.flips = new Map();
                this.matchModeBag = [];
                this.decoyModeBag = [];
                this.foilRate = conflictConfig.foilRate;
                this.foilTypes = Object.keys(conflictConfig.foilTypesWeights);
                this.foilWeights = this.foilTypes.map(type => conflictConfig.foilTypesWeights[type]);
            }

            plan(totalTrials, n) {
                this.schedule = new Array(totalTrials).fill(false);
                this.flips.clear();
                const rate = this.rng.nextBetween(0.35, 0.55);
                const history = [];
                for (let i = 0; i < totalTrials; i++) {
                    if (i < n) {
                        this.schedule[i] = false;
                        history.push(false);
                        continue;
                    }

                    let decision = this.rng.next() < rate;
                    if (this.wouldRepeat(history, decision)) {
                        decision = !decision;
                        this.flips.set(i, true);
                    }

                    this.schedule[i] = decision;
                    history.push(decision);
                    if (history.length > 24) history.shift();
                }
                return this.schedule;
            }

            chooseConflictMode(plannedMatch) {
                if (plannedMatch) {
                    if (this.matchModeBag.length === 0) {
                        this.matchModeBag = this.rng.shuffle(['BSM', 'CAC']);
                    }
                    return this.matchModeBag.pop();
                }
                if (this.decoyModeBag.length === 0) {
                    const decoys = ['ASNM', 'APNM', 'PPHF', 'CBB', 'WLC', 'ISD'];
                    const bag = [];
                    for (let i = 0; i < 2; i++) {
                        bag.push(...decoys);
                    }
                    this.decoyModeBag = this.rng.shuffle(bag);
                }
                return this.decoyModeBag.pop();
            }

            sampleFoilType() {
                if (this.foilTypes.length === 0) {
                    return null;
                }
                return this.rng.weightedChoice(this.foilTypes, this.foilWeights);
            }

            maybePlanFoil() {
                if (this.foilRate <= 0) return null;
                if (this.rng.next() < this.foilRate) {
                    const type = this.sampleFoilType();
                    return type ? { type } : null;
                }
                return null;
            }

            wouldRepeat(history, decision) {
                const window = [...history, decision];
                if (window.length < 24) return false;
                const recent = window.slice(-12);
                const previous = window.slice(-24, -12);
                return this.isRotationEqual(previous, recent);
            }

            isRotationEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) return false;
                const joined1 = arr1.join('');
                const joined2 = arr2.join('');
                return (joined1 + joined1).includes(joined2);
            }

            forceFlip(index) {
                if (index < 0 || index >= this.schedule.length) return;
                this.schedule[index] = !this.schedule[index];
                this.flips.set(index, true);
            }

            wasFlipped(index) {
                return this.flips.get(index) || false;
            }
        }

        class GameLogger {
            constructor(limitBytes = 5 * 1024 * 1024) {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeLimit = limitBytes;
                this.sizeEstimate = 0;
            }

            estimateSize(entry) {
                try {
                    return JSON.stringify(entry).length;
                } catch (error) {
                    return 0;
                }
            }

            flushToArchive() {
                const keep = Math.min(1000, this.entries.length);
                const flushCount = this.entries.length - keep;
                if (flushCount <= 0) return false;
                const flushedEntries = this.entries.splice(0, flushCount);
                const flushedSizes = this.entrySizes.splice(0, flushCount);
                this.archivedChunks.push(JSON.stringify(flushedEntries));
                const reclaimed = flushedSizes.reduce((acc, value) => acc + value, 0);
                this.sizeEstimate = Math.max(0, this.sizeEstimate - reclaimed);
                return true;
            }

            add(entry) {
                const size = this.estimateSize(entry);
                this.entries.push(entry);
                this.entrySizes.push(size);
                this.sizeEstimate += size;
                while (this.sizeEstimate > this.sizeLimit) {
                    const flushed = this.flushToArchive();
                    if (!flushed) {
                        break;
                    }
                }
            }

            reset() {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeEstimate = 0;
            }

            getEntriesSnapshot() {
                const snapshot = [];
                for (const chunk of this.archivedChunks) {
                    try {
                        const parsed = JSON.parse(chunk);
                        if (Array.isArray(parsed)) {
                            snapshot.push(...parsed);
                        }
                    } catch (error) {
                        console.warn('Failed to parse archived log chunk', error);
                    }
                }
                snapshot.push(...this.entries);
                return snapshot;
            }

            toCSV() {
                const entries = this.getEntriesSnapshot();
                if (entries.length === 0) return '';
                const headers = Object.keys(entries[0]);
                const rows = [headers.join(',')];
                entries.forEach(entry => {
                    const row = headers.map(key => {
                        const value = entry[key];
                        if (value === null || value === undefined) return '';
                        if (typeof value === 'object') {
                            return JSON.stringify(value).replace(/"/g, '""');
                        }
                        return String(value).replace(/"/g, '""');
                    }).join(',');
                    rows.push(row);
                });
                return rows.join('\n');
            }

            toJSON() {
                return JSON.stringify(this.getEntriesSnapshot(), null, 2);
            }
        }

        class GameState {
            constructor(seed, options) {
                this.seed = seed;
                this.rng = new Mulberry32(seed);
                this.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                this.windowSize = options.windowSize;
                this.currentStep = 0;
                this.constraintStore = [];
                this.premiseHistory = [];
                this.letterUsage = new Map();
                this.axisUsage = { N: 0, S: 0, E: 0, W: 0 };
                this.cooldown = new Map();
                this.novelty = new NoveltyManager(HAMMING_WINDOW, FIRST_N_NOVELTY);
                this.letterPool = new LetterPoolManager(this.letters, this.rng, this.letterUsage);
                this.coordinates = new Map();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ENHANCEMENT: DA VINCI MODE AXIS ROTATION TRACKING
                // Initialize round-robin indices for Mode 1 (Dialectical) and Mode 2 (Tensor).
                // These ensure that axis pairs rotate systematically instead of randomly.
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.dialecticalAxisIndex = 0;  // For Mode 1: cycles through 4 orthogonal pairs
                this.tensorAxisIndex = 0;        // For Mode 2: cycles through 4 orthogonal pairs
            }

            resetNovelty() {
                this.novelty.reset();
            }

            getWindowAtoms() {
                const cutoff = Math.max(0, this.currentStep - this.windowSize);
                return this.constraintStore
                    .filter(entry => entry.step >= cutoff)
                    .flatMap(entry => entry.atoms);
            }

            getConstraintsInRange(start, end) {
                return this.constraintStore
                    .filter(entry => entry.step >= start && entry.step <= end)
                    .flatMap(entry => entry.atoms);
            }

            ensureLetterUsage(letter) {
                if (!this.letterUsage.has(letter)) {
                    this.letterUsage.set(letter, { head: 0, tail: 0 });
                }
                return this.letterUsage.get(letter);
            }

            updateUsage(premise) {
                // META premises don't have atoms to track usage for
                if (!premise || premise.type === 'META_RELATIONAL') {
                    return;
                }

                // ATOMIC premises - track letter and axis usage
                if (premise.atoms && Array.isArray(premise.atoms)) {
                    premise.atoms.forEach(atom => {
                        if (atom && atom.head && atom.tail && atom.axis) {
                            this.ensureLetterUsage(atom.head).head += 1;
                            this.ensureLetterUsage(atom.tail).tail += 1;
                            if (this.axisUsage[atom.axis] !== undefined) {
                                this.axisUsage[atom.axis] += 1;
                            }
                        }
                    });
                }
            }

            recordPremise(premise, atoms, metadata) {
                // Defensive: ensure atoms is an array
                const safeAtoms = (Array.isArray(atoms) && atoms.length > 0) ? atoms : [];

                // For META premises, atoms will be empty array - that's expected
                if (premise && premise.type === 'META_RELATIONAL') {
                    console.log('Recording META premise:', premise.toString(), metadata);
                }

                this.constraintStore.push({ step: this.currentStep, atoms: safeAtoms });
                this.premiseHistory.push({ step: this.currentStep, premise, metadata });
                this.currentStep += 1;

                const cutoff = this.currentStep - this.windowSize;
                this.constraintStore = this.constraintStore.filter(entry => entry.step >= cutoff);
                this.premiseHistory = this.premiseHistory.filter(entry => entry.step >= cutoff - this.windowSize);

                this.updateUsage(premise);
            }

            getPremiseAt(index) {
                const entry = this.premiseHistory.find(p => p.step === index);
                return entry ? entry.premise : null;
            }

            getActiveCooldown(currentTrial) {
                const active = new Set();
                this.cooldown.forEach((expiry, letter) => {
                    if (expiry > currentTrial) {
                        active.add(letter);
                    }
                });
                return active;
            }

            applyCooldown(letters, currentTrial, n) {
                const cooldownLength = Math.ceil(n / 2);
                letters.forEach(letter => {
                    this.cooldown.set(letter, currentTrial + cooldownLength);
                });
            }
        }

        class PremiseGenerator {
            constructor(state, solver, equivalence) {
                this.state = state;
                this.solver = solver;
                this.equivalence = equivalence;
                this.planner = null;
            }

            setPlanner(planner) {
                this.planner = planner;
            }

            generate(options) {
                const {
                    trialIndex,
                    k,
                    n,
                    plannedMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters,
                    allowOverride,
                    foilPlan,
                    // DEPRECATED (January 2025): force*Leap flags replaced by logic-level-select dropdown
                    // Kept for backward compatibility, but always set to false in GameEngine
                    forceMetaLeap,
                    forceCompoundLeap
                } = options;

                // DA VINCI HIERARCHY: TOPOLOGY MODE ROUTING
                // Mode 0: Standard (user-controlled k, standard atomic premises)
                // Mode 1: Dialectical Superposition (k=2, 1 node + 2 orthogonal vectors)
                // Mode 2: Semantic Tensor (k=2, 3 nodes with intersection)
                // Mode 3: System Homology (k=3, 4 nodes with symmetry)
                // Mode 4: Complementary Interface (k=5, 6 nodes with asymmetry)
                const logicLevelSelect = document.getElementById('logic-level-select');
                const selectedMode = logicLevelSelect ? parseInt(logicLevelSelect.value) : 0;

                console.log('[PremiseGenerator.generate] ENTRY - selectedMode:', selectedMode, 'plannedMatch:', plannedMatch, 'nBackPremise:', nBackPremise);

                // Mode 1: Dialectical Superposition - STRICT MODE (NO FALLBACK)
                if (selectedMode === 1) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // MODE 1 ENTRY BANNER - Highly visible console logging
                    // If user doesn't see this banner, Mode 1 is NOT being entered.
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    console.log('');
                    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                    console.log('‚ïë                                                                    ‚ïë');
                    console.log('‚ïë  üéØ MODE 1: DIALECTICAL SUPERPOSITION - ENTRY CONFIRMED           ‚ïë');
                    console.log('‚ïë                                                                    ‚ïë');
                    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                    console.log('');
                    console.log('[PremiseGenerator] Mode 1: Dialectical Superposition (k=2) - STRICT MODE');
                    console.log('[PremiseGenerator] Entry parameters:', {
                        plannedMatch,
                        nBackPremise_exists: !!nBackPremise,
                        k_param_received: k,
                        k_will_be_forced_to: 2,
                        trialIndex,
                        middleAtoms_count: middleAtoms?.length || 0
                    });
                    console.log('[PremiseGenerator] Starting 10-retry loop for dialectical premise generation...');
                    console.log('');

                    // Retry loop: attempt up to 10 times with different random variations
                    for (let retryAttempt = 0; retryAttempt < 10; retryAttempt++) {
                        try {
                            console.log(`[PremiseGenerator] Mode 1 Retry Attempt ${retryAttempt + 1}/10`);
                            const dialecticPremise = this.buildDialecticalPremise(plannedMatch, nBackPremise, k);

                            if (dialecticPremise && dialecticPremise.atoms && dialecticPremise.atoms.length > 0) {
                                console.log('[PremiseGenerator] Mode 1 SUCCESS - Generated premise:', dialecticPremise.toString());
                                console.log('[PremiseGenerator] Premise type:', dialecticPremise.type);
                                const signatures = this.state.novelty.buildSignatures(dialecticPremise);
                                return {
                                    premise: dialecticPremise,
                                    signatures,
                                    novelty: { noveltyScores: {}, blocked: false },
                                    satResult: { ok: true, coordinates: new Map() },
                                    certificate: null,
                                    midDerivable: false,
                                    attempts: retryAttempt + 1,
                                    modeUsed: 'DIALECTIC',
                                    features: dialecticPremise.getFeatures(),
                                    foilType: null,
                                    planMatch: plannedMatch
                                };
                            } else {
                                console.warn(`[PremiseGenerator] Retry ${retryAttempt + 1}: buildDialecticalPremise returned null/invalid - retrying...`);
                            }
                        } catch (err) {
                            console.error(`[PremiseGenerator] Retry ${retryAttempt + 1}: Exception during generation:`, err);
                        }
                    }

                    // CRITICAL: After 10 retries, throw error instead of falling back
                    const errorMsg = `[PremiseGenerator] Mode 1 FAILED after 10 retry attempts. plannedMatch=${plannedMatch}, nBackPremise=${!!nBackPremise}. Check builder logic.`;
                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }

                // Mode 2: Semantic Tensor - STRICT MODE (NO FALLBACK)
                if (selectedMode === 2) {
                    console.log('[PremiseGenerator] Mode 2: Semantic Tensor (k=2) - STRICT MODE');
                    console.log('[PremiseGenerator] plannedMatch:', plannedMatch, '| nBackPremise exists:', !!nBackPremise);

                    // Retry loop: attempt up to 10 times with different random variations
                    for (let retryAttempt = 0; retryAttempt < 10; retryAttempt++) {
                        try {
                            console.log(`[PremiseGenerator] Mode 2 Retry Attempt ${retryAttempt + 1}/10`);
                            const triadicPremise = this.buildTriadicPremise(plannedMatch, nBackPremise, k);

                            if (triadicPremise && triadicPremise.atoms && triadicPremise.atoms.length > 0) {
                                console.log('[PremiseGenerator] Mode 2 SUCCESS - Generated premise:', triadicPremise.toString());
                                console.log('[PremiseGenerator] Premise type:', triadicPremise.type);
                                const signatures = this.state.novelty.buildSignatures(triadicPremise);
                                return {
                                    premise: triadicPremise,
                                    signatures,
                                    novelty: { noveltyScores: {}, blocked: false },
                                    satResult: { ok: true, coordinates: new Map() },
                                    certificate: null,
                                    midDerivable: false,
                                    attempts: retryAttempt + 1,
                                    modeUsed: 'TENSOR',
                                    features: triadicPremise.getFeatures(),
                                    foilType: null,
                                    planMatch: plannedMatch
                                };
                            } else {
                                console.warn(`[PremiseGenerator] Retry ${retryAttempt + 1}: buildTriadicPremise returned null/invalid - retrying...`);
                            }
                        } catch (err) {
                            console.error(`[PremiseGenerator] Retry ${retryAttempt + 1}: Exception during generation:`, err);
                        }
                    }

                    // CRITICAL: After 10 retries, throw error instead of falling back
                    const errorMsg = `[PremiseGenerator] Mode 2 FAILED after 10 retry attempts. plannedMatch=${plannedMatch}, nBackPremise=${!!nBackPremise}. Check builder logic.`;
                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }

                // Mode 3: System Homology - STRICT MODE (NO FALLBACK)
                if (selectedMode === 3) {
                    console.log('[PremiseGenerator] Mode 3: System Homology (k=3) - STRICT MODE');
                    console.log('[PremiseGenerator] plannedMatch:', plannedMatch, '| nBackPremise exists:', !!nBackPremise);

                    // Retry loop: attempt up to 10 times with different random variations
                    for (let retryAttempt = 0; retryAttempt < 10; retryAttempt++) {
                        try {
                            console.log(`[PremiseGenerator] Mode 3 Retry Attempt ${retryAttempt + 1}/10`);
                            const algebraicPremise = this.buildAlgebraicPremise(plannedMatch, nBackPremise, k);

                            if (algebraicPremise && algebraicPremise.atoms && algebraicPremise.atoms.length > 0) {
                                console.log('[PremiseGenerator] Mode 3 SUCCESS - Generated premise:', algebraicPremise.toString());
                                console.log('[PremiseGenerator] Premise type:', algebraicPremise.type);
                                const signatures = this.state.novelty.buildSignatures(algebraicPremise);
                                return {
                                    premise: algebraicPremise,
                                    signatures,
                                    novelty: { noveltyScores: {}, blocked: false },
                                    satResult: { ok: true, coordinates: new Map() },
                                    certificate: null,
                                    midDerivable: false,
                                    attempts: retryAttempt + 1,
                                    modeUsed: 'HOMOLOGY',
                                    features: algebraicPremise.getFeatures(),
                                    foilType: null,
                                    planMatch: plannedMatch
                                };
                            } else {
                                console.warn(`[PremiseGenerator] Retry ${retryAttempt + 1}: buildAlgebraicPremise returned null/invalid - retrying...`);
                            }
                        } catch (err) {
                            console.error(`[PremiseGenerator] Retry ${retryAttempt + 1}: Exception during generation:`, err);
                        }
                    }

                    // CRITICAL: After 10 retries, throw error instead of falling back
                    const errorMsg = `[PremiseGenerator] Mode 3 FAILED after 10 retry attempts. plannedMatch=${plannedMatch}, nBackPremise=${!!nBackPremise}. Check builder logic.`;
                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }

                // Mode 4: Complementary Interface - STRICT MODE (NO FALLBACK)
                if (selectedMode === 4) {
                    console.log('[PremiseGenerator] Mode 4: Complementary Interface (k=5) - STRICT MODE');
                    console.log('[PremiseGenerator] plannedMatch:', plannedMatch, '| nBackPremise exists:', !!nBackPremise);

                    // Retry loop: attempt up to 10 times with different random variations
                    for (let retryAttempt = 0; retryAttempt < 10; retryAttempt++) {
                        try {
                            console.log(`[PremiseGenerator] Mode 4 Retry Attempt ${retryAttempt + 1}/10`);
                            const interfacePremise = this.buildInterfacePremise(plannedMatch, nBackPremise, k);

                            if (interfacePremise && interfacePremise.atoms && interfacePremise.atoms.length > 0) {
                                console.log('[PremiseGenerator] Mode 4 SUCCESS - Generated premise:', interfacePremise.toString());
                                console.log('[PremiseGenerator] Premise type:', interfacePremise.type);
                                const signatures = this.state.novelty.buildSignatures(interfacePremise);
                                return {
                                    premise: interfacePremise,
                                    signatures,
                                    novelty: { noveltyScores: {}, blocked: false },
                                    satResult: { ok: true, coordinates: new Map() },
                                    certificate: null,
                                    midDerivable: false,
                                    attempts: retryAttempt + 1,
                                    modeUsed: 'INTERFACE',
                                    features: interfacePremise.getFeatures(),
                                    foilType: null,
                                    planMatch: plannedMatch
                                };
                            } else {
                                console.warn(`[PremiseGenerator] Retry ${retryAttempt + 1}: buildInterfacePremise returned null/invalid - retrying...`);
                            }
                        } catch (err) {
                            console.error(`[PremiseGenerator] Retry ${retryAttempt + 1}: Exception during generation:`, err);
                        }
                    }

                    // CRITICAL: After 10 retries, throw error instead of falling back
                    const errorMsg = `[PremiseGenerator] Mode 4 FAILED after 10 retry attempts. plannedMatch=${plannedMatch}, nBackPremise=${!!nBackPremise}. Check builder logic.`;
                    console.error(errorMsg);
                    throw new Error(errorMsg);
                }

                // Mode 0 or Level 1: Standard / Manual (user controls k) or Linear Chains (k=3)
                // Fall through to existing atomic premise generation logic
                console.log(`[PremiseGenerator] ${selectedMode === 1 ? 'Level 1: Linear Chains' : 'Mode 0: Standard'} (atomic premises, k=${k})`);

                // COMPOUND OPERATOR premise generation path (Old Level 7 - now deprecated in favor of INTERFACE)
                // Only triggered by forceCompoundLeap flag (not accessible via dropdown)
                if (forceCompoundLeap) {
                    try {
                        const compoundPremise = this.buildCompoundOperatorPremise(plannedMatch, nBackPremise, k);
                        if (compoundPremise && compoundPremise.atoms && compoundPremise.atoms.length > 0) {
                            const signatures = this.state.novelty.buildSignatures(compoundPremise);
                            return {
                                premise: compoundPremise,
                                signatures,
                                novelty: { noveltyScores: {}, blocked: false },
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: 1,
                                modeUsed: 'COMPOUND_OPERATOR',
                                features: compoundPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        } else {
                            console.error('buildCompoundOperatorPremise returned invalid premise', compoundPremise);
                        }
                    } catch (err) {
                        console.error('COMPOUND premise generation failed', err);
                        // Fall through to META or atomic generation as emergency fallback
                    }
                }

                // META premise generation path (Level 6)
                if (forceMetaLeap) {
                    try {
                        const metaPremise = this.buildMetaPremise(plannedMatch, nBackPremise, k);
                        if (metaPremise && metaPremise.type === 'META_RELATIONAL') {
                            const signatures = this.state.novelty.buildSignatures(metaPremise);
                            return {
                                premise: metaPremise,
                                signatures,
                                novelty: { noveltyScores: {}, blocked: false },
                                satResult: { ok: true, coordinates: new Map() },
                                certificate: null,
                                midDerivable: false,
                                attempts: 1,
                                modeUsed: 'META',
                                features: metaPremise.getFeatures(),
                                foilType: null,
                                planMatch: plannedMatch
                            };
                        } else {
                            console.error('buildMetaPremise returned invalid premise', metaPremise);
                        }
                    } catch (err) {
                        console.error('META premise generation failed', err);
                        // Fall through to atomic generation as emergency fallback
                    }
                }

                const windowAtoms = this.state.getWindowAtoms();
                let bestCandidate = null;
                let attempts = 0;
                let expanded = false;
                const effectiveMatch = plannedMatch && Boolean(nBackPremise);
                let mode = effectiveMatch ? 'BSM' : 'ASNM';
                if (this.planner) {
                    mode = this.planner.chooseConflictMode(effectiveMatch);
                }

                let activeFoilPlan = (!effectiveMatch && foilPlan && typeof foilPlan.type === 'string') ? { type: foilPlan.type } : null;
                let foilAttempts = 0;

                while (attempts < MAX_GENERATION_ATTEMPTS) {
                    const expand = attempts > 0 && attempts % NOVELTY_OVERRIDE_THRESHOLD === 0;
                    if (expand) expanded = true;

                    let candidatePremise = null;
                    let candidateAtoms = null;
                    let modeUsed = mode;
                    let foilType = null;

                    if (!effectiveMatch && activeFoilPlan && nBackPremise) {
                        const foilResult = this.buildFoilPremise(activeFoilPlan.type, {
                            referencePremise: nBackPremise,
                            windowAtoms,
                            middleAtoms,
                            avoidLetters
                        });
                        foilAttempts++;
                        if (foilResult) {
                            candidatePremise = foilResult.premise;
                            candidateAtoms = candidatePremise.atoms;
                            foilType = foilResult.foilType;
                            modeUsed = `FOIL_${foilResult.foilType}`;
                        } else if (foilAttempts >= 60) {
                            activeFoilPlan = null;
                        }
                    }

                    if (!candidatePremise) {
                        const pool = this.state.letterPool.nextPool(k, { expand });
                        const context = {
                            mode,
                            plannedMatch: effectiveMatch,
                            nBackPremise,
                            pool,
                            k,
                            n,
                            trialIndex,
                            middleAtoms,
                            avoidLetters,
                            state: this.state,
                            rng: this.state.rng
                        };
                        const atomsFromMode = this.makePremiseWithMode(mode, context);
                        attempts++;
                        if (!atomsFromMode) {
                            if (attempts % 12 === 0 && this.planner) {
                                mode = this.planner.chooseConflictMode(effectiveMatch);
                            }
                            continue;
                        }
                        candidateAtoms = atomsFromMode;
                        candidatePremise = new Premise(atomsFromMode);
                    } else {
                        attempts++;
                        candidateAtoms = candidatePremise.atoms;
                    }

                    const premise = candidatePremise;
                    const features = premise.getFeatures();
                    const signatures = this.state.novelty.buildSignatures(premise);
                    const novelty = this.state.novelty.evaluate(premise, signatures, trialIndex);

                    if (novelty.blocked && !(allowOverride && expanded)) {
                        continue;
                    }

                    const satResult = this.solver.evaluate(windowAtoms, candidateAtoms);
                    if (!satResult.ok) {
                        continue;
                    }

                    let certificate = null;
                    let midDerivable = false;

                    if (effectiveMatch) {
                        const equivalence = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (!equivalence.match) {
                            continue;
                        }
                        certificate = equivalence.certificate;
                        midDerivable = equivalence.midWindowDerivable;
                    } else if (nBackPremise) {
                        const check = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (check.match) {
                            continue;
                        }
                    }

                    const score = Math.exp(ACCEPTANCE_ALPHA * novelty.noveltyScores.hamming - ACCEPTANCE_BETA * novelty.penalty);
                    if (!bestCandidate || score > bestCandidate.score) {
                        bestCandidate = {
                            premise,
                            signatures,
                            novelty,
                            satResult,
                            certificate,
                            midDerivable,
                            attempts,
                            modeUsed,
                            features,
                            foilType,
                            score
                        };
                    }

                    if (this.state.rng.next() < Math.min(1, score)) {
                        return bestCandidate;
                    }

                    if (attempts % 12 === 0 && this.planner) {
                        mode = this.planner.chooseConflictMode(effectiveMatch);
                    }
                }

                return bestCandidate;
            }

            makePremiseWithMode(mode, context) {
                const requiresNBack = ['ASNM', 'APNM', 'PPHF', 'BSM', 'WLC', 'CAC', 'ISD'];
                if (!context.nBackPremise && requiresNBack.includes(mode)) {
                    return this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
                switch (mode) {
                    case 'ASNM':
                        return this.makeAxisSwapNearMiss(context);
                    case 'APNM':
                        return this.makeAnchorPermutationNearMiss(context);
                    case 'PPHF':
                        return this.makeParityPreservedHubFlip(context);
                    case 'CBB':
                        return this.makeCycleBorderBait(context);
                    case 'BSM':
                        return this.makeBipartiteSignatureMatch(context);
                    case 'WLC':
                        return this.makeWrongLagCamouflage(context);
                    case 'CAC':
                        return this.makeCrossAxisCoupling(context);
                    case 'ISD':
                        return this.makeIsomorphicSkeletonDecoy(context);
                    default:
                        return context.plannedMatch
                            ? this.buildMatchCandidate(context.nBackPremise, context.pool, context.k)
                            : this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
            }

            buildFoilPremise(type, context) {
                const { referencePremise, windowAtoms, middleAtoms, avoidLetters } = context;
                if (!referencePremise) return null;
                const maxAttempts = 80;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    let candidate = null;
                    switch (type) {
                        case 'ANCHOR_ONE':
                            candidate = this.makeAnchorOneFoil(referencePremise);
                            break;
                        case 'PAIR_SWAP':
                            candidate = this.makePairSwapFoil(referencePremise);
                            break;
                        case 'PARITY_OFF':
                            candidate = this.makeParityOffFoil(referencePremise);
                            break;
                        case 'AXIS_ORTHO':
                            candidate = this.makeAxisOrthoFoil(referencePremise);
                            break;
                        case 'DERIVED_IN_ONE':
                            candidate = this.makeDerivedInOneFoil(referencePremise);
                            break;
                        case 'WINDOW_SHADOW':
                            candidate = this.makeWindowShadowFoil(referencePremise, middleAtoms);
                            break;
                        default:
                            candidate = null;
                    }
                    if (!candidate) {
                        continue;
                    }
                    if (avoidLetters) {
                        const letters = candidate.getLetters();
                        let blocked = false;
                        avoidLetters.forEach(letter => {
                            if (letters.has(letter)) {
                                blocked = true;
                            }
                        });
                        if (blocked) continue;
                    }
                    const sat = this.solver.evaluate(windowAtoms, candidate.atoms);
                    if (!sat.ok) {
                        continue;
                    }
                    const eq = this.equivalence.Equivalent(referencePremise, candidate, windowAtoms, middleAtoms);
                    if (eq.ok) {
                        continue;
                    }
                    if (!this.foilReasonMatches(type, eq.reason)) {
                        continue;
                    }
                    return { premise: candidate, foilType: type };
                }
                return null;
            }

            foilReasonMatches(type, reason) {
                const expected = {
                    ANCHOR_ONE: 'anchors',
                    PAIR_SWAP: 'mapping',
                    PARITY_OFF: 'parity',
                    AXIS_ORTHO: 'mapping',
                    DERIVED_IN_ONE: 'parity',
                    WINDOW_SHADOW: 'mid-window-derivable'
                };
                const matchReason = expected[type];
                if (!matchReason) return true;
                if (matchReason === reason) return true;
                if (type === 'DERIVED_IN_ONE' && reason === 'mid-window-derivable') return true;
                return false;
            }

            makeAnchorOneFoil(referencePremise) {
                const refLetters = referencePremise.getLetters();
                const refArray = Array.from(refLetters);
                if (refArray.length === 0) return null;
                const anchor = this.state.rng.choice(refArray);
                const banned = new Set(refLetters);
                banned.delete(anchor);
                const available = this.state.letters.filter(letter => !banned.has(letter));
                if (available.length === 0) return null;
                const atoms = [];
                for (const atom of referencePremise.atoms) {
                    const axis = atom.axis;
                    const head = atom.head === anchor ? anchor : this.state.rng.choice(available);
                    let tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                    let guard = 0;
                    while (tail === head && guard < 12) {
                        tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                        guard++;
                    }
                    if (tail === head) return null;
                    atoms.push(new Atom(axis, head, tail));
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refLetters.has(letter));
                if (shared.length !== 1 || shared[0] !== anchor) return null;
                return premise;
            }

            makePairSwapFoil(referencePremise) {
                const atoms = referencePremise.atoms;
                if (atoms.length < 2) return null;
                const heads = atoms.map(atom => atom.head);
                const tails = atoms.map(atom => atom.tail);
                for (let attempt = 0; attempt < 40; attempt++) {
                    const shuffledHeads = this.state.rng.shuffle(heads);
                    const shuffledTails = this.state.rng.shuffle(tails);
                    const candidates = [];
                    const usedKeys = new Set();
                    let valid = true;
                    for (let i = 0; i < atoms.length; i++) {
                        let head = shuffledHeads[i];
                        let tail = shuffledTails[i];
                        let guard = 0;
                        while (head === tail && guard < 8) {
                            tail = this.state.rng.choice(tails);
                            guard++;
                        }
                        if (head === tail) {
                            valid = false;
                            break;
                        }
                        const atomCandidate = new Atom(atoms[i].axis, head, tail);
                        const key = atomCandidate.toKey();
                        if (usedKeys.has(key)) {
                            valid = false;
                            break;
                        }
                        if (atomCandidate.equals(atoms[i]) || atomCandidate.equals(Atom.invert(atoms[i]))) {
                            valid = false;
                            break;
                        }
                        usedKeys.add(key);
                        candidates.push(atomCandidate);
                    }
                    if (!valid) continue;
                    const premise = new Premise(candidates);
                    if (premise.toKey() === referencePremise.toKey()) continue;
                    return premise;
                }
                return null;
            }

            makeParityOffFoil(referencePremise) {
                const refSet = referencePremise.getLetters();
                const refLetters = Array.from(refSet);
                const base = this.cloneAtoms(referencePremise);
                const originalLength = base.length;
                if (originalLength === 0) return null;
                let target = originalLength;
                if (originalLength === 1) {
                    target = Math.min(4, 2);
                } else if (originalLength === 4) {
                    target = 3;
                } else {
                    const delta = this.state.rng.next() < 0.5 ? -1 : 1;
                    target = Math.min(4, Math.max(1, originalLength + delta));
                    if (target === originalLength) {
                        target = Math.max(1, Math.min(4, originalLength - delta));
                    }
                    if (target === originalLength) {
                        target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                    }
                }
                if (target === originalLength) {
                    target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                }
                if (target < 1) target = 1;
                let atoms = base;
                if (target < originalLength) {
                    atoms = base.slice();
                    while (atoms.length > target) {
                        const index = this.state.rng.nextInt(0, atoms.length - 1);
                        atoms.splice(index, 1);
                    }
                } else if (target > originalLength) {
                    atoms = base.slice();
                    const axes = MATCH_AXES;
                    let guard = 0;
                    while (atoms.length < target && guard < 60) {
                        guard++;
                        const head = this.state.rng.choice(refLetters);
                        if (avoidLetters && avoidLetters.has(head)) continue;
                        let tailCandidates = refLetters.filter(letter => letter !== head);
                        if (avoidLetters) {
                            tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                        }
                        if (tailCandidates.length === 0) continue;
                        const tail = this.state.rng.choice(tailCandidates);
                        const axis = this.state.rng.choice(axes);
                        const candidate = new Atom(axis, head, tail);
                        if (atoms.some(atom => atom.toKey() === candidate.toKey())) continue;
                        atoms.push(candidate);
                    }
                    if (atoms.length !== target) return null;
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refSet.has(letter));
                if (shared.length < 2) return null;
                return premise;
            }

            makeAxisOrthoFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const index = this.state.rng.nextInt(0, base.length - 1);
                const orthMap = { N: 'E', S: 'W', E: 'N', W: 'S' };
                const axis = orthMap[base[index].axis];
                if (!axis) return null;
                base[index] = new Atom(axis, base[index].head, base[index].tail);
                return new Premise(base);
            }

            makeDerivedInOneFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const additions = [];
                for (let i = 0; i < base.length; i++) {
                    for (let j = 0; j < base.length; j++) {
                        if (i === j) continue;
                        const a = base[i];
                        const b = base[j];
                        if (a.axis !== b.axis) continue;
                        if (a.tail === b.head && a.head !== b.tail) {
                            const candidate = new Atom(a.axis, a.head, b.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                        if (b.tail === a.head && b.head !== a.tail) {
                            const candidate = new Atom(a.axis, b.head, a.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                    }
                }
                if (additions.length === 0) return null;
                base.push(this.state.rng.choice(additions));
                return new Premise(base);
            }

            makeWindowShadowFoil(referencePremise, middleAtoms) {
                if (!middleAtoms || middleAtoms.length === 0) return null;
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const refLetters = referencePremise.getLetters();
                const options = middleAtoms.filter(atom => {
                    const already = base.some(existing => existing.equals(atom));
                    return !already && (refLetters.has(atom.head) || refLetters.has(atom.tail));
                });
                if (options.length === 0) return null;
                const replacement = this.state.rng.choice(options);
                const index = this.state.rng.nextInt(0, base.length - 1);
                base[index] = new Atom(replacement.axis, replacement.head, replacement.tail);
                return new Premise(base);
            }

            cloneAtoms(premise) {
                return premise.atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
            }

            sampleNewLetter(excludeSet = new Set()) {
                const candidates = this.state.letters.filter(letter => !excludeSet.has(letter));
                if (candidates.length === 0) return null;
                return this.state.rng.choice(candidates);
            }

            normalizeAtomCount(atoms, pool, target, avoidLetters, options = {}) {
                if (!atoms) return null;
                const clones = atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
                const required = new Set();
                if (typeof options.requiredIndex === 'number') {
                    required.add(options.requiredIndex);
                }
                if (Array.isArray(options.requiredIndices)) {
                    options.requiredIndices.forEach(idx => required.add(idx));
                }

                const result = [];
                const usedKeys = new Set();
                const pushAtom = (atom) => {
                    const key = atom.toKey();
                    if (usedKeys.has(key)) return false;
                    result.push(atom);
                    usedKeys.add(key);
                    return true;
                };

                for (const idx of required) {
                    if (idx >= 0 && idx < clones.length) {
                        pushAtom(clones[idx]);
                    }
                }

                for (let i = 0; i < clones.length && result.length < target; i++) {
                    if (required.has(i)) continue;
                    pushAtom(clones[i]);
                }

                const poolLetters = pool.length > 0 ? pool : this.state.letters;
                let attempts = 0;
                while (result.length < target && attempts < 200) {
                    attempts++;
                    const head = this.state.rng.choice(poolLetters);
                    if (avoidLetters && avoidLetters.has(head)) continue;
                    let tailCandidates = poolLetters.filter(letter => letter !== head);
                    if (avoidLetters) {
                        tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                    }
                    if (tailCandidates.length === 0) continue;
                    const tail = this.state.rng.choice(tailCandidates);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    const atom = new Atom(axis, head, tail);
                    if (usedKeys.has(atom.toKey())) continue;
                    pushAtom(atom);
                }

                if (result.length !== target) return null;
                return result;
            }

            makeAxisSwapNearMiss({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise || nBackPremise.atoms.length === 0) return null;
                const base = this.cloneAtoms(nBackPremise);
                const index = this.state.rng.nextInt(0, base.length - 1);
                const axisOptions = MATCH_AXES.filter(axis => axis !== base[index].axis);
                if (axisOptions.length === 0) return null;
                base[index] = new Atom(this.state.rng.choice(axisOptions), base[index].head, base[index].tail);
                return this.normalizeAtomCount(base, pool, k, avoidLetters, { requiredIndex: index });
            }

            makeAnchorPermutationNearMiss({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length < 2) return null;
                const anchor = this.state.rng.choice(letters);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of letters) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, null);
            }

            makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise) return null;
                const counts = new Map();
                nBackPremise.atoms.forEach(atom => {
                    counts.set(atom.head, (counts.get(atom.head) || 0) + 1);
                    counts.set(atom.tail, (counts.get(atom.tail) || 0) + 1);
                });
                const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
                if (!sorted.length || sorted[0][1] < 2) return null;
                const hub = sorted[0][0];
                const exclude = new Set(nBackPremise.getLetters());
                let newHub = this.sampleNewLetter(exclude);
                if (!newHub) return null;
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = atom.head === hub ? newHub : atom.head;
                    const tail = atom.tail === hub ? newHub : atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeCycleBorderBait({ k, pool, avoidLetters }) {
                const uniquePool = Array.from(new Set(pool));
                const targetLetters = Math.max(3, Math.min(k + 1, 6));
                const letters = [];
                const used = new Set();
                const shuffled = this.state.rng.shuffle(uniquePool);
                for (const letter of shuffled) {
                    if (letters.length >= targetLetters) break;
                    letters.push(letter);
                    used.add(letter);
                }
                while (letters.length < targetLetters) {
                    const next = this.sampleNewLetter(used);
                    if (!next) break;
                    letters.push(next);
                    used.add(next);
                }
                if (letters.length < 3) return null;
                const axes = ['N', 'E', 'S', 'W'];
                const atoms = [];
                for (let i = 0; i < Math.min(k, letters.length - 1); i++) {
                    const axis = axes[i % axes.length];
                    atoms.push(new Atom(axis, letters[i], letters[i + 1]));
                }
                if (atoms.length < k) {
                    const axis = axes[atoms.length % axes.length];
                    const head = letters[letters.length - 1];
                    const tailIndex = letters.length > 2 ? 1 : 0;
                    atoms.push(new Atom(axis, head, letters[tailIndex]));
                }
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeBipartiteSignatureMatch({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const targetFeatures = nBackPremise.getFeatures();
                for (let attempt = 0; attempt < 12; attempt++) {
                    const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    if (candidate.toKey() === nBackPremise.toKey()) continue;
                    if (!this.compareDegreeVectors(candidate.getFeatures().degreeVector, targetFeatures.degreeVector)) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeWrongLagCamouflage({ trialIndex, n, state, pool, k }) {
                let altPremise = null;
                if (n > 1) {
                    altPremise = state.getPremiseAt(trialIndex - (n - 1));
                }
                if (!altPremise) {
                    altPremise = state.getPremiseAt(trialIndex - (n + 1));
                }
                if (!altPremise) return null;
                for (let attempt = 0; attempt < 10; attempt++) {
                    const atoms = this.buildMatchCandidate(altPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    const equivalence = this.equivalence.computeCertificate(altPremise, candidate, []);
                    if (!equivalence.match) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeCrossAxisCoupling(context) {
                const { nBackPremise, pool, k, plannedMatch, avoidLetters } = context;
                if (!nBackPremise) {
                    return plannedMatch
                        ? this.buildMatchCandidate(nBackPremise, pool, k)
                        : this.buildNovelPremise(pool, k, avoidLetters);
                }
                if (plannedMatch) {
                    for (let attempt = 0; attempt < 12; attempt++) {
                        const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                        if (!atoms) return null;
                        const candidate = new Premise(atoms);
                        if (candidate.toKey() === nBackPremise.toKey()) continue;
                        if (!this.hasCrossAxisCoupling(nBackPremise, candidate)) continue;
                        return atoms;
                    }
                    return null;
                }
                const atoms = this.makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters });
                if (!atoms) return null;
                const candidate = new Premise(atoms);
                return this.hasCrossAxisCoupling(nBackPremise, candidate) ? atoms : null;
            }

            makeIsomorphicSkeletonDecoy({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length === 0) return null;
                const sorted = [...letters].sort();
                const anchor = this.state.rng.choice(sorted);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of sorted) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                const candidate = new Premise(atoms);
                if (candidate.isoSignature() !== nBackPremise.isoSignature()) {
                    return null;
                }
                return this.normalizeAtomCount(candidate.atoms, pool, k, null);
            }

            compareDegreeVectors(a, b) {
                if (a.size !== b.size) return false;
                for (const [letter, vecA] of a.entries()) {
                    const vecB = b.get(letter);
                    if (!vecB) return false;
                    for (let i = 0; i < vecA.length; i++) {
                        if (vecA[i] !== vecB[i]) return false;
                    }
                }
                return true;
            }

            collectAxisUsage(premise) {
                const usage = new Map();
                const mark = (letter, axis) => {
                    if (!usage.has(letter)) {
                        usage.set(letter, { vertical: false, horizontal: false });
                    }
                    const entry = usage.get(letter);
                    if (axis === 'N' || axis === 'S') {
                        entry.vertical = true;
                    } else {
                        entry.horizontal = true;
                    }
                };
                premise.atoms.forEach(atom => {
                    mark(atom.head, atom.axis);
                    mark(atom.tail, atom.axis);
                });
                return usage;
            }

            hasCrossAxisCoupling(p1, p2) {
                const usage1 = this.collectAxisUsage(p1);
                const usage2 = this.collectAxisUsage(p2);
                const letters = new Set([...usage1.keys(), ...usage2.keys()]);
                for (const letter of letters) {
                    const info1 = usage1.get(letter) || { vertical: false, horizontal: false };
                    const info2 = usage2.get(letter) || { vertical: false, horizontal: false };
                    if ((info1.vertical || info2.vertical) && (info1.horizontal || info2.horizontal)) {
                        return true;
                    }
                }
                return false;
            }

            buildMatchCandidate(nBackPremise, pool, k) {
                if (!nBackPremise) return null;
                const atoms = [];
                const nAtoms = nBackPremise.atoms;
                for (let i = 0; i < nAtoms.length; i++) {
                    const atom = nAtoms[i];
                    const invert = this.state.rng.next() < 0.6;
                    atoms.push(invert ? Atom.invert(atom) : new Atom(atom.axis, atom.head, atom.tail));
                }

                while (atoms.length < k) {
                    const head = this.state.rng.choice(pool);
                    const tailOptions = pool.filter(l => l !== head);
                    if (tailOptions.length === 0) break;
                    const tail = this.state.rng.choice(tailOptions);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    atoms.push(new Atom(axis, head, tail));
                }
                return atoms.slice(0, k);
            }

            buildNovelPremise(pool, k, avoidLetters) {
                const atoms = [];
                const usedPairs = new Set();
                const axisWeights = MATCH_AXES.map(axis => 1 / (1 + this.state.axisUsage[axis]));

                for (let i = 0; i < k; i++) {
                    let attempts = 0;
                    while (attempts < 40) {
                        let head = this.state.rng.choice(pool);
                        let tailCandidates = pool.filter(letter => letter !== head);
                        if (avoidLetters && avoidLetters.size > 0) {
                            const filtered = tailCandidates.filter(letter => !avoidLetters.has(letter));
                            if (filtered.length > 0) {
                                tailCandidates = filtered;
                            }
                            if (avoidLetters.has(head)) {
                                const alternatives = pool.filter(letter => !avoidLetters.has(letter));
                                if (alternatives.length > 0) {
                                    head = this.state.rng.choice(alternatives);
                                    tailCandidates = pool.filter(letter => letter !== head && !avoidLetters.has(letter));
                                }
                            }
                        }

                        if (tailCandidates.length === 0) break;
                        const tail = this.state.rng.choice(tailCandidates);
                        const pairKey = `${head}|${tail}`;
                        if (usedPairs.has(pairKey)) {
                            attempts++;
                            continue;
                        }

                        const axis = this.state.rng.weightedChoice(MATCH_AXES, axisWeights);
                        atoms.push(new Atom(axis, head, tail));
                        usedPairs.add(pairKey);
                        break;
                    }
                }

                return atoms.length === k ? atoms : null;
            }

            buildMetaPremise(plannedMatch, nBackPremise, k) {
                // Generate a META_RELATIONAL premise (6th-order reasoning)
                // k controls number of operator pairs: k=2 ‚Üí 4 ops, k=3 ‚Üí 6 ops, k=4 ‚Üí 8 ops
                const META_OPERATORS = ['North', 'South', 'East', 'West'];

                // Determine number of operators needed (k pairs = k*2 operators)
                // Minimum 2 pairs (4 operators) for a valid analogy
                const numPairs = Math.max(2, Math.min(4, k || 2));
                const numOperators = numPairs * 2;

                try {
                    if (plannedMatch && nBackPremise && nBackPremise.type === 'META_RELATIONAL') {
                        // For match trials, create a premise with same truth value
                        const nBackTruth = this.equivalence.getMetaTruthValue(nBackPremise);

                        // Defensive check
                        if (nBackTruth === 'INVALID') {
                            console.warn('buildMetaPremise: n-back has invalid truth value, generating random');
                            const shuffled = this.generateMetaOperators(numOperators);
                            return new Premise({
                                type: 'META_RELATIONAL',
                                p: shuffled
                            });
                        }

                        // Generate premises until we find one with matching truth value
                        for (let attempt = 0; attempt < 50; attempt++) {
                            const shuffled = this.generateMetaOperators(numOperators);

                            try {
                                const candidate = new Premise({
                                    type: 'META_RELATIONAL',
                                    p: shuffled
                                });

                                const candidateTruth = this.equivalence.getMetaTruthValue(candidate);

                                // Accept if truth values match AND not identical to n-back
                                if (candidateTruth === nBackTruth && candidate.toKey() !== nBackPremise.toKey()) {
                                    return candidate;
                                }
                            } catch (err) {
                                console.warn('buildMetaPremise: candidate creation failed', err);
                                continue;
                            }
                        }

                        console.warn('buildMetaPremise: failed to find matching truth value after 50 attempts');
                    }

                    // For non-match or first trials, or fallback, generate a random META premise
                    const shuffled = this.generateMetaOperators(numOperators);
                    return new Premise({
                        type: 'META_RELATIONAL',
                        p: shuffled
                    });
                } catch (err) {
                    console.error('buildMetaPremise: critical error', err);
                    // Ultimate fallback - return a known valid META premise
                    return new Premise({
                        type: 'META_RELATIONAL',
                        p: this.generateMetaOperators(numOperators)
                    });
                }
            }

            generateMetaOperators(numOperators) {
                // Generate numOperators operators, ensuring NO consecutive duplicates
                // Example: ['North', 'South', 'East', 'West'] OK
                // Example: ['North', 'North', 'East', 'West'] INVALID (North-North is identity)
                const META_OPERATORS = ['North', 'South', 'East', 'West'];
                const result = [];

                for (let i = 0; i < numOperators; i++) {
                    let op;
                    let attempts = 0;
                    do {
                        op = this.state.rng.choice(META_OPERATORS);
                        attempts++;
                        // Prevent infinite loop
                        if (attempts > 50) {
                            console.warn('generateMetaOperators: too many attempts to avoid duplicate');
                            break;
                        }
                    } while (i > 0 && op === result[i - 1]);  // No consecutive duplicates

                    result.push(op);
                }

                return result;
            }

            generateCompoundOperator() {
                // Generate a compound operator like "north-west" or "south-east"
                // ALWAYS exactly 2 DIFFERENT operators (no "north-north" identity)
                const META_OPERATORS = ['north', 'south', 'east', 'west'];
                const op1 = this.state.rng.choice(META_OPERATORS);

                // Ensure op2 is different from op1
                const otherOps = META_OPERATORS.filter(op => op !== op1);
                const op2 = this.state.rng.choice(otherOps);

                return `${op1}-${op2}`;
            }

            buildCompoundOperatorPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 7: Compound Operator Relational premise
                // Example: "north-west is north of south-east"
                // k controls number of atoms: k=1 ‚Üí 1 atom, k=2 ‚Üí 2 atoms, etc.

                const numAtoms = Math.max(1, Math.min(4, k || 1));
                const META_AXES = ['N', 'S', 'E', 'W'];
                const atoms = [];

                try {
                    for (let i = 0; i < numAtoms; i++) {
                        // Generate two compound operators (always 2-operator sequences)
                        const compound1 = this.generateCompoundOperator();
                        const compound2 = this.generateCompoundOperator();

                        // Choose random meta-operator to relate them
                        const metaAxis = this.state.rng.choice(META_AXES);

                        // Create atom with compound operators as head/tail
                        atoms.push(new Atom(metaAxis, compound1, compound2));
                    }

                    return new Premise(atoms);
                } catch (err) {
                    console.error('buildCompoundOperatorPremise: critical error', err);
                    // Fallback to simple compound premise
                    return new Premise([new Atom('N', 'north-west', 'south-east')]);
                }
            }

            buildDialecticalPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 1 (Da Vinci Mode): DIALECTICAL premise (Dual-Axis Simultaneous Constraint)
                // Cognitive Goal: Parallel processing / Superposition
                // Structure: Two atoms with same Head and Tail, but ORTHOGONAL axes (not opposites)
                // Example: A is North of B AND A is West of B ‚Üí Display: "A is North and West of B"
                // Constraint: Axes must be orthogonal (N+W, N+E, S+W, S+E), NOT opposites (N+S, E+W)

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRITICAL FIX #1: FORCE k=2 REGARDLESS OF PARAMETER
                // Mode 1 ALWAYS uses exactly 2 atoms (dialectical structure).
                // The k parameter might be stale from previous settings or race conditions.
                // IGNORE the parameter and enforce k=2 internally.
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const DIALECTICAL_K = 2;

                console.log('[buildDialecticalPremise] ENTRY - plannedMatch:', plannedMatch, 'nBackPremise:', nBackPremise, '| k param received:', k, '| FORCED k:', DIALECTICAL_K);

                try {
                    // MATCH HANDLING: Clone n-back premise structure with new letters
                    if (plannedMatch && nBackPremise) {
                        console.log('[buildDialecticalPremise] MATCH MODE - Cloning n-back structure');

                        // Verify n-back is dialectical type (2 atoms, same head/tail, orthogonal axes)
                        if (nBackPremise.atoms && nBackPremise.atoms.length === 2) {
                            const atom1 = nBackPremise.atoms[0];
                            const atom2 = nBackPremise.atoms[1];

                            // Extract axes from n-back
                            const axis1 = atom1.axis;
                            const axis2 = atom2.axis;

                            console.log('[buildDialecticalPremise] Extracted axes from n-back:', axis1, axis2);

                            // Clone with new letters - max 5 attempts
                            for (let attempt = 0; attempt < 5; attempt++) {
                                const pool = this.state.letterPool.nextPool(DIALECTICAL_K, { expand: false });
                                console.log(`[buildDialecticalPremise] MATCH attempt ${attempt + 1}/5: letterPool returned`, pool, 'length:', pool?.length);
                                if (!pool || pool.length < DIALECTICAL_K) {
                                    console.error(`[buildDialecticalPremise] MATCH attempt ${attempt + 1}/5: INSUFFICIENT LETTERS - pool:`, pool, 'length:', pool?.length, 'needed:', DIALECTICAL_K);
                                    continue;
                                }

                                const [letterA, letterB] = pool;

                                // Create atoms with SAME axes as n-back
                                const atoms = [
                                    new Atom(axis1, letterA, letterB),
                                    new Atom(axis2, letterA, letterB)
                                ];

                                // Validate with ConstraintSolver
                                const satResult = this.solver.evaluate([], atoms);
                                if (!satResult.ok) {
                                    console.error(`[buildDialecticalPremise] MATCH MODE Attempt ${attempt + 1}: SAT REJECTION - This should NOT happen after dialectical bypass fix!`, {
                                        reason: satResult.reason,
                                        atoms: atoms.map(a => `${a.axis}: ${a.head}->${a.tail}`),
                                        axes: [atoms[0].axis, atoms[1].axis],
                                        head: atoms[0].head,
                                        tail: atoms[0].tail
                                    });
                                    continue;
                                }

                                const premise = new Premise(atoms);

                                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                // CRITICAL FIX #4: TYPE VERIFICATION IN MATCH MODE
                                // Verify type detection succeeded before proceeding to equivalence check.
                                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                if (premise.type !== 'DIALECTIC') {
                                    console.error('[buildDialecticalPremise] MATCH MODE: Type detection failed!', {
                                        detected_type: premise.type,
                                        expected: 'DIALECTIC',
                                        atoms: premise.atoms.map(a => `${a.axis}:${a.head}->${a.tail}`)
                                    });
                                    premise.setType('DIALECTIC'); // Force correct type
                                }

                                // CRITICAL: Verify match with EquivalenceEngine
                                const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                                console.log('[buildDialecticalPremise] Match verification:', verification.match, '| reason:', verification.reason);

                                if (verification.match) {
                                    console.log('[buildDialecticalPremise] ‚úì SUCCESS - Valid MATCH created:', {
                                        atoms: premise.atoms.map(a => `${a.axis}:${a.head}->${a.tail}`),
                                        axes: [premise.atoms[0].axis, premise.atoms[1].axis].sort().join('-'),
                                        display: premise.toString(),
                                        type: premise.type,
                                        certificate: verification.certificate,
                                        nBack_axes: [nBackPremise.atoms[0].axis, nBackPremise.atoms[1].axis].sort().join('-')
                                    });
                                    return premise;
                                } else {
                                    console.warn(`[buildDialecticalPremise] MATCH Attempt ${attempt + 1}/5: EquivalenceEngine rejected - reason:`, verification.reason);
                                }
                            }

                            console.error('[buildDialecticalPremise] MATCH FAILED after 5 attempts - Falling back to buildNeutralNonMatch');
                            return null; // Caller will handle fallback
                        } else {
                            console.warn('[buildDialecticalPremise] n-back is not dialectical type, generating random');
                        }
                    }

                    // NO-MATCH MODE or FALLBACK: Generate random dialectical premise
                    console.log('[buildDialecticalPremise] NO-MATCH MODE - Generating random premise');

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL FIX #2: NO-MATCH MODE GUARANTEE WITH ULTIMATE FALLBACKS
                    // This section MUST ALWAYS succeed because it's not constrained by matching.
                    // We add multiple fallback layers to ensure success.
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                    let pool = this.state.letterPool.nextPool(DIALECTICAL_K, { expand: false });
                    console.log('[buildDialecticalPremise] NO-MATCH mode (expand=false): letterPool returned', pool, 'length:', pool?.length);

                    // FALLBACK LAYER 1: Try expanding pool if initial request failed
                    if (!pool || pool.length < DIALECTICAL_K) {
                        console.warn('[buildDialecticalPremise] Pool insufficient with expand=false, trying expand=true');
                        pool = this.state.letterPool.nextPool(DIALECTICAL_K, { expand: true });
                        console.log('[buildDialecticalPremise] NO-MATCH mode (expand=true): letterPool returned', pool, 'length:', pool?.length);
                    }

                    // FALLBACK LAYER 2: Use alphabet fallback if pool still insufficient
                    if (!pool || pool.length < DIALECTICAL_K) {
                        console.error('[buildDialecticalPremise] Pool still insufficient after expand=true, using ALPHABET FALLBACK');
                        pool = ['A', 'B']; // Guaranteed 2 letters
                    }

                    const [letterA, letterB] = pool;

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // ENHANCEMENT #1: AXIS ROTATION SYSTEM
                    // Use round-robin axis selection instead of random to ensure variety.
                    // Note: dialecticalAxisIndex is now initialized in GameState constructor (line 4435).
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                    const orthogonalPairs = [
                        ['N', 'W'], ['N', 'E'], ['S', 'W'], ['S', 'E']
                    ];
                    const pairIndex = this.state.dialecticalAxisIndex % orthogonalPairs.length;
                    const chosenPair = orthogonalPairs[pairIndex];
                    const [axis1, axis2] = chosenPair;

                    // Increment for next trial (round-robin)
                    this.state.dialecticalAxisIndex++;

                    console.log('[buildDialecticalPremise] Selected axis pair (round-robin):', axis1, '-', axis2, '| index:', pairIndex);

                    // Create two atoms with same head/tail, different orthogonal axes
                    const atoms = [
                        new Atom(axis1, letterA, letterB),
                        new Atom(axis2, letterA, letterB)
                    ];

                    // Validate with ConstraintSolver (should pass with dialectical bypass)
                    const satResult = this.solver.evaluate([], atoms);
                    if (!satResult.ok) {
                        // This should NEVER happen with dialectical bypass in place
                        console.error('[buildDialecticalPremise] CRITICAL: SAT REJECTION despite dialectical bypass!', {
                            reason: satResult.reason,
                            atoms: atoms.map(a => `${a.axis}: ${a.head}->${a.tail}`),
                            axes: [atoms[0].axis, atoms[1].axis],
                            head: atoms[0].head,
                            tail: atoms[0].tail,
                            bypass_check: this.solver.isDialecticalPremise(atoms)
                        });
                        return null;
                    }

                    // Create premise - auto-detection will set type to DIALECTIC
                    const premise = new Premise(atoms);

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL FIX #3: EXPLICIT TYPE VERIFICATION
                    // Verify that Premise.detectType() correctly identified this as DIALECTIC.
                    // If detection failed, log detailed diagnostic information.
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (premise.type !== 'DIALECTIC') {
                        console.error('[buildDialecticalPremise] CRITICAL: Type detection failed!', {
                            detected_type: premise.type,
                            expected_type: 'DIALECTIC',
                            atom_count: premise.atoms.length,
                            same_head: premise.atoms[0]?.head === premise.atoms[1]?.head,
                            same_tail: premise.atoms[0]?.tail === premise.atoms[1]?.tail,
                            axes: premise.atoms.map(a => a.axis),
                            atoms_detail: premise.atoms.map(a => `${a.axis}:${a.head}->${a.tail}`)
                        });
                        // Force type to DIALECTIC even if auto-detection failed
                        premise.setType('DIALECTIC');
                        console.warn('[buildDialecticalPremise] FORCED type to DIALECTIC manually');
                    }

                    // If this was supposed to be a non-match, verify it doesn't accidentally match
                    if (!plannedMatch && nBackPremise) {
                        const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                        if (verification.match) {
                            console.warn('[buildDialecticalPremise] Accidental match detected in NO-MATCH mode - Regenerating');
                            return null; // Caller will retry
                        }
                    }

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // ENHANCEMENT #2: COMPREHENSIVE SUCCESS LOGGING
                    // Log complete details of successful generation for debugging and validation.
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    console.log('[buildDialecticalPremise] ‚úì SUCCESS - Random NO-MATCH premise generated:', {
                        atoms: premise.atoms.map(a => `${a.axis}:${a.head}->${a.tail}`),
                        axes: [premise.atoms[0].axis, premise.atoms[1].axis].sort().join('-'),
                        display: premise.toString(),
                        type: premise.type,
                        letterA,
                        letterB,
                        axis_pair: `${axis1}-${axis2}`,
                        round_robin_index: pairIndex
                    });

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL FINAL VALIDATION - Ensure premise is structurally valid
                    // If this fails, it indicates a logic error in premise generation.
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (!premise || !premise.atoms || premise.atoms.length !== 2) {
                        const diagnostic = {
                            premise_exists: !!premise,
                            atoms_exists: !!(premise && premise.atoms),
                            atom_count: premise?.atoms?.length,
                            expected_count: 2,
                            atoms_detail: premise?.atoms?.map(a => ({
                                axis: a.axis,
                                head: a.head,
                                tail: a.tail,
                                toString: a.toString()
                            })),
                            premise_toString: premise?.toString(),
                            premise_type: premise?.type
                        };

                        console.error('[buildDialecticalPremise] ‚ùå CRITICAL VALIDATION FAILURE - Invalid premise structure');
                        console.error('[buildDialecticalPremise] Diagnostic details:', JSON.stringify(diagnostic, null, 2));

                        throw new Error(`buildDialecticalPremise returned structurally invalid premise. Expected 2 atoms, got ${premise?.atoms?.length}. See console for full diagnostic.`);
                    }

                    if (premise.type !== 'DIALECTIC') {
                        console.error('[buildDialecticalPremise] ‚ùå CRITICAL: Type is NOT DIALECTIC even after forced setting!', {
                            actual_type: premise.type,
                            expected_type: 'DIALECTIC',
                            atoms: premise.atoms.map(a => `${a.axis}:${a.head}->${a.tail}`),
                            detectType_result: premise.detectType()
                        });

                        // Attempt forced correction one more time
                        console.warn('[buildDialecticalPremise] Attempting emergency type correction...');
                        premise.type = 'DIALECTIC';

                        // Verify correction worked
                        if (premise.type !== 'DIALECTIC') {
                            throw new Error(`Unable to force premise.type to DIALECTIC. Type setter may be broken. Current type: ${premise.type}`);
                        }

                        console.log('[buildDialecticalPremise] ‚úì Emergency type correction successful');
                    }

                    // Validate toString() output format
                    const displayString = premise.toString();
                    const expectedPattern = /^[A-Z] is (north|south|east|west) and (north|south|east|west) [A-Z]$/i;

                    if (!expectedPattern.test(displayString)) {
                        console.warn('[buildDialecticalPremise] ‚ö†Ô∏è WARNING: toString() output does not match expected dialectical format', {
                            actual_output: displayString,
                            expected_pattern: 'A is [direction] and [direction] B',
                            premise_type: premise.type,
                            atom_count: premise.atoms.length
                        });
                        // Don't throw - just warn. toString() might have alternate valid formats.
                    }

                    console.log('[buildDialecticalPremise] ‚úÖ FINAL VALIDATION PASSED - Premise is valid:', {
                        atom_count: premise.atoms.length,
                        type: premise.type,
                        display: displayString,
                        axes: premise.atoms.map(a => a.axis).join('-')
                    });

                    return premise;
                } catch (err) {
                    console.error('buildDialecticalPremise: critical error', err);
                    return null;
                }
            }

            buildTriadicPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 2 (Da Vinci Mode): SEMANTIC TENSOR premise (Cross-Domain Intersection)
                // Cognitive Goal: Solving A = f(B) ‚à© g(C) where f and g are different transformations
                // Structure: One Head relates to TWO distinct Tails via TWO ORTHOGONAL axes
                // Example: A is North of B AND A is East of C
                // Constraint: Axes must be orthogonal (N+E, N+W, S+E, S+W), B ‚â† C

                console.log('[buildTriadicPremise] ENTRY - plannedMatch:', plannedMatch, 'nBackPremise:', nBackPremise);

                try {
                    // MATCH HANDLING: Clone n-back premise structure with new letters
                    if (plannedMatch && nBackPremise) {
                        console.log('[buildTriadicPremise] MATCH MODE - Cloning n-back structure');

                        // Verify n-back is triadic type (2 atoms, same head, different tails)
                        if (nBackPremise.atoms && nBackPremise.atoms.length === 2) {
                            const atom1 = nBackPremise.atoms[0];
                            const atom2 = nBackPremise.atoms[1];

                            // Extract axes from n-back
                            const axis1 = atom1.axis;
                            const axis2 = atom2.axis;

                            console.log('[buildTriadicPremise] Extracted axes from n-back:', axis1, axis2);

                            // Clone with new letters - max 5 attempts
                            for (let attempt = 0; attempt < 5; attempt++) {
                                const pool = this.state.letterPool.nextPool(3, { expand: false });
                                if (!pool || pool.length < 3) {
                                    console.warn(`[buildTriadicPremise] Attempt ${attempt + 1}: insufficient letters`);
                                    continue;
                                }

                                const [letterA, letterB, letterC] = pool;

                                // Create atoms with SAME axes as n-back
                                const atoms = [
                                    new Atom(axis1, letterA, letterB),
                                    new Atom(axis2, letterA, letterC)
                                ];

                                // Validate with ConstraintSolver
                                const satResult = this.solver.evaluate([], atoms);
                                if (!satResult.ok) {
                                    console.warn(`[buildTriadicPremise] Attempt ${attempt + 1}: SAT rejected`);
                                    continue;
                                }

                                const premise = new Premise(atoms);

                                // CRITICAL: Verify match with EquivalenceEngine
                                const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                                console.log('[buildTriadicPremise] Match verification:', verification.match);

                                if (verification.match) {
                                    console.log('[buildTriadicPremise] SUCCESS - Valid match created');
                                    return premise;
                                } else {
                                    console.warn(`[buildTriadicPremise] Attempt ${attempt + 1}: EquivalenceEngine rejected match`);
                                }
                            }

                            console.error('[buildTriadicPremise] MATCH FAILED after 5 attempts - Falling back');
                            return null; // Caller will handle fallback
                        } else {
                            console.warn('[buildTriadicPremise] n-back is not triadic type, generating random');
                        }
                    }

                    // NO-MATCH MODE or FALLBACK: Generate random triadic premise
                    console.log('[buildTriadicPremise] NO-MATCH MODE - Generating random premise');

                    const pool = this.state.letterPool.nextPool(3, { expand: false });
                    if (!pool || pool.length < 3) {
                        console.warn('buildTriadicPremise: insufficient letters in pool');
                        return null;
                    }

                    const [letterA, letterB, letterC] = pool;

                    // Choose 2 ORTHOGONAL axes (not the same axis, not opposites)
                    const orthogonalPairs = [
                        ['N', 'E'], ['N', 'W'], ['S', 'E'], ['S', 'W']
                    ];
                    const chosenPair = this.state.rng.choice(orthogonalPairs);
                    const [axis1, axis2] = chosenPair;

                    // Create two atoms:
                    // 1. A is [axis1] of B
                    // 2. A is [axis2] of C
                    const atoms = [
                        new Atom(axis1, letterA, letterB),
                        new Atom(axis2, letterA, letterC)
                    ];

                    // Validate with ConstraintSolver
                    const satResult = this.solver.evaluate([], atoms);
                    if (!satResult.ok) {
                        console.warn('buildTriadicPremise: ConstraintSolver rejected configuration');
                        return null;
                    }

                    // Create premise - auto-detection will set type to TENSOR
                    const premise = new Premise(atoms);

                    // If this was supposed to be a non-match, verify it doesn't accidentally match
                    if (!plannedMatch && nBackPremise) {
                        const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                        if (verification.match) {
                            console.warn('[buildTriadicPremise] Accidental match detected in NO-MATCH mode - Regenerating');
                            return null; // Caller will retry
                        }
                    }

                    console.log('[buildTriadicPremise] Random premise generated successfully');
                    return premise;
                } catch (err) {
                    console.error('buildTriadicPremise: critical error', err);
                    return null;
                }
            }

            buildAlgebraicPremise(plannedMatch, nBackPremise, k) {
                // Generate Level 3 (Da Vinci Mode): SYSTEM HOMOLOGY premise (Second-Order Isomorphism)
                // Cognitive Goal: Comparing structural dynamics of two domains
                // Structure: 4-node graph with 2 visible (A, B), 2 hidden (X, Y)
                //   - X is [axis1] of A (hidden derivative of A)
                //   - Y is [axis1] of B (hidden derivative of B - SAME AXIS as X‚ÜíA)
                //   - X is [axis3] of Y (relationship between hidden nodes)
                // Display: "(North of A) is East of (North of B)"
                // This reveals meta-structural equivalence: both domains transform the same way

                console.log('[buildAlgebraicPremise] ENTRY - plannedMatch:', plannedMatch, 'nBackPremise:', nBackPremise);

                try {
                    // MATCH HANDLING: Clone n-back premise structure with new letters
                    if (plannedMatch && nBackPremise) {
                        console.log('[buildAlgebraicPremise] MATCH MODE - Cloning n-back structure');

                        // Verify n-back is algebraic type (3 atoms, 4 nodes)
                        if (nBackPremise.atoms && nBackPremise.atoms.length === 3) {
                            // Extract axis structure from n-back
                            const axis1 = nBackPremise.atoms[0].axis; // X‚ÜíA axis
                            const axis3 = nBackPremise.atoms[2].axis; // X‚ÜíY axis

                            console.log('[buildAlgebraicPremise] Extracted axes from n-back - axis1:', axis1, 'axis3:', axis3);

                            // Clone with new letters - max 5 attempts
                            for (let attempt = 0; attempt < 5; attempt++) {
                                const pool = this.state.letterPool.nextPool(4, { expand: false });
                                if (!pool || pool.length < 4) {
                                    console.warn(`[buildAlgebraicPremise] Attempt ${attempt + 1}: insufficient letters`);
                                    continue;
                                }

                                const [letterA, letterB, letterX, letterY] = pool;
                                const visibleNodes = [letterA, letterB];
                                const hiddenNodes = [letterX, letterY];

                                // Create atoms with SAME axis structure as n-back
                                const atoms = [
                                    new Atom(axis1, letterX, letterA),
                                    new Atom(axis1, letterY, letterB),
                                    new Atom(axis3, letterX, letterY)
                                ];

                                // Validate with ConstraintSolver
                                const satResult = this.solver.evaluate([], atoms);
                                if (!satResult.ok) {
                                    console.warn(`[buildAlgebraicPremise] Attempt ${attempt + 1}: SAT rejected`);
                                    continue;
                                }

                                const premise = new Premise(atoms);
                                premise.setType('HOMOLOGY');
                                premise.setHomologyMetadata(visibleNodes, hiddenNodes);

                                // CRITICAL: Verify match with EquivalenceEngine
                                const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                                console.log('[buildAlgebraicPremise] Match verification:', verification.match);

                                if (verification.match) {
                                    console.log('[buildAlgebraicPremise] SUCCESS - Valid match created');
                                    return premise;
                                } else {
                                    console.warn(`[buildAlgebraicPremise] Attempt ${attempt + 1}: EquivalenceEngine rejected match`);
                                }
                            }

                            console.error('[buildAlgebraicPremise] MATCH FAILED after 5 attempts - Falling back');
                            return null;
                        } else {
                            console.warn('[buildAlgebraicPremise] n-back is not algebraic type, generating random');
                        }
                    }

                    // NO-MATCH MODE or FALLBACK: Generate random algebraic premise
                    console.log('[buildAlgebraicPremise] NO-MATCH MODE - Generating random premise');

                    const pool = this.state.letterPool.nextPool(4, { expand: false });
                    if (!pool || pool.length < 4) {
                        console.warn('buildAlgebraicPremise: insufficient letters in pool');
                        return null;
                    }

                    const [letterA, letterB, letterX, letterY] = pool;
                    const visibleNodes = [letterA, letterB];
                    const hiddenNodes = [letterX, letterY];

                    // Choose axes:
                    // axis1: Used for BOTH X‚ÜíA and Y‚ÜíB (structural equivalence)
                    // axis3: Relationship between X and Y
                    const axes = ['N', 'S', 'E', 'W'];
                    const axis1 = this.state.rng.choice(axes); // Same transformation for both domains
                    const axis3 = this.state.rng.choice(axes); // Cross-domain relationship

                    // Create 3 atoms:
                    // 1. X is [axis1] of A (hidden derivative of domain A)
                    // 2. Y is [axis1] of B (hidden derivative of domain B - SAME transformation)
                    // 3. X is [axis3] of Y (relationship between derivatives)
                    const atoms = [
                        new Atom(axis1, letterX, letterA),
                        new Atom(axis1, letterY, letterB),  // CHANGED: Use axis1 (not random axis2)
                        new Atom(axis3, letterX, letterY)
                    ];

                    // Validate with ConstraintSolver (ensures no spatial contradictions)
                    const satResult = this.solver.evaluate([], atoms);
                    if (!satResult.ok) {
                        console.warn('buildAlgebraicPremise: ConstraintSolver rejected configuration');
                        return null;
                    }

                    // Create premise
                    const premise = new Premise(atoms);

                    // Explicitly set type to HOMOLOGY and store metadata
                    premise.setType('HOMOLOGY');
                    premise.setHomologyMetadata(visibleNodes, hiddenNodes);

                    // If this was supposed to be a non-match, verify it doesn't accidentally match
                    if (!plannedMatch && nBackPremise) {
                        const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                        if (verification.match) {
                            console.warn('[buildAlgebraicPremise] Accidental match detected in NO-MATCH mode - Regenerating');
                            return null;
                        }
                    }

                    console.log('[buildAlgebraicPremise] Random premise generated successfully');
                    return premise;
                } catch (err) {
                    console.error('buildAlgebraicPremise: critical error', err);
                    return null;
                }
            }

            buildInterfacePremise(plannedMatch, nBackPremise, k) {
                // Generate Level 4 (Da Vinci Mode): COMPLEMENTARY INTERFACE premise (Heterogeneous Integration)
                // Cognitive Goal: Do two different complex processes fit together functionally?
                // Topology: 6 nodes - 2 Roots (A, B), 2 Intermediates (I1, I2), 2 Endpoints (E1, E2)
                //
                // Path A (North‚ÜíWest): I1 ‚Üí A, E1 ‚Üí I1
                // Path B (South‚ÜíEast): I2 ‚Üí B, E2 ‚Üí I2
                // Interface: E1 ‚Üí E2
                //
                // Display: "(North-West of A) is West of (South-East of B)"
                // This reveals whether two divergent processes have compatible endpoints

                console.log('[buildInterfacePremise] ENTRY - plannedMatch:', plannedMatch, 'nBackPremise:', nBackPremise);

                try {
                    // MATCH HANDLING: Clone n-back premise structure with new letters
                    if (plannedMatch && nBackPremise) {
                        console.log('[buildInterfacePremise] MATCH MODE - Cloning n-back structure');

                        // Verify n-back is interface type (5 atoms, 6 nodes)
                        if (nBackPremise.atoms && nBackPremise.atoms.length === 5) {
                            // Extract axis structure from n-back (assuming fixed structure: atomA1, atomA2, atomB1, atomB2, atomInterface)
                            const pathA_axis1 = nBackPremise.atoms[0].axis;
                            const pathA_axis2 = nBackPremise.atoms[1].axis;
                            const pathB_axis1 = nBackPremise.atoms[2].axis;
                            const pathB_axis2 = nBackPremise.atoms[3].axis;
                            const interfaceAxis = nBackPremise.atoms[4].axis;

                            console.log('[buildInterfacePremise] Extracted axes from n-back - PathA:', pathA_axis1, pathA_axis2, 'PathB:', pathB_axis1, pathB_axis2, 'Interface:', interfaceAxis);

                            // Clone with new letters - max 5 attempts
                            for (let attempt = 0; attempt < 5; attempt++) {
                                const pool = this.state.letterPool.nextPool(6, { expand: false });
                                if (!pool || pool.length < 6) {
                                    console.warn(`[buildInterfacePremise] Attempt ${attempt + 1}: insufficient letters`);
                                    continue;
                                }

                                const [letterA, letterB, letterI1, letterI2, letterE1, letterE2] = pool;

                                // Create atoms with SAME axis structure as n-back
                                const atomA1 = new Atom(pathA_axis1, letterI1, letterA);
                                const atomA2 = new Atom(pathA_axis2, letterE1, letterI1);
                                const atomB1 = new Atom(pathB_axis1, letterI2, letterB);
                                const atomB2 = new Atom(pathB_axis2, letterE2, letterI2);
                                const atomInterface = new Atom(interfaceAxis, letterE1, letterE2);

                                const atoms = [atomA1, atomA2, atomB1, atomB2, atomInterface];

                                // Validate with ConstraintSolver
                                const satResult = this.solver.evaluate([], atoms);
                                if (!satResult.ok) {
                                    console.warn(`[buildInterfacePremise] Attempt ${attempt + 1}: SAT rejected`);
                                    continue;
                                }

                                const premise = new Premise(atoms);
                                premise.setType('INTERFACE');
                                premise.setInterfaceMetadata({
                                    roots: [letterA, letterB],
                                    intermediates: [letterI1, letterI2],
                                    endpoints: [letterE1, letterE2],
                                    pathA: { axis1: pathA_axis1, axis2: pathA_axis2 },
                                    pathB: { axis1: pathB_axis1, axis2: pathB_axis2 },
                                    interfaceAxis: interfaceAxis
                                });

                                // CRITICAL: Verify match with EquivalenceEngine
                                const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                                console.log('[buildInterfacePremise] Match verification:', verification.match);

                                if (verification.match) {
                                    console.log('[buildInterfacePremise] SUCCESS - Valid match created');
                                    return premise;
                                } else {
                                    console.warn(`[buildInterfacePremise] Attempt ${attempt + 1}: EquivalenceEngine rejected match`);
                                }
                            }

                            console.error('[buildInterfacePremise] MATCH FAILED after 5 attempts - Falling back');
                            return null;
                        } else {
                            console.warn('[buildInterfacePremise] n-back is not interface type, generating random');
                        }
                    }

                    // NO-MATCH MODE or FALLBACK: Generate random interface premise
                    console.log('[buildInterfacePremise] NO-MATCH MODE - Generating random premise');

                    const pool = this.state.letterPool.nextPool(6, { expand: false });
                    if (!pool || pool.length < 6) {
                        console.warn('buildInterfacePremise: insufficient letters in pool');
                        return null;
                    }

                    const [letterA, letterB, letterI1, letterI2, letterE1, letterE2] = pool;

                    // Define the two paths with asymmetric transformations
                    // Path A: North (generalization) ‚Üí West (analogue shift)
                    const pathA_axis1 = 'N';  // I1 is North of A
                    const pathA_axis2 = 'W';  // E1 is West of I1

                    // Path B: South (specification) ‚Üí East (analogue shift)
                    const pathB_axis1 = 'S';  // I2 is South of B
                    const pathB_axis2 = 'E';  // E2 is East of I2

                    // Interface axis (relationship between endpoints)
                    // Choose from orthogonal options to Path A and Path B endpoints
                    const interfaceAxisOptions = ['N', 'S', 'E', 'W'];
                    const interfaceAxis = this.state.rng.choice(interfaceAxisOptions);

                    // Create 5 atoms:
                    // Path A: 2 atoms
                    const atomA1 = new Atom(pathA_axis1, letterI1, letterA);  // I1 is North of A
                    const atomA2 = new Atom(pathA_axis2, letterE1, letterI1); // E1 is West of I1

                    // Path B: 2 atoms
                    const atomB1 = new Atom(pathB_axis1, letterI2, letterB);  // I2 is South of B
                    const atomB2 = new Atom(pathB_axis2, letterE2, letterI2); // E2 is East of I2

                    // Interface: 1 atom
                    const atomInterface = new Atom(interfaceAxis, letterE1, letterE2); // E1 is [axis] of E2

                    const atoms = [atomA1, atomA2, atomB1, atomB2, atomInterface];

                    // Validate with ConstraintSolver (ensures no spatial contradictions)
                    const satResult = this.solver.evaluate([], atoms);
                    if (!satResult.ok) {
                        console.warn('buildInterfacePremise: ConstraintSolver rejected configuration');
                        return null;
                    }

                    // Create premise
                    const premise = new Premise(atoms);

                    // Explicitly set type to INTERFACE and store metadata
                    premise.setType('INTERFACE');

                    // Store metadata for rendering
                    premise.setInterfaceMetadata({
                        roots: [letterA, letterB],
                        intermediates: [letterI1, letterI2],
                        endpoints: [letterE1, letterE2],
                        pathA: { axis1: pathA_axis1, axis2: pathA_axis2 },
                        pathB: { axis1: pathB_axis1, axis2: pathB_axis2 },
                        interfaceAxis: interfaceAxis
                    });

                    // If this was supposed to be a non-match, verify it doesn't accidentally match
                    if (!plannedMatch && nBackPremise) {
                        const verification = this.equivalence.computeCertificate(nBackPremise, premise, [], []);
                        if (verification.match) {
                            console.warn('[buildInterfacePremise] Accidental match detected in NO-MATCH mode - Regenerating');
                            return null;
                        }
                    }

                    console.log('[buildInterfacePremise] Random premise generated successfully');
                    return premise;
                } catch (err) {
                    console.error('buildInterfacePremise: critical error', err);
                    return null;
                }
            }

        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // iOS-SPECIFIC FEMALE VOICE ENFORCEMENT SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // This VoiceSynthesis class implements comprehensive iOS Safari
        // Web Speech API bug workarounds to prevent male voice (Reed) usage.
        //
        // iOS CRITICAL BUGS FIXED:
        //
        // 1. VOICE OBJECT STALENESS (PRIMARY BUG):
        //    - Voice objects from getVoices() become "stale" when cached
        //    - Stale voice objects assigned to utterance.voice are IGNORED
        //    - iOS falls back to system default voice (Reed - MALE)
        //    - FIX: Store voiceName + voiceLang as STRINGS only
        //    - FIX: Call getFreshVoiceObject() before EVERY speak()
        //
        // 2. DUAL PROPERTY REQUIREMENT:
        //    - iOS requires BOTH utterance.voice AND utterance.lang set
        //    - Setting only ONE property causes iOS to IGNORE both
        //    - iOS falls back to default voice (Reed - MALE)
        //    - FIX: Always set both properties together in speak()
        //
        // 3. ONE VOICE PER LOCALE LIMITATION:
        //    - iOS allows only ONE voice per locale to be selected
        //    - For en-US, that voice is Samantha (FEMALE) - this is GOOD
        //    - Attempting other en-US voices causes fallback to Reed
        //    - FIX: Priority cascade locks to Samantha for iOS
        //
        // 4. ASYNCHRONOUS VOICE LOADING:
        //    - getVoices() returns empty array on first call
        //    - voiceschanged event is unreliable/never fires on Safari
        //    - FIX: Polling mechanism (250ms interval, 3000ms timeout)
        //
        // 5. USER GESTURE REQUIREMENT:
        //    - iOS requires speechSynthesis triggered from user interaction
        //    - FIX: unlockIOSSpeech() speaks empty utterance on button click
        //
        // SAFETY LAYERS:
        // - Layer 1: Null check - refuse if voiceName/voiceLang null
        // - Layer 2: Male voice pattern check - refuse if matches Reed, etc.
        // - Layer 3: Female voice confirmation - warn if no female match
        // - Layer 4: utterance.voice verification - refuse if not set
        // - Layer 5: iOS dual-property check - refuse if only one set
        // - Layer 6: Final male voice check - refuse if assigned voice is male
        //
        // All safety checks REFUSE TO SPEAK rather than risk default voice.
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        class VoiceSynthesis {
            constructor() {
                this.synth = window.speechSynthesis;

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL FIX: Store voice NAME and LANG, NOT voice object
                // Voice objects become "stale" on iOS and cause fallback to Reed
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.voiceName = null;          // Store voice name as string
                this.voiceLang = null;          // Store voice lang as string
                this.voiceReady = false;
                this.pitch = 1.2;
                this.rate = 0.9;
                this.volume = 1.0;
                this.sessionToken = makeEpoch();

                // iOS-specific flags
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                            (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                this.iosGestureUnlocked = false;

                console.log(`üé§ VoiceSynthesis initialized - Platform: ${this.isIOS ? 'iOS' : 'Desktop'}`);
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: User Gesture Unlock
            // iOS requires speechSynthesis to be triggered from user interaction
            // Call this on voice-mode button click to unlock speech for session
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            unlockIOSSpeech() {
                if (!this.isIOS || this.iosGestureUnlocked) {
                    return;
                }

                try {
                    // Speak empty utterance to unlock iOS speech synthesis
                    const unlockUtterance = new SpeechSynthesisUtterance('');
                    unlockUtterance.volume = 0;
                    this.synth.speak(unlockUtterance);
                    this.iosGestureUnlocked = true;
                    console.log('‚úì iOS speech synthesis unlocked via user gesture');
                } catch (err) {
                    console.warn('iOS gesture unlock failed:', err);
                }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: Polling-Based Voice Loading
            // iOS Safari returns empty array on first getVoices() call
            // voiceschanged event is unreliable - use polling instead
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            async initialize() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`  Initializing voice system - Platform: ${this.isIOS ? 'iOS' : 'Desktop'}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // iOS: Unlock speech from user gesture (if not already done)
                if (this.isIOS) {
                    this.unlockIOSSpeech();
                }

                return new Promise((resolve, reject) => {
                    let pollAttempts = 0;
                    const maxPollAttempts = 12; // 12 √ó 250ms = 3000ms max wait
                    const pollIntervalMs = 250; // Poll every 250ms

                    let pollInterval = null;
                    let pollTimeout = null;

                    const stopPolling = () => {
                        if (pollInterval) clearInterval(pollInterval);
                        if (pollTimeout) clearTimeout(pollTimeout);
                    };

                    // Polling function
                    const pollForVoices = () => {
                        pollAttempts++;
                        console.log(`üì¢ Polling for voices... attempt ${pollAttempts}/${maxPollAttempts}`);

                        try {
                            const voices = this.synth.getVoices();
                            console.log(`  Retrieved ${voices?.length || 0} voices from speechSynthesis.getVoices()`);

                            if (voices && voices.length > 0) {
                                // SUCCESS: Voices loaded
                                stopPolling();
                                console.log(`‚úì Voices loaded successfully after ${pollAttempts} attempts`);

                                try {
                                    this.selectVoice(voices);
                                    this.voiceReady = true;
                                    console.log(`‚úì Voice system initialized: ${this.voiceName || 'null'} (${this.voiceLang || 'null'})`);
                                    resolve();
                                } catch (err) {
                                    console.error('Voice selection failed:', err);
                                    reject(err);
                                }
                            }
                        } catch (error) {
                            console.error('Polling error:', error);
                            stopPolling();
                            reject(error);
                        }
                    };

                    // Timeout handler
                    pollTimeout = setTimeout(() => {
                        stopPolling();
                        console.error('‚úó Voice loading timeout after 3000ms');
                        reject(new Error('Voice loading timeout - no voices available'));
                    }, 3000);

                    // Start polling every 250ms
                    pollInterval = setInterval(pollForVoices, pollIntervalMs);

                    // Immediate first attempt
                    pollForVoices();

                    // Also listen for voiceschanged event (unreliable on iOS but doesn't hurt)
                    if (this.synth.onvoiceschanged !== undefined) {
                        this.synth.onvoiceschanged = () => {
                            console.log('  voiceschanged event fired (backup trigger)');
                            pollForVoices();
                        };
                    }
                });
            }

            selectVoice(voices) {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('    ULTRA-COMPREHENSIVE FEMALE-ONLY VOICE SELECTION (ANY LANGUAGE)');
                console.log('    USER REQUIREMENT: ANY female voice, ZERO male voices');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Total voices available: ${voices.length}`);

                // Log all available voices for debugging
                voices.forEach((v, idx) => {
                    console.log(`  [${idx}] ${v.name} (${v.lang}) - ${v.localService ? 'local' : 'remote'}`);
                });

                // Detect platform
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                const platform = isIOS ? 'iOS' : 'Desktop';
                console.log(`Platform detected: ${platform}`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 1: WESTERN-ONLY LANGUAGE WHITELIST
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const westernLanguageCodes = [
                    'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',
                    'en', // Generic English
                    'fr-FR', 'fr-CA', 'fr-BE', 'fr-CH',
                    'de-DE', 'de-AT', 'de-CH',
                    'es-ES', 'es-MX', 'es-AR',
                    'it-IT', 'it-CH',
                    'pt-PT', 'pt-BR',
                    'nl-NL', 'nl-BE',
                    'sv-SE',
                    'da-DK',
                    'no-NO',
                    'fi-FI',
                    'pl-PL',
                    'cs-CZ',
                    'hu-HU',
                    'ro-RO',
                    'el-GR'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 2: NON-WESTERN LANGUAGE/ACCENT EXCLUSION (COMPLETE BLACKLIST)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const nonWesternLanguageCodes = [
                    // INDIAN LANGUAGES (ALL INDIAN ACCENTS - CRITICAL EXCLUSION)
                    'hi-IN', 'hi', 'ta-IN', 'ta', 'bn-IN', 'bn', 'te-IN', 'te',
                    'mr-IN', 'mr', 'gu-IN', 'gu', 'kn-IN', 'kn', 'ml-IN', 'ml',
                    'pa-IN', 'pa', 'or-IN', 'or', 'as-IN', 'as', 'ur-IN', 'ur',

                    // CHINESE LANGUAGES
                    'zh-CN', 'zh-TW', 'zh-HK', 'zh', 'cmn', 'yue', 'nan',

                    // JAPANESE
                    'ja-JP', 'ja',

                    // KOREAN
                    'ko-KR', 'ko',

                    // ARABIC LANGUAGES
                    'ar-SA', 'ar-EG', 'ar-AE', 'ar-DZ', 'ar', 'ar-MA', 'ar-TN',
                    'ar-IQ', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-OM', 'ar-QA',

                    // RUSSIAN/SLAVIC (non-Western European)
                    'ru-RU', 'ru', 'uk-UA', 'uk', 'be-BY', 'be',

                    // THAI
                    'th-TH', 'th',

                    // VIETNAMESE
                    'vi-VN', 'vi',

                    // INDONESIAN/MALAY
                    'id-ID', 'id', 'ms-MY', 'ms',

                    // TURKISH
                    'tr-TR', 'tr',

                    // PERSIAN
                    'fa-IR', 'fa',

                    // HEBREW
                    'he-IL', 'he', 'iw-IL', 'iw'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 3: EXHAUSTIVE MALE VOICE EXCLUSION LIST (100+ NAMES)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const maleVoiceNames = [
                    // ‚ïê‚ïê‚ïê COMMON ENGLISH MALE VOICES ‚ïê‚ïê‚ïê
                    'Alex', 'Daniel', 'Fred', 'Tom', 'Thomas', 'Oliver', 'Ralph',
                    'Bruce', 'James', 'John', 'Nathan', 'Aaron', 'Jorge', 'Diego',
                    'Timothy', 'Mark', 'David', 'Richard', 'Chris', 'Christopher',
                    'Matthew', 'Paul', 'George', 'Kevin', 'Jason', 'Michael', 'Robert',
                    'William', 'Joseph', 'Charles', 'Steven', 'Edward', 'Brian',
                    'Andrew', 'Anthony', 'Donald', 'Kenneth', 'Joshua', 'Brandon',
                    'Justin', 'Ryan', 'Eric', 'Nicholas', 'Jacob', 'Jonathan',
                    'Samuel', 'Benjamin', 'Patrick', 'Alexander', 'Jack', 'Henry',
                    'Oscar', 'Adam', 'Ethan', 'Noah', 'Liam', 'Mason', 'Logan',
                    'Lucas', 'Isaac', 'Nathan', 'Caleb', 'Christian', 'Hunter',
                    'Jordan', 'Dylan', 'Brandon', 'Jose', 'Austin', 'Evan',
                    'Sean', 'Tyler', 'Kyle', 'Ian', 'Carter', 'Xavier',

                    // ‚ïê‚ïê‚ïê CRITICAL iOS/macOS MALE VOICES (PREVIOUSLY MISSING - MOST LIKELY CULPRITS) ‚ïê‚ïê‚ïê
                    'Reed', 'Reed (Enhanced)', 'Reed (Compact)',
                    'Rocko', 'Rocko (Enhanced)', 'Rocko (Compact)',
                    'Lee', 'Lee (Enhanced)', 'Lee (Compact)',
                    'Gordon', 'Gordon (Enhanced)', 'Gordon (Compact)',
                    'Martin', 'Martin (Enhanced)', 'Martin (Compact)',
                    'Xander', 'Xander (Enhanced)', 'Xander (Compact)',
                    'Yuri', 'Yuri (Enhanced)', 'Yuri (Compact)',
                    'Otoya', 'Otoya (Enhanced)', 'Otoya (Compact)',
                    'Maged', 'Maged (Enhanced)', 'Maged (Compact)',
                    'Majed', 'Majed (Enhanced)', 'Majed (Compact)',
                    'Tarik', 'Tarik (Enhanced)', 'Tarik (Compact)',

                    // ‚ïê‚ïê‚ïê ADDITIONAL iOS/macOS MALE VOICES ‚ïê‚ïê‚ïê
                    'Carmit', 'Carmit (Enhanced)', 'Carmit (Compact)',
                    'Lekha', 'Lekha (Enhanced)', 'Lekha (Compact)',
                    'Lesya', 'Lesya (Enhanced)', 'Lesya (Compact)',
                    'Luca', 'Luca (Enhanced)', 'Luca (Compact)',
                    'Maged', 'Majed', 'Tarik',
                    'Yannick', 'Yannick (Enhanced)', 'Yannick (Compact)',
                    'Steffi', 'Steffi (Enhanced)', 'Steffi (Compact)',
                    'Yuri', 'Yuri (Enhanced)', 'Yuri (Compact)',
                    'Xander', 'Xander (Enhanced)', 'Xander (Compact)',

                    // ‚ïê‚ïê‚ïê SIRI MALE VARIANTS (ALL) ‚ïê‚ïê‚ïê
                    'Siri Male', 'Siri Male (Enhanced)', 'Siri Male (Compact)',
                    'Siri Male #1', 'Siri Male #2', 'Siri Male #3', 'Siri Male #4',

                    // ‚ïê‚ïê‚ïê INDIAN MALE VOICES (CRITICAL EXCLUSION - RISHI) ‚ïê‚ïê‚ïê
                    'Rishi', 'Prabhat', 'Hemant', 'Swara', 'Kalpana',

                    // ‚ïê‚ïê‚ïê MICROSOFT MALE VOICES ‚ïê‚ïê‚ïê
                    'Microsoft David', 'Microsoft Mark', 'Microsoft Paul',
                    'Microsoft George', 'Microsoft Rishi', 'Microsoft James',
                    'Microsoft Sean', 'Microsoft Guy', 'Microsoft Michael',
                    'Microsoft David Desktop', 'Microsoft Mark Desktop',

                    // ‚ïê‚ïê‚ïê GOOGLE MALE VOICES ‚ïê‚ïê‚ïê
                    'Google UK English Male', 'Google US English Male',
                    'Google Hindi Male', 'Google Tamil Male', 'Google Bengali Male',
                    'Google French Male', 'Google German Male', 'Google Spanish Male',
                    'Google Italian Male', 'Google Portuguese Male',
                    'Google Arabic Male', 'Google Russian Male', 'Google Japanese Male',
                    'Google Korean Male', 'Google Chinese Male', 'Google Dutch Male',

                    // ‚ïê‚ïê‚ïê APPLE/iOS MALE VOICES (ALL VARIANTS) ‚ïê‚ïê‚ïê
                    'Alex (Enhanced)', 'Fred (Enhanced)', 'Daniel (Compact)',
                    'Oliver (Enhanced)', 'Ralph (Compact)', 'Tom (Compact)',
                    'Alex (Compact)', 'Fred (Compact)', 'Daniel (Enhanced)',
                    'Oliver (Compact)', 'Ralph (Enhanced)', 'Thomas (Enhanced)',
                    'Tom (Enhanced)', 'Bruce (Enhanced)', 'Bruce (Compact)',
                    'James (Enhanced)', 'James (Compact)', 'John (Enhanced)', 'John (Compact)',

                    // ‚ïê‚ïê‚ïê NOVELTY/OTHER PLATFORM MALE VOICES ‚ïê‚ïê‚ïê
                    'Albert', 'Bad News', 'Bahh', 'Bells', 'Boing', 'Bubbles',
                    'Cellos', 'Deranged', 'Good News', 'Hysterical', 'Junior',
                    'Pipe Organ', 'Trinoids', 'Whisper', 'Wobble', 'Zarvox',

                    // ‚ïê‚ïê‚ïê ADDITIONAL PLATFORM-SPECIFIC MALE VOICES ‚ïê‚ïê‚ïê
                    'Eddy', 'Grandpa', 'Rocky', 'Shelley', 'Superstar',
                    'Jacques', 'Henri', 'Antoine', 'Pierre', 'Marc',
                    'Klaus', 'Hans', 'Markus',
                    'Carlos', 'Juan', 'Luis', 'Miguel', 'Pablo',
                    'Luca', 'Paolo', 'Marco', 'Giorgio', 'Matteo',

                    // ‚ïê‚ïê‚ïê EUROPEAN/MULTILINGUAL MALE VOICES ‚ïê‚ïê‚ïê
                    'Diego', 'Diego (Enhanced)', 'Diego (Compact)',
                    'Jorge', 'Jorge (Enhanced)', 'Jorge (Compact)',
                    'Juan', 'Juan (Enhanced)', 'Juan (Compact)',
                    'Tomas', 'Tomas (Enhanced)', 'Tomas (Compact)',
                    'Damien', 'Damien (Enhanced)', 'Damien (Compact)',
                    'Nicolas', 'Nicolas (Enhanced)', 'Nicolas (Compact)',
                    'Matthias', 'Matthias (Enhanced)', 'Matthias (Compact)',
                    'Viktor', 'Viktor (Enhanced)', 'Viktor (Compact)',
                    'Marko', 'Marko (Enhanced)', 'Marko (Compact)'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 4: EXHAUSTIVE MALE VOICE REGEX PATTERNS
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const malePatterns = [
                    // Common male names
                    /\balex\b/i, /\bdaniel\b/i, /\bfred\b/i, /\btom\b/i, /\bthomas\b/i,
                    /\boliver\b/i, /\bralph\b/i, /\bbruce\b/i, /\bjames\b/i, /\bjohn\b/i,
                    /\bnathan\b/i, /\baaron\b/i, /\bjorge\b/i, /\bdiego\b/i,
                    /\btimothy\b/i, /\bmark\b/i, /\bdavid\b/i, /\brichard\b/i,
                    /\bchris\b/i, /\bchristopher\b/i, /\bmatthew\b/i, /\bpaul\b/i,
                    /\bgeorge\b/i, /\bkevin\b/i, /\bjason\b/i, /\bmichael\b/i,
                    /\brobert\b/i, /\bwilliam\b/i, /\bjoseph\b/i, /\bcharles\b/i,
                    /\bsteven\b/i, /\bedward\b/i, /\bbrian\b/i, /\bandrew\b/i,
                    /\banthony\b/i, /\bdonald\b/i, /\bkenneth\b/i, /\bjoshua\b/i,
                    /\bjustin\b/i, /\bryan\b/i, /\beric\b/i, /\bjacob\b/i,
                    /\bpatrick\b/i, /\balexander\b/i, /\bjack\b/i, /\bhenry\b/i,
                    /\bethan\b/i, /\bnoah\b/i, /\bliam\b/i, /\bmason\b/i,
                    /\btyler\b/i, /\bkyle\b/i, /\bdylan\b/i, /\badam\b/i,
                    /\bsean\b/i, /\bcarlos\b/i, /\bjuan\b/i, /\bluis\b/i,

                    // CRITICAL iOS/macOS MALE VOICES (PREVIOUSLY MISSING - MOST LIKELY CULPRITS)
                    /\breed\b/i, /\brocko\b/i, /\blee\b/i, /\bgordon\b/i,
                    /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                    /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i,

                    // ADDITIONAL iOS/macOS MALE PATTERNS
                    /\bcarmit\b/i, /\blekha\b/i, /\blesya\b/i,
                    /\btomas\b/i, /\bdamien\b/i, /\bnicolas\b/i,
                    /\bmatthias\b/i, /\bviktor\b/i, /\bmarko\b/i,
                    /\bluca\b/i, /\bpaolo\b/i, /\bmarco\b/i, /\bgiorgio\b/i, /\bmatteo\b/i,
                    /\bjacques\b/i, /\bhenri\b/i, /\bantoine\b/i, /\bpierre\b/i, /\bmarc\b/i,
                    /\bklaus\b/i, /\bhans\b/i, /\bmarkus\b/i, /\byannick\b/i,
                    /\beddy\b/i, /\bgrandpa\b/i, /\brocky\b/i, /\bshelley\b/i, /\bsuperstar\b/i,

                    // SIRI MALE PATTERNS
                    /siri.*male/i, /male.*siri/i,

                    // INDIAN MALE VOICES (CRITICAL EXCLUSION - RISHI + ALL INDIAN NAMES)
                    /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i,

                    // Generic male indicators
                    /\bmale\b/i, /\bman\b/i, /\b\(m\)\b/i, /\bmale voice\b/i,
                    /\bguy\b/i, /\bdude\b/i, /\bboy\b/i, /\bmr\b/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 5: INDIAN VOICE EXCLUSION (NAME-BASED)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const indianVoiceNames = [
                    // ALL INDIAN VOICES (BOTH MALE AND FEMALE)
                    'Rishi', 'Prabhat', 'Hemant', 'Swara', 'Kalpana',
                    'Lekha', 'Raveena', 'Veena',
                    'Aditi', 'Anjali', 'Divya', 'Kavya', 'Priya', 'Shreya'
                ];

                const indianVoicePatterns = [
                    /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i, /\bswara\b/i, /\bkalpana\b/i,
                    /\blekha\b/i, /\braveena\b/i, /\bveena\b/i,
                    /\baditi\b/i, /\banjali\b/i, /\bdivya\b/i, /\bkavya\b/i,
                    /\bpriya\b/i, /\bshreya\b/i,
                    /hindi/i, /tamil/i, /bengali/i, /telugu/i, /marathi/i, /gujarati/i,
                    /indian/i, /india/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 6: COMPREHENSIVE WESTERN FEMALE VOICE INCLUSION LIST (50+)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const femaleVoiceNames = [
                    // ‚ïê‚ïê‚ïê COMMON ENGLISH FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Samantha', 'Karen', 'Victoria', 'Susan', 'Zoe', 'Moira',
                    'Tessa', 'Fiona', 'Nicky', 'Serena', 'Hazel', 'Zira',
                    'Aria', 'Eva', 'Ava', 'Emma', 'Emily', 'Sarah', 'Kate',
                    'Anna', 'Lauren', 'Jessica', 'Jennifer', 'Michelle',
                    'Catherine', 'Elizabeth', 'Amanda', 'Rebecca', 'Nicole',
                    'Stephanie', 'Melissa', 'Ashley', 'Heather', 'Rachel',
                    'Amy', 'Laura', 'Angela', 'Kimberly', 'Lisa', 'Mary',
                    'Sandra', 'Nancy', 'Betty', 'Dorothy', 'Helen', 'Deborah',
                    'Donna', 'Carol', 'Ruth', 'Sharon', 'Cynthia',

                    // ‚ïê‚ïê‚ïê MICROSOFT WESTERN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Microsoft Zira', 'Microsoft Hazel', 'Microsoft Susan',
                    'Microsoft Zira Desktop', 'Microsoft Zira - English (United States)',
                    'Microsoft Linda', 'Microsoft Heather', 'Microsoft Laura',

                    // ‚ïê‚ïê‚ïê GOOGLE WESTERN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Google UK English Female', 'Google US English Female',
                    'Google Australian Female', 'Google French Female',
                    'Google German Female', 'Google Spanish Female',
                    'Google Italian Female', 'Google Portuguese Female',

                    // ‚ïê‚ïê‚ïê APPLE/iOS FEMALE VOICES (ALL VARIANTS) ‚ïê‚ïê‚ïê
                    'Samantha (Enhanced)', 'Karen (Enhanced)', 'Moira (Enhanced)',
                    'Tessa (Enhanced)', 'Victoria (Enhanced)', 'Fiona (Enhanced)',
                    'Samantha (Compact)', 'Karen (Compact)', 'Moira (Compact)',
                    'Tessa (Compact)', 'Victoria (Compact)', 'Fiona (Compact)',

                    // iOS format variations: "Name - Language (Country)"
                    'Samantha - English (United States)', 'Samantha - English (US)',
                    'Karen - English (Australia)', 'Karen - English (Australian)',
                    'Moira - English (Ireland)', 'Moira - English (Irish)',
                    'Tessa - English (South Africa)', 'Tessa - English (South African)',
                    'Victoria - English (United States)', 'Victoria - English (US)',
                    'Fiona - English (Scotland)', 'Fiona - English (Scottish)',
                    'Nicky - English (United States)', 'Serena - English (United Kingdom)',

                    // iOS format variations: "Name (Country Code)"
                    'Samantha (US)', 'Karen (AU)', 'Moira (IE)', 'Tessa (ZA)',
                    'Victoria (US)', 'Fiona (GB)', 'Nicky (US)', 'Serena (GB)',

                    // ‚ïê‚ïê‚ïê SIRI VARIANTS ‚ïê‚ïê‚ïê
                    'Siri Female', 'Siri Female (Enhanced)', 'Siri Female (Compact)',
                    'Siri (Female)', 'Siri - Female', 'Female Siri',

                    // ‚ïê‚ïê‚ïê EUROPEAN FEMALE VOICES ‚ïê‚ïê‚ïê
                    'Amelie', 'Audrey', 'Aurelie', 'Celine', 'Chantal',
                    'Marie', 'Sophie', 'Yelda', 'Zofia', 'Petra', 'Vicki',
                    'Katja', 'Sabina', 'Carmit', 'Kyoko', 'Luciana', 'Joana'
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LAYER 7: WESTERN FEMALE VOICE REGEX PATTERNS (EXPANDED FOR iOS)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const femalePatterns = [
                    // Core female names (iOS/macOS primary)
                    /\bsamantha\b/i, /\bkaren\b/i, /\bvictoria\b/i, /\bsusan\b/i,
                    /\bzoe\b/i, /\bmoira\b/i, /\btessa\b/i, /\bfiona\b/i,
                    /\bnicky\b/i, /\bserena\b/i, /\bhazel\b/i, /\bzira\b/i,

                    // Additional common female names
                    /\baria\b/i, /\beva\b/i, /\bava\b/i, /\bemma\b/i,
                    /\bemily\b/i, /\bsarah\b/i, /\bkate\b/i, /\banna\b/i,
                    /\blauren\b/i, /\bjessica\b/i, /\bjennifer\b/i, /\bmichelle\b/i,
                    /\bcatherine\b/i, /\belizabeth\b/i, /\bamanda\b/i,
                    /\brebecca\b/i, /\bnicole\b/i, /\bstephanie\b/i, /\bmelissa\b/i,
                    /\bashley\b/i, /\bheather\b/i, /\brachel\b/i, /\bamy\b/i,
                    /\blaura\b/i, /\bangela\b/i, /\blisa\b/i, /\bmary\b/i,

                    // European female names
                    /\bamelie\b/i, /\baudrey\b/i, /\bceline\b/i, /\bmarie\b/i,
                    /\bsophie\b/i, /\bpietra\b/i, /\bvicki\b/i, /\bkatja\b/i,
                    /\bjoana\b/i, /\bluciana\b/i, /\bcarmit\b/i, /\bkyoko\b/i,

                    // Generic female indicators
                    /\bfemale\b/i, /\bwoman\b/i, /\b\(f\)\b/i, /\bfemale voice\b/i,
                    /\bsiri.*female\b/i, /female.*siri/i, /\blady\b/i, /\bgirl\b/i,
                    /\bms\b/i, /\bmiss\b/i, /\bmrs\b/i
                ];

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SIMPLIFIED FILTERING: EXCLUDE MALES ONLY, ACCEPT ALL OTHERS
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // USER REQUIREMENT: "I just want a female voice, it doesn't have to be western"
                // NEW APPROACH: Inverse logic - reject ONLY male voices, accept everything else

                console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  FILTERING: REMOVING MALE VOICES ONLY (ANY LANGUAGE)   ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                const femaleVoices = voices.filter(voice => {
                    const voiceName = voice.name;

                    // Check by male name (comprehensive list)
                    const isMaleName = maleVoiceNames.some(maleName =>
                        voiceName.toLowerCase() === maleName.toLowerCase() ||
                        voiceName.toLowerCase().includes(maleName.toLowerCase())
                    );

                    // Check by male pattern (regex)
                    const isMalePattern = malePatterns.some(pattern =>
                        pattern.test(voiceName)
                    );

                    if (isMaleName || isMalePattern) {
                        console.log(`  ‚úó‚úó‚úó EXCLUDED (MALE VOICE): ${voiceName} (${voice.lang})`);
                        return false;
                    }

                    console.log(`  ‚úì‚úì‚úì ACCEPTED (FEMALE/NON-MALE): ${voiceName} (${voice.lang})`);
                    return true;
                });

                console.log(`\nAfter male voice filtering: ${femaleVoices.length} voices remain (${voices.length - femaleVoices.length} male voices EXCLUDED)`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRITICAL RULE: If NO non-male voices exist, FAIL HARD
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if (femaleVoices.length === 0) {
                    console.error('\n‚úó‚úó‚úó CRITICAL FAILURE ‚úó‚úó‚úó');
                    console.error('NO FEMALE VOICES AVAILABLE!');
                    console.error('All available voices matched male exclusion patterns.');
                    this.voiceName = null;
                    this.voiceLang = null;
                    this.showVoiceWarning('ERROR: Only male voices available on this system!');
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log('   VOICE SELECTION FAILED (No female voices found)');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                    return;
                }

                const finalVoicePool = femaleVoices;

                console.log(`FINAL VOICE POOL SIZE: ${finalVoicePool.length} female voices (any language)`);
                console.log(`  (${voices.length} original ‚Üí ${finalVoicePool.length} after male exclusion)\n`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TIER 1: PLATFORM-SPECIFIC PRIORITY LISTS (PREFERRED VOICES)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const iOSFemalePriority = [
                    'Samantha',
                    'Samantha (Enhanced)',
                    'Karen',
                    'Karen (Enhanced)',
                    'Moira',
                    'Moira (Enhanced)',
                    'Tessa',
                    'Tessa (Enhanced)',
                    'Victoria',
                    'Victoria (Enhanced)',
                    'Fiona',
                    'Fiona (Enhanced)',
                    'Nicky',
                    'Serena',
                    'Siri Female',
                    'Siri Female (Enhanced)',
                    'Siri Female (Compact)'
                ];

                const desktopFemalePriority = [
                    'Samantha',
                    'Victoria',
                    'Karen',
                    'Susan',
                    'Zoe',
                    'Hazel',
                    'Zira',
                    'Microsoft Zira',
                    'Microsoft Zira Desktop',
                    'Microsoft Hazel',
                    'Microsoft Susan',
                    'Google US English Female',
                    'Google UK English Female',
                    'Google Australian Female'
                ];

                const priorityList = isIOS ? iOSFemalePriority : desktopFemalePriority;

                console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  TIER 1: PRIORITY LIST MATCHING                       ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                for (const priorityName of priorityList) {
                    console.log(`  Trying priority voice: ${priorityName}`);
                    const match = finalVoicePool.find(v => v.name === priorityName);
                    if (match) {
                        console.log(`  ‚úì‚úì‚úì PRIORITY VOICE FOUND: ${match.name} (${match.lang})`);

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // FINAL SAFETY NET: Verify this is NOT a male voice (should never happen)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        const voiceName = match.name;
                        const isMaleName = maleVoiceNames.some(maleName =>
                            voiceName.toLowerCase().includes(maleName.toLowerCase())
                        );
                        const isMalePattern = malePatterns.some(pattern => pattern.test(voiceName));

                        if (isMaleName || isMalePattern) {
                            console.error(`  ‚úó‚úó‚úó SAFETY BLOCK: Priority voice "${voiceName}" matched MALE pattern! Skipping.`);
                            continue;
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: Store name and lang as STRINGS, not object
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        this.voiceName = match.name;
                        this.voiceLang = match.lang;
                        this.persistVoice(match, this.isIOS);
                        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        console.log(`   VOICE SELECTION COMPLETE: ${this.voiceName} (${this.voiceLang})`);
                        console.log('   (Stored as name+lang strings for iOS compatibility)');
                        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                        return;
                    }
                }
                console.log('  No priority matches found');

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TIER 2: USE FIRST VOICE FROM FILTERED POOL
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                console.log('‚îÇ  TIER 2: SELECTING FIRST FEMALE VOICE FROM POOL        ‚îÇ');
                console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');

                if (finalVoicePool.length > 0) {
                    const candidateVoice = finalVoicePool[0];
                    const voiceName = candidateVoice.name;

                    console.log(`  Candidate voice: ${voiceName} (${candidateVoice.lang})`);

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // FINAL SAFETY NET: Verify this is NOT a male voice (should never happen)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    const isMaleName = maleVoiceNames.some(maleName =>
                        voiceName.toLowerCase().includes(maleName.toLowerCase())
                    );
                    const isMalePattern = malePatterns.some(pattern => pattern.test(voiceName));

                    if (isMaleName || isMalePattern) {
                        console.error(`  ‚úó‚úó‚úó SAFETY BLOCK: Candidate voice "${voiceName}" matched MALE pattern!`);
                        console.error('  This should never happen - male voice in female pool!');
                        this.voiceName = null;
                        this.voiceLang = null;
                        this.showVoiceWarning('ERROR: Male voice detected in female pool! Refusing assignment for safety.');
                        return;
                    }

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // iOS CRITICAL: Store name and lang as STRINGS, not object
                    // Voice passed male exclusion filter, so it's female - ACCEPT IT
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    this.voiceName = candidateVoice.name;
                    this.voiceLang = candidateVoice.lang;
                    console.log(`  ‚úì‚úì‚úì SELECTED: ${this.voiceName} (${this.voiceLang})`);
                    this.persistVoice(candidateVoice, this.isIOS);
                    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                    console.log(`   VOICE SELECTION COMPLETE: ${this.voiceName} (${this.voiceLang})`);
                    console.log('   (Stored as name+lang strings for iOS compatibility)');
                    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                    return;
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRITICAL FAILURE - No suitable voices exist
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.error('\n‚úó‚úó‚úó CRITICAL FAILURE ‚úó‚úó‚úó');
                console.error('No female voices available on this device!');
                console.error('All available voices matched male exclusion patterns.');
                console.error('This should not happen on iPhone - investigating available voices:');
                voices.forEach((v, idx) => {
                    console.error(`  [${idx}] ${v.name} (${v.lang})`);
                });
                this.voiceName = null;
                this.voiceLang = null;
                this.showVoiceWarning('ERROR: No female voice available on this device!');
                console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('   VOICE SELECTION FAILED');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            }

            // Helper method to persist voice selection with platform awareness
            persistVoice(voice, isIOS) {
                localStorage.setItem('relational-nback-voice-name', voice.name);
                localStorage.setItem('relational-nback-voice-lang', voice.lang);
                localStorage.setItem('relational-nback-voice-platform', isIOS ? 'ios' : 'desktop');
                console.log('Persisted voice:', voice.name, voice.lang, isIOS ? 'ios' : 'desktop');
            }

            // Method to reset voice selection (for manual override)
            resetVoiceSelection() {
                localStorage.removeItem('relational-nback-voice-name');
                localStorage.removeItem('relational-nback-voice-lang');
                localStorage.removeItem('relational-nback-voice-platform');
                this.voiceName = null;
                this.voiceLang = null;
                console.log('Voice selection reset');
            }

            // Display warning to user about voice selection issues
            showVoiceWarning(message) {
                console.warn(`VOICE WARNING: ${message}`);

                // Update voice-info element if it exists
                const voiceInfoEl = document.getElementById('voice-info');
                if (voiceInfoEl) {
                    voiceInfoEl.innerHTML = `<span style="color: #e74c3c;">‚ö† ${message}</span>`;
                }

                // Optionally show alert for critical issues
                if (message.includes('ERROR')) {
                    setTimeout(() => {
                        alert(`Voice System Warning:\n\n${message}\n\nThe game may not work correctly without a suitable voice.`);
                    }, 500);
                }
            }

            getVoiceInfo() {
                return this.voiceName ? `${this.voiceName} (${this.voiceLang})` : 'Voice not initialized';
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // iOS CRITICAL: Get FRESH voice object from getVoices()
            // NEVER return cached voice object - causes staleness on iOS
            // This method is called by speak() before EVERY utterance
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            getFreshVoiceObject() {
                if (!this.voiceName || !this.voiceLang) {
                    console.error('getFreshVoiceObject: No voice selected (voiceName/voiceLang null)');
                    return null;
                }

                try {
                    const voices = this.synth.getVoices();

                    if (!voices || voices.length === 0) {
                        console.error('getFreshVoiceObject: getVoices() returned empty array');
                        return null;
                    }

                    // Find voice by name AND lang (exact match)
                    const freshVoice = voices.find(v =>
                        v.name === this.voiceName &&
                        v.lang === this.voiceLang
                    );

                    if (freshVoice) {
                        console.log(`‚úì Fresh voice object retrieved: ${freshVoice.name} (${freshVoice.lang})`);
                        return freshVoice;
                    }

                    // FALLBACK: Selected voice not found - try to find ANY female voice
                    console.warn(`Selected voice "${this.voiceName}" (${this.voiceLang}) not found in current getVoices()`);
                    console.warn('Attempting fallback to ANY available female voice...');

                    // Use the same male exclusion logic as selectVoice()
                    const maleVoiceNames = ['Reed', 'Alex', 'Daniel', 'Fred', 'Tom', 'Thomas', 'Oliver', 'Ralph', 'Bruce', 'James', 'Rishi', 'Rocko', 'Lee', 'Gordon', 'Martin', 'Xander', 'Yuri'];
                    const malePatterns = [/\breed\b/i, /\balex\b/i, /\bmale\b/i, /\brishi\b/i, /\bman\b/i];

                    const anyFemaleVoice = voices.find(v => {
                        const isMaleName = maleVoiceNames.some(maleName =>
                            v.name.toLowerCase().includes(maleName.toLowerCase())
                        );
                        const isMalePattern = malePatterns.some(pattern => pattern.test(v.name));
                        return !isMaleName && !isMalePattern;
                    });

                    if (anyFemaleVoice) {
                        console.warn(`‚ö† Using fallback female voice: ${anyFemaleVoice.name} (${anyFemaleVoice.lang})`);
                        return anyFemaleVoice;
                    }

                    console.error('getFreshVoiceObject: No female voice found (all voices are male)');
                    return null;

                } catch (err) {
                    console.error('getFreshVoiceObject error:', err);
                    return null;
                }
            }

            // Backward compatibility alias (calls getFreshVoiceObject)
            getLockedVoice() {
                return this.getFreshVoiceObject();
            }

            async cancelAndWait() {
                try {
                    this.synth.cancel();
                } catch (error) {
                    console.warn('speechSynthesis.cancel failed', error);
                }
                await new Promise(resolve => setTimeout(resolve, 50));
                this.sessionToken = makeEpoch();
            }

            speak(text, guardToken = null) {
                if (!text) {
                    return Promise.resolve({ fallback: false, attempts: 0 });
                }

                return new Promise(resolve => {
                    if (guardToken && guardToken !== this.sessionToken) {
                        resolve({ fallback: false, attempts: 0 });
                        return;
                    }

                    const utterance = new SpeechSynthesisUtterance(text);
                    const voice = this.getLockedVoice();

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL SAFETY RULE #1: REFUSE TO SPEAK IF NO VOICE ASSIGNED
                    // This prevents browser from using its DEFAULT voice (male on iPhone)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (!voice) {
                        console.error('‚úó‚úó‚úó CRITICAL SAFETY BLOCK: No voice assigned (this.voice is null)!');
                        console.error('REFUSING TO SPEAK to prevent browser default voice (likely male) from being used!');
                        console.error('Voice system failed to initialize properly or all voices were filtered out.');
                        console.error('Check browser console for voice selection errors.');
                        resolve({ fallback: true, attempts: 0 });
                        return;
                    }

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // COMPREHENSIVE SAFETY CHECK: Prevent ANY male voices from speaking
                    // This is the SECOND line of defense - if a male voice reaches here,
                    // we refuse to speak rather than use it
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (voice) {
                        const voiceName = voice.name;

                        // EXHAUSTIVE male voice detection patterns (CRITICAL - includes Reed, Rocko, Lee, Gordon, etc.)
                        const malePatterns = [
                            // Common male names
                            /\balex\b/i, /\bdaniel\b/i, /\bfred\b/i, /\btom\b/i, /\bthomas\b/i,
                            /\boliver\b/i, /\bralph\b/i, /\bbruce\b/i, /\bjames\b/i, /\bjohn\b/i,
                            /\bnathan\b/i, /\baaron\b/i, /\bjorge\b/i, /\bdiego\b/i,
                            /\bmark\b/i, /\bdavid\b/i, /\brichard\b/i, /\bpaul\b/i, /\bgeorge\b/i,
                            /\bmichael\b/i, /\brobert\b/i, /\bwilliam\b/i, /\bjoseph\b/i,

                            // CRITICAL iOS/macOS male voices (PREVIOUSLY MISSING)
                            /\breed\b/i, /\brocko\b/i, /\blee\b/i, /\bgordon\b/i,
                            /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                            /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i,

                            // Additional male voices
                            /\bluca\b/i, /\bpaolo\b/i, /\bmarco\b/i, /\btomas\b/i,
                            /\bnicolas\b/i, /\bviktor\b/i, /\bmarko\b/i,

                            // INDIAN MALE VOICES
                            /\brishi\b/i, /\bprabhat\b/i, /\bhemant\b/i,

                            // Siri male
                            /siri.*male/i, /male.*siri/i,

                            // Generic male indicators
                            /\bmale\b/i, /\bman\b/i, /\b\(m\)\b/i, /\bmale voice\b/i,
                            /\bguy\b/i, /\bdude\b/i, /\bboy\b/i, /\bmr\b/i
                        ];

                        const isMaleVoice = malePatterns.some(pattern => pattern.test(voiceName));

                        if (isMaleVoice) {
                            console.error(`‚úó‚úó‚úó RUNTIME SAFETY BLOCK: Prevented male voice "${voiceName}" from speaking!`);
                            console.error('CRITICAL: Male voice bypassed selectVoice filtering - this should NEVER happen!');
                            console.error('Refusing to speak. Voice system is compromised.');
                            resolve({ fallback: true, attempts: 0 });
                            return;
                        }

                        // ADDITIONAL SAFETY: Confirm voice matches female patterns (EXPANDED FOR iOS)
                        const femalePatterns = [
                            // Core iOS/macOS female voices
                            /\bsamantha\b/i, /\bkaren\b/i, /\bvictoria\b/i, /\bsusan\b/i,
                            /\bzoe\b/i, /\bmoira\b/i, /\btessa\b/i, /\bfiona\b/i,
                            /\bnicky\b/i, /\bserena\b/i, /\bhazel\b/i, /\bzira\b/i,

                            // Additional common female names
                            /\baria\b/i, /\beva\b/i, /\bava\b/i, /\bemma\b/i,
                            /\bemily\b/i, /\bsarah\b/i, /\bkate\b/i, /\banna\b/i,
                            /\blauren\b/i, /\bjessica\b/i, /\bjennifer\b/i, /\bmichelle\b/i,
                            /\bcatherine\b/i, /\belizabeth\b/i, /\bamanda\b/i,
                            /\brebecca\b/i, /\bnicole\b/i, /\bstephanie\b/i, /\bmelissa\b/i,

                            // European female names
                            /\bamelie\b/i, /\baudrey\b/i, /\bceline\b/i, /\bmarie\b/i,
                            /\bsophie\b/i, /\bvicki\b/i, /\bkatja\b/i, /\bjoana\b/i,
                            /\bluciana\b/i,

                            // Generic female indicators
                            /\bfemale\b/i, /\bwoman\b/i, /\bsiri.*female\b/i, /female.*siri/i,
                            /\blady\b/i, /\bgirl\b/i, /\b\(f\)\b/i
                        ];

                        const isFemaleVoice = femalePatterns.some(pattern => pattern.test(voiceName));

                        if (!isFemaleVoice) {
                            console.warn(`‚ö† WARNING: Voice "${voiceName}" does not match known female patterns`);
                            console.warn('Allowing it to proceed, but this voice may not be female');
                            console.warn('If you hear a male voice, please report this immediately');
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: Set BOTH utterance.voice AND utterance.lang
                        // Setting only ONE property causes iOS to ignore and use default
                        // BOTH must be set together or iOS falls back to Reed (male)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        utterance.voice = voice;
                        utterance.lang = voice.lang;

                        if (this.isIOS) {
                            console.log(`iOS: Set both utterance.voice="${voice.name}" AND utterance.lang="${voice.lang}"`);
                        }
                    }

                    utterance.pitch = this.pitch;
                    utterance.rate = this.rate;
                    utterance.volume = this.volume;

                    let settled = false;
                    const finish = (fallback) => {
                        if (settled) return;
                        settled = true;
                        clearTimeout(fallbackTimer);
                        resolve({ fallback, attempts: 1 });
                    };

                    const fallbackTimer = setTimeout(() => finish(true), estimateUtteranceMs(text, this.rate) + 400);

                    utterance.onend = () => finish(false);
                    utterance.onerror = () => finish(true);

                    setTimeout(() => {
                        if (settled) return;
                        if (guardToken && guardToken !== this.sessionToken) {
                            finish(true);
                            return;
                        }
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // CRITICAL SAFETY RULE #2: VERIFY utterance.voice IS SET
                        // Final check before speaking - if utterance.voice is not set,
                        // browser will use DEFAULT voice (Reed on iPhone)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if (!utterance.voice) {
                            console.error('‚úó‚úó‚úó CRITICAL SAFETY BLOCK: utterance.voice is not set!');
                            console.error('REFUSING TO SPEAK - would use browser default voice (male)!');
                            console.error('This should NEVER happen - voice was not properly assigned to utterance.');
                            finish(true);
                            return;
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // iOS CRITICAL: VERIFY BOTH utterance.voice AND utterance.lang ARE SET
                        // iOS requires BOTH properties or ignores voice and uses default Reed
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if (this.isIOS) {
                            if (!utterance.voice || !utterance.lang) {
                                console.error('‚úó‚úó‚úó iOS CRITICAL SAFETY BLOCK: utterance.voice OR utterance.lang not set!');
                                console.error(`utterance.voice: ${utterance.voice?.name || 'NULL'}`);
                                console.error(`utterance.lang: ${utterance.lang || 'NULL'}`);
                                console.error('iOS requires BOTH properties set or will use default voice (Reed - male)!');
                                console.error('REFUSING TO SPEAK!');
                                finish(true);
                                return;
                            }
                            console.log(`‚úì iOS dual-property check passed: voice="${utterance.voice.name}", lang="${utterance.lang}"`);
                        }

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // FINAL VERIFICATION: Confirm assigned voice is female
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        const assignedVoiceName = utterance.voice.name;
                        console.log(`üì¢ About to speak with voice: "${assignedVoiceName}" (${utterance.voice.lang})`);

                        // One last male voice check (includes Reed - iOS default)
                        const finalMaleCheck = [
                            /\breed\b/i, /\brocko\b/i, /\balex\b/i, /\bfred\b/i, /\btom\b/i,
                            /\bmale\b/i, /\bman\b/i, /\brishi\b/i, /\blee\b/i, /\bgordon\b/i,
                            /\bmartin\b/i, /\bxander\b/i, /\byuri\b/i, /\botoya\b/i,
                            /\bmaged\b/i, /\bmajed\b/i, /\btarik\b/i, /\bdaniel\b/i
                        ];

                        if (finalMaleCheck.some(pattern => pattern.test(assignedVoiceName))) {
                            console.error(`‚úó‚úó‚úó FINAL SAFETY BLOCK: Assigned voice "${assignedVoiceName}" is MALE!`);
                            console.error('REFUSING TO SPEAK!');
                            finish(true);
                            return;
                        }

                        try {
                            this.synth.resume();
                        } catch (err) {
                            console.warn('speechSynthesis.resume failed', err);
                        }
                        try {
                            this.synth.speak(utterance);
                        } catch (err) {
                            console.warn('speechSynthesis.speak failed', err);
                            finish(true);
                        }
                    }, 120);
                });
            }

            async speakPremise(premise, guardToken = null) {
                if (!premise) {
                    return { fallback: false, attempts: 0 };
                }
                const text = formatPremiseForSpeech(premise);
                return this.speak(text, guardToken);
            }
        }

        class GameEngine {
            constructor() {
                this.session = sessionDefaults();
                this.session.state = 'STOPPED';
                this.seedManager = new SeedManager();
                this.logger = new GameLogger();
                this.voice = new VoiceSynthesis();
                this.state = null;
                this.solver = null;
                this.equivalence = new EquivalenceEngine(false);
                this.generator = null;
                this.planner = null;
                this.matchSchedule = [];
                this.awaitingResponse = false;
                this.sessionToken = makeEpoch();
                this.responseStartTime = 0;
                this.currentPremises = [];
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.M = 8;
                this.lockSeed = this.seedManager.getLockPreference();
                this.resetOnRestart = false;
                this.pendingPlannerFlip = false;
                this.pendingRestart = false;
                this.statusMessage = 'Idle';
                this.policy = AdvancePolicy.ACTIVE;
                this.lastSpokenFallback = false;
                this.activePremise = null;
                // DEPRECATED (January 2025): Force flags replaced by logic-level-select dropdown
                // These are kept for backward compatibility with PremiseGenerator.generate()
                // They're always false but still passed to generate() as fallback parameters
                this.forceMetaLeap = false;
                this.forceCompoundLeap = false;
            }

            get n() {
                return this.session.n;
            }

            set n(value) {
                this.session.n = value;
            }

            get k() {
                return this.session.k;
            }

            set k(value) {
                this.session.k = value;
            }

            get secondsPerTrial() {
                return this.session.secondsPerTrial;
            }

            set secondsPerTrial(value) {
                this.session.secondsPerTrial = value;
            }

            get totalTrials() {
                return this.session.numTrials;
            }

            set totalTrials(value) {
                this.session.numTrials = value;
            }

            applyNumTrialsFromUI() {
                const current = loadNumTrials();
                this.session.numTrials = current;
                return current;
            }

            speakOnce(text) {
                if (!text) return;
                this.voice.speak(text, this.voice.sessionToken);
            }

            renderSummary() {
                this.statusMessage = `Session complete. ${this.session.numTrials} trials finished.`;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
            }

            async initialize() {
                await this.voice.initialize();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL: Unlock speech synthesis from user gesture
                // Must be called after voice.initialize() to enable iOS speech
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.voice.unlockIOSSpeech();

                this.updateVoiceInfo();
                this.attachUI();
                this.updateUI();
            }

            attachUI() {
                if (window._imagiHandlersBound) {
                    return;
                }
                window._imagiHandlersBound = true;

                const lockSeedToggle = document.getElementById('lock-seed-toggle');
                if (lockSeedToggle) {
                    lockSeedToggle.checked = this.lockSeed;
                    lockSeedToggle.addEventListener('change', (e) => {
                        this.lockSeed = e.target.checked;
                        this.seedManager.setLockPreference(this.lockSeed);
                    });
                }

                const resetSeedToggle = document.getElementById('reset-seed-toggle');
                if (resetSeedToggle) {
                    resetSeedToggle.addEventListener('change', (e) => {
                        this.resetOnRestart = e.target.checked;
                    });
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // FORCE NEW SEED BUTTON - Clear seed lock and cached seeds
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const forceNewSeedBtn = document.getElementById('force-new-seed-btn');
                if (forceNewSeedBtn) {
                    forceNewSeedBtn.addEventListener('click', () => {
                        console.log('[SeedManager] Force New Seed button clicked - clearing ALL seed localStorage');

                        // Clear all seed-related localStorage keys
                        localStorage.removeItem('relational-nback-lock-seed');
                        localStorage.removeItem('relational-nback-last-seed');
                        localStorage.removeItem('relational-nback-run-counter');

                        // Uncheck the lock seed checkbox
                        const lockSeedToggle = document.getElementById('lock-seed-toggle');
                        if (lockSeedToggle) {
                            lockSeedToggle.checked = false;
                            this.lockSeed = false;
                            this.seedManager.setLockPreference(false);
                        }

                        // Update UI to show cleared state
                        const seedValueSpan = document.getElementById('seed-value-runtime');
                        if (seedValueSpan) {
                            seedValueSpan.textContent = 'CLEARED - will generate new on next session';
                            seedValueSpan.style.color = '#00ff00';
                        }

                        // User feedback
                        alert('‚úÖ Seed cleared successfully!\n\n' +
                              'All cached seeds removed from localStorage.\n' +
                              'Lock seed checkbox unchecked.\n' +
                              'Next session will use a fresh random seed.\n\n' +
                              'Click START to begin new session with random premises.');

                        console.log('[SeedManager] Seed reset complete:', {
                            lockSeed_cleared: !localStorage.getItem('relational-nback-lock-seed'),
                            lastSeed_cleared: !localStorage.getItem('relational-nback-last-seed'),
                            counter_cleared: !localStorage.getItem('relational-nback-run-counter'),
                            lockSeedToggle_unchecked: lockSeedToggle ? !lockSeedToggle.checked : 'N/A'
                        });
                    });

                    // Add hover effect
                    forceNewSeedBtn.addEventListener('mouseenter', () => {
                        forceNewSeedBtn.style.background = 'linear-gradient(135deg, #ff5577 0%, #e94560 100%)';
                        forceNewSeedBtn.style.transform = 'translateY(-2px)';
                        forceNewSeedBtn.style.boxShadow = '0 4px 10px rgba(233, 69, 96, 0.5)';
                    });
                    forceNewSeedBtn.addEventListener('mouseleave', () => {
                        forceNewSeedBtn.style.background = 'linear-gradient(135deg, #e94560 0%, #c72a47 100%)';
                        forceNewSeedBtn.style.transform = 'translateY(0)';
                        forceNewSeedBtn.style.boxShadow = '0 2px 5px rgba(233, 69, 96, 0.3)';
                    });
                }

                const transitivityToggle = document.getElementById('transitivity-toggle');
                if (transitivityToggle) {
                    this.equivalence.setTransitivity(transitivityToggle.checked); // Apply initial state
                    transitivityToggle.addEventListener('change', (e) => {
                        this.equivalence.setTransitivity(e.target.checked);
                    });
                }

                // DA VINCI HIERARCHY: Logic Level Dropdown Event Listener
                const logicLevelSelect = document.getElementById('logic-level-select');
                if (logicLevelSelect) {
                    logicLevelSelect.addEventListener('change', (e) => {
                        const selectedMode = parseInt(e.target.value);

                        // K-slider locking based on Topology Mode
                        const kLabel = document.getElementById('k-label');
                        const kSlider = document.getElementById('k-slider');
                        const kNumber = document.getElementById('k-number');
                        const kValue = document.getElementById('k-value');

                        if (selectedMode === 0) {
                            // Mode 0: Standard / Manual - User controls k
                            if (kLabel) kLabel.textContent = 'Atoms per Premise (k):';
                            if (kSlider) {
                                kSlider.disabled = false;
                                kSlider.style.opacity = '1.0';
                                kSlider.style.cursor = 'pointer';
                            }
                            if (kNumber) {
                                kNumber.disabled = false;
                                kNumber.style.opacity = '1.0';
                            }
                        } else if (selectedMode === 1 || selectedMode === 2) {
                            // Mode 1 & 2: Dialectical Superposition and Semantic Tensor - Lock k=2
                            const modeName = selectedMode === 1 ? 'Dialectical Superposition' : 'Semantic Tensor';
                            if (kLabel) kLabel.textContent = `Mode ${selectedMode} - ${modeName} (fixed at k=2):`;
                            if (kSlider) {
                                kSlider.value = 2;
                                kSlider.disabled = true;
                                kSlider.style.opacity = '0.5';
                                kSlider.style.cursor = 'not-allowed';
                            }
                            if (kNumber) {
                                kNumber.value = 2;
                                kNumber.disabled = true;
                                kNumber.style.opacity = '0.5';
                            }
                            if (kValue) kValue.textContent = '2';
                            this.k = 2;
                        } else if (selectedMode === 3) {
                            // Mode 3: System Homology - Lock k=3
                            if (kLabel) kLabel.textContent = 'Mode 3 - System Homology (fixed at k=3):';
                            if (kSlider) {
                                kSlider.value = 3;
                                kSlider.disabled = true;
                                kSlider.style.opacity = '0.5';
                                kSlider.style.cursor = 'not-allowed';
                            }
                            if (kNumber) {
                                kNumber.value = 3;
                                kNumber.disabled = true;
                                kNumber.style.opacity = '0.5';
                            }
                            if (kValue) kValue.textContent = '3';
                            this.k = 3;
                        } else if (selectedMode === 4) {
                            // Mode 4: Complementary Interface - Lock k=5
                            if (kLabel) kLabel.textContent = 'Mode 4 - Complementary Interface (fixed at k=5):';
                            if (kSlider) {
                                kSlider.value = 5;
                                kSlider.disabled = true;
                                kSlider.style.opacity = '0.5';
                                kSlider.style.cursor = 'not-allowed';
                            }
                            if (kNumber) {
                                kNumber.value = 5;
                                kNumber.disabled = true;
                                kNumber.style.opacity = '0.5';
                            }
                            if (kValue) kValue.textContent = '5';
                            this.k = 5;
                        }
                    });
                }

                const debugToggle = document.getElementById('debug-toggle');
                if (debugToggle) {
                    debugToggle.addEventListener('change', (e) => {
                        document.getElementById('debug').hidden = !e.target.checked;
                    });
                }

                const sptSlider = document.getElementById('spt-slider');
                const sptNumber = document.getElementById('spt-number');
                const syncSeconds = (value) => {
                    this.secondsPerTrial = parseFloat(value);
                    const sptValue = document.getElementById('spt-value');
                    if (sptValue) {
                        sptValue.textContent = this.secondsPerTrial.toFixed(1);
                    }
                };
                if (sptSlider) {
                    sptSlider.addEventListener('input', (e) => {
                        if (sptNumber) {
                            sptNumber.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }
                if (sptNumber) {
                    sptNumber.addEventListener('input', (e) => {
                        if (sptSlider) {
                            sptSlider.value = e.target.value;
                        }
                        syncSeconds(e.target.value);
                    });
                }

                const nSlider = document.getElementById('n-slider');
                if (nSlider) {
                    nSlider.addEventListener('input', (e) => {
                        this.n = parseInt(e.target.value, 10);
                        const nValue = document.getElementById('n-value');
                        if (nValue) {
                            nValue.textContent = this.n;
                        }
                    });
                }

                const kSlider = document.getElementById('k-slider');
                if (kSlider) {
                    kSlider.addEventListener('input', (e) => {
                        this.k = parseInt(e.target.value, 10);
                        const kValue = document.getElementById('k-value');
                        if (kValue) {
                            kValue.textContent = this.k;
                        }
                    });
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        this.pendingRestart = false;
                        startSession();
                    });
                }

                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        restartSession();
                    });
                }

                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) {
                    stopBtn.addEventListener('click', () => {
                        stopSession();
                    });
                }

                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) {
                    repeatBtn.addEventListener('click', () => {
                        onRepeatPressed();
                    });
                }

                const previewBtn = document.getElementById('preview-btn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', async () => {
                        const previewPremise = new Premise([
                            new Atom('N', 'A', 'B'),
                            new Atom('E', 'C', 'D')
                        ]);
                        await this.voice.speakPremise(previewPremise, this.voice.sessionToken);
                    });
                }

                const resetVoiceBtn = document.getElementById('reset-voice-btn');
                if (resetVoiceBtn) {
                    resetVoiceBtn.addEventListener('click', async () => {
                        console.log('Manual voice reset requested');
                        // Reset voice selection and re-initialize
                        this.voice.resetVoiceSelection();
                        this.voice.voiceReady = false;

                        try {
                            await this.voice.initialize();
                            this.updateVoiceInfo();
                            alert('Voice selection has been reset and re-initialized.\n\nSelected voice: ' + this.voice.getVoiceInfo());
                        } catch (error) {
                            console.error('Voice re-initialization failed:', error);
                            alert('Voice re-initialization failed: ' + error.message);
                        }
                    });
                }

                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        const handler = window.__imagiActiveResponse;
                        if (typeof handler === 'function') {
                            e.preventDefault();
                            handler(e.code === 'Space' ? 'match' : 'nomatch');
                        }
                    }
                });

                const exportBtn = document.getElementById('export-btn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => {
                        this.exportData();
                    });
                }

                const testBtn = document.getElementById('test-btn');
                if (testBtn) {
                    testBtn.addEventListener('click', async () => {
                        const panel = document.getElementById('test-panel');
                        const resultsEl = document.getElementById('test-results');
                        if (panel) panel.hidden = false;
                        if (resultsEl) {
                            resultsEl.innerHTML = '<p>Running tests...</p>';
                            const harness = new TestHarness();
                            const results = await harness.runAll();
                            resultsEl.innerHTML = results.map(result => {
                                const cls = result.passed ? 'pass' : 'fail';
                                const symbol = result.passed ? '‚úì' : '‚úó';
                                return `<div class="test-result ${cls}">${symbol} ${result.test}: ${result.details}</div>`;
                            }).join('');
                        }
                    });
                }
            }

            updateVoiceInfo() {
                const info = document.getElementById('voice-info');
                if (info) {
                    const voiceInfo = this.voice.getVoiceInfo();
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                    const platform = isIOS ? 'iOS' : 'Desktop';

                    // Determine voice status with female voice awareness
                    let voiceStatus;
                    if (this.voice.voice) {
                        const voiceName = this.voice.voice.name;

                        // Check if it's a known female voice
                        const knownFemaleVoices = [
                            'Samantha', 'Karen', 'Moira', 'Tessa', 'Victoria', 'Fiona',
                            'Nicky', 'Serena', 'Susan', 'Zoe', 'Hazel', 'Zira'
                        ];
                        const isKnownFemale = knownFemaleVoices.some(name => voiceName.includes(name));

                        if (voiceName.includes('Samantha')) {
                            voiceStatus = '<span style="color: #2ecc71;">‚úì Samantha (Female)</span>';
                        } else if (isKnownFemale) {
                            voiceStatus = '<span style="color: #2ecc71;">‚úì Female Voice</span>';
                        } else {
                            voiceStatus = '<span style="color: #f39c12;">‚ö† Ambiguous Voice</span>';
                        }
                    } else {
                        voiceStatus = '<span style="color: #e74c3c;">‚úó No Voice</span>';
                    }

                    info.innerHTML = `<strong>Voice:</strong> ${voiceInfo} | <strong>Platform:</strong> ${platform} | ${voiceStatus}`;
                    console.log(`Voice info updated: ${voiceInfo} on ${platform}`);
                }
            }

            updateUI() {
                const trialCount = document.getElementById('trial-count');
                if (trialCount) {
                    trialCount.textContent = this.session.trialIndex;
                }
                const scoreEl = document.getElementById('score');
                if (scoreEl) {
                    scoreEl.textContent = this.score;
                }
                const omissionsEl = document.getElementById('omissions');
                if (omissionsEl) {
                    omissionsEl.textContent = this.omissions;
                }
                const accuracyEl = document.getElementById('accuracy');
                const accuracy = this.totalResponses > 0 ? (this.correctResponses / this.totalResponses) * 100 : null;
                if (accuracyEl) {
                    accuracyEl.textContent = accuracy !== null ? `${accuracy.toFixed(1)}%` : '-';
                }
                const rollingEl = document.getElementById('rolling-acc');
                const rolling = this.recentAccuracy.length > 0
                    ? (this.recentAccuracy.reduce((a, b) => a + b, 0) / this.recentAccuracy.length) * 100
                    : null;
                if (rollingEl) {
                    rollingEl.textContent = rolling !== null ? `${rolling.toFixed(1)}%` : '-';
                }

                const running = this.session.state === 'RUNNING';
                const statusText = running ? `Running (n=${this.n}, k=${this.k})` : this.statusMessage;
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.textContent = statusText;
                }

                const startBtn = document.getElementById('start-btn');
                if (startBtn) startBtn.disabled = running;
                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) restartBtn.disabled = !running;
                const stopBtn = document.getElementById('stop-btn');
                if (stopBtn) stopBtn.disabled = !running;
            }

            prepareSession(sess) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SESSION START DIAGNOSTICS
                // Log all critical session parameters to help debug mode/seed issues.
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.log('');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üöÄ SESSION INITIALIZATION - prepareSession()');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                const dropdown = document.getElementById('logic-level-select');
                const selectedMode = dropdown ? parseInt(dropdown.value) : 0;
                const kSlider = document.getElementById('k-slider');
                const kSliderValue = kSlider ? parseInt(kSlider.value) : 0;

                console.log('[Session Init] Dropdown state:', {
                    dropdown_exists: !!dropdown,
                    dropdown_value: dropdown?.value,
                    selectedMode_parsed: selectedMode,
                    selected_option_text: dropdown?.selectedOptions[0]?.text
                });

                console.log('[Session Init] K parameter state:', {
                    k_slider_value: kSliderValue,
                    GameEngine_k_property: this.k,
                    will_use_k: this.k
                });

                console.log('[Session Init] Seed state:', {
                    lockSeed_property: this.lockSeed,
                    lockSeed_localStorage: localStorage.getItem('relational-nback-lock-seed'),
                    lastSeed_localStorage: localStorage.getItem('relational-nback-last-seed')
                });

                console.log('[Session Init] Session parameters:', {
                    n: this.n,
                    numTrials: this.numTrials,
                    secondsPerTrial: this.secondsPerTrial,
                    listenOnly: this.listenOnly
                });

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('');

                const totalPlanned = sess.numTrials;
                this.session = sessionDefaults();
                this.session.trialIndex = 0;
                this.session.numTrials = totalPlanned;
                this.session.state = 'RUNNING';
                this.policy = sess.policy;
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.pendingPlannerFlip = false;
                this.awaitingResponse = false;
                this.lastSpokenFallback = false;

                const shouldResetLogs = !this.pendingRestart || this.resetOnRestart;
                this.pendingRestart = false;

                const seed = this.seedManager.generateSessionSeed(this.lockSeed);
                this.session.seedSession = seed;
                this.state = new GameState(seed, { windowSize: Math.max(2 * this.n + 2, 12) });
                this.state.resetNovelty();
                this.solver = new ConstraintSolver();
                this.generator = new PremiseGenerator(this.state, this.solver, this.equivalence);
                this.planner = new MatchPlanner(this.state.rng);
                this.generator.setPlanner(this.planner);
                this.matchSchedule = this.planner.plan(totalPlanned, this.n);
                if (shouldResetLogs) {
                    this.logger.reset();
                }
                this.currentPremises = [];
                this.statusMessage = `Running (n=${this.n}, k=${this.k})`;
                this.sessionToken = makeEpoch();

                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = '';
                }
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    feedbackEl.textContent = '';
                    feedbackEl.className = 'feedback';
                }
                const repeatBtn = document.getElementById('repeat-btn');
                if (repeatBtn) repeatBtn.disabled = true;
                const matchBtn = document.getElementById('match-btn');
                if (matchBtn) matchBtn.disabled = true;
                const noMatchBtn = document.getElementById('no-match-btn');
                if (noMatchBtn) noMatchBtn.disabled = true;
                window.__imagiActiveResponse = null;
                window.forceCurrentTrialTimeout = null;
                window.currentPremiseText = '';

                this.updateUI();
            }

            async finalizeSession(sess, aborted) {
                // CRITICAL FIX: Add comprehensive logging to track why session is stopping
                const reason = aborted ? 'ABORTED' : 'COMPLETED';
                const trialProgress = `${sess?.trialIndex || 0}/${sess?.numTrials || 'unknown'}`;
                console.log(`finalizeSession called: ${reason}, trials: ${trialProgress}, epoch: ${sess?.epoch}`);

                // DEFENSIVE: Capture stack trace to see what triggered this finalization
                if (aborted && sess && sess.trialIndex < sess.numTrials) {
                    console.warn(`Session stopped prematurely at trial ${sess.trialIndex}/${sess.numTrials}. Stack trace:`);
                    console.trace();
                }

                this.awaitingResponse = false;
                this.session.state = 'STOPPED';
                this.statusMessage = aborted ? 'Stopped' : `Session complete. ${this.session.numTrials} trials finished.`;
                if (!aborted) {
                    this.renderSummary();
                }
                this.activePremise = null;
                this.updateUI();
            }

            planTrial(trialIndex) {
                const scheduledMatch = this.matchSchedule[trialIndex] || false;
                const nBackIndex = trialIndex - this.n;
                const nBackPremise = nBackIndex >= 0 ? this.currentPremises[nBackIndex] : null;
                const middleAtoms = nBackIndex >= 0 ? this.state.getConstraintsInRange(nBackIndex + 1, trialIndex - 1) : [];
                const cooldown = this.state.getActiveCooldown(trialIndex);
                const planMatch = scheduledMatch && Boolean(nBackPremise);
                const foilPlan = (!planMatch && nBackPremise) ? this.planner.maybePlanFoil() : null;
                return { trialIndex, scheduledMatch, nBackPremise, middleAtoms, cooldown, planMatch, foilPlan };
            }

            tryGenerate(plan, override = null) {
                const params = {
                    trialIndex: plan.trialIndex,
                    k: this.k,
                    n: this.n,
                    plannedMatch: override !== null ? override : plan.planMatch,
                    nBackPremise: plan.nBackPremise,
                    middleAtoms: plan.middleAtoms,
                    avoidLetters: (override !== null ? override : plan.planMatch) ? plan.cooldown : null,
                    allowOverride: true,
                    foilPlan: plan.foilPlan,
                    forceMetaLeap: this.forceMetaLeap,
                    forceCompoundLeap: this.forceCompoundLeap
                };
                return this.generator.generate(params);
            }

            async generatePremiseGuaranteed(plan) {
                for (let attempt = 0; attempt < 30; attempt++) {
                    const result = this.tryGenerate(plan, null);
                    if (result) {
                        return { ...result, planMatch: plan.planMatch };
                    }
                    if (plan.scheduledMatch && attempt === 0) {
                        this.planner.forceFlip(plan.trialIndex);
                        this.pendingPlannerFlip = true;
                        const flipped = this.tryGenerate(plan, false);
                        if (flipped) {
                            return { ...flipped, planMatch: false };
                        }
                    }
                }

                if (!plan._flipped && plan.nBackPremise) {
                    const flippedPlan = { ...plan, planMatch: !plan.planMatch, scheduledMatch: false, _flipped: true };
                    for (let attempt = 0; attempt < 30; attempt++) {
                        const result = this.tryGenerate(flippedPlan, flippedPlan.planMatch);
                        if (result) {
                            return { ...result, planMatch: flippedPlan.planMatch };
                        }
                    }
                }

                return this.buildNeutralNonMatch(plan);
            }

            buildNeutralNonMatch(plan) {
                const letters = this.state?.letters || 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const head = this.state?.rng ? this.state.rng.choice(letters) : letters[0];
                const tails = letters.filter(letter => letter !== head);
                const tail = (this.state?.rng ? this.state.rng.choice(tails.length ? tails : letters) : (tails[0] || letters[1] || head));
                const axis = this.state?.rng ? this.state.rng.choice(MATCH_AXES) : 'N';
                const safeTail = tail === head ? letters[(letters.indexOf(head) + 1) % letters.length] : tail;
                const premise = new Premise([new Atom(axis, head, safeTail)]);
                const signatures = this.state ? this.state.novelty.buildSignatures(premise) : { exact: premise.toKey() };
                const windowAtoms = this.state ? this.state.getWindowAtoms() : [];
                const satResult = this.solver ? this.solver.evaluate(windowAtoms, premise.atoms) : { ok: true, coordinates: new Map() };
                return {
                    premise,
                    signatures,
                    novelty: { noveltyScores: {}, blocked: false },
                    satResult,
                    certificate: null,
                    modeUsed: 'fallback',
                    features: premise.getFeatures(),
                    foilType: null,
                    planMatch: false
                };
            }


            async executeTrial(sess, trialToken, signal) {
                // CRITICAL FIX: Enhanced validation with detailed logging
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid at start, trial ${sess.trialIndex}, reason: ${!session ? 'no global session' : session.epoch !== sess.epoch ? 'epoch mismatch' : trialToken !== session.trialToken ? 'token mismatch' : signal.aborted ? 'signal aborted' : 'unknown'}`);
                    return;
                }
                resetSpeechGateForTrial();
                const currentIndex = sess.trialIndex;
                this.session.trialIndex = currentIndex;
                this.updateUI();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // RUNTIME DIAGNOSTICS UPDATE
                // Update diagnostic panel with actual runtime values EVERY trial.
                // This provides visibility into mode selection, k parameter, and seed state.
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const diagnosticsPanel = document.getElementById('runtime-diagnostics-panel');
                if (diagnosticsPanel && this.session.state === 'RUNNING') {
                    diagnosticsPanel.style.display = 'block';

                    // Read ACTUAL mode from dropdown at runtime
                    const dropdown = document.getElementById('logic-level-select');
                    const selectedMode = dropdown ? parseInt(dropdown.value) : 0;

                    const modeNames = [
                        'Standard / Manual',
                        'Dialectical Superposition',
                        'Semantic Tensor',
                        'System Homology',
                        'Complementary Interface'
                    ];
                    const modeName = modeNames[selectedMode] || 'Unknown';

                    // Update mode indicator (green if Mode 1, cyan otherwise)
                    const modeValueSpan = document.getElementById('mode-value');
                    if (modeValueSpan) {
                        modeValueSpan.textContent = `${selectedMode} (${modeName})`;
                        modeValueSpan.style.color = selectedMode === 1 ? '#00ff00' :
                                                     selectedMode === 2 ? '#ffff00' :
                                                     selectedMode >= 3 ? '#ff00ff' : '#00ffff';
                    }

                    // Update k indicator
                    const kValueSpan = document.getElementById('k-value-runtime');
                    if (kValueSpan) {
                        kValueSpan.textContent = this.k;
                        kValueSpan.style.color = this.k === 2 && selectedMode === 1 ? '#00ff00' :
                                                 this.k === 2 && selectedMode === 2 ? '#00ff00' : '#00ffff';
                    }

                    // Update seed indicator (RED if locked, GREEN if random)
                    const seedValueSpan = document.getElementById('seed-value-runtime');
                    if (seedValueSpan) {
                        const seedHex = this.state.seed.toString(16).toUpperCase().padStart(8, '0');
                        const lockStatus = this.lockSeed ? '[LOCKED]' : '[RANDOM]';
                        seedValueSpan.textContent = `${seedHex} ${lockStatus}`;
                        seedValueSpan.style.color = this.lockSeed ? '#ff0000' : '#00ff00';
                    }

                    // Update trial indicator
                    const trialValueSpan = document.getElementById('trial-value-runtime');
                    if (trialValueSpan) {
                        trialValueSpan.textContent = `${sess.trialIndex + 1}/${sess.numTrials}`;
                    }

                    console.log('[Runtime Diagnostics] Mode:', selectedMode, modeName, '| k:', this.k, '| Seed:', this.state.seed, '| Locked:', this.lockSeed);
                } else if (diagnosticsPanel && this.session.state === 'STOPPED') {
                    diagnosticsPanel.style.display = 'none';
                }

                let plan = this.planTrial(currentIndex);
                let result = null;
                try {
                    result = await this.generatePremiseGuaranteed(plan);
                } catch (err) {
                    console.error('[executeTrial] Premise generation threw exception:', err);
                    result = null;
                }
                if (!result) {
                    console.warn('[executeTrial] Premise generation returned null; using neutral fallback.');
                    result = this.buildNeutralNonMatch(plan);
                }

                const { premise, signatures, novelty, satResult, certificate, modeUsed, features, foilType, planMatch } = result;
                this.activePremise = premise;
                const planType = planMatch ? 'match' : (foilType ? `foil:${foilType}` : 'nonmatch');
                const featureSnapshot = features || premise.getFeatures();

                this.currentPremises.push(premise);
                this.state.recordPremise(premise, premise.atoms, { plannedMatch: planMatch, certificate, modeUsed, foilType });
                this.state.novelty.register(signatures);
                this.state.coordinates = satResult.coordinates;

                sess.phaseToken = (sess.phaseToken || 0) + 1;
                const premiseDisplay = document.getElementById('premise-display');
                if (premiseDisplay) {
                    premiseDisplay.textContent = premise.toString();
                }
                window.currentPremiseText = formatPremiseForSpeech(premise);
                const matchBtn = document.getElementById('match-btn');
                const noMatchBtn = document.getElementById('no-match-btn');
                const repeatBtn = document.getElementById('repeat-btn');
                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = false;

                const speechMeta = await speakPremiseSafe(sess, premise, trialToken, signal);
                this.lastSpokenFallback = Boolean(speechMeta?.fallback);
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid after speech, trial ${currentIndex}`);
                    return;
                }

                if (sess.policy === AdvancePolicy.LISTEN) {
                    await dwellSafe(this.secondsPerTrial, trialToken, signal);
                    if (!valid(sess, trialToken)) {
                        console.warn(`executeTrial: invalid after dwell, trial ${currentIndex}`);
                        return;
                    }
                    this.logTrial({
                        planMatch,
                        planType,
                        certificate,
                        featureSnapshot,
                        premise,
                        novelty,
                        satResult,
                        foilType,
                        responsePayload: { choice: null, correct: null, rt: null, omission: false, timeout: false },
                        modeUsed,
                        trialIndex: currentIndex,
                        passiveAdvance: true,
                        trialTokenAtStart: trialToken,
                        listenOnly: true
                    });
                    if (repeatBtn) repeatBtn.disabled = true;
                    const feedbackEl = document.getElementById('feedback');
                    if (feedbackEl) {
                        feedbackEl.textContent = 'Listening‚Ä¶';
                        feedbackEl.className = 'feedback';
                    }
                    this.updateUI();
                    this.activePremise = null;
                    return;
                }

                this.awaitingResponse = true;
                this.responseStartTime = Date.now();
                if (matchBtn) matchBtn.disabled = false;
                if (noMatchBtn) noMatchBtn.disabled = false;

                const response = await collectResponseSafe(this.secondsPerTrial, trialToken, signal);
                this.awaitingResponse = false;
                if (!valid(sess, trialToken)) {
                    console.warn(`executeTrial: invalid after collectResponse, trial ${currentIndex}`);
                    return;
                }

                if (matchBtn) matchBtn.disabled = true;
                if (noMatchBtn) noMatchBtn.disabled = true;
                if (repeatBtn) repeatBtn.disabled = true;

                const responseChoice = response?.type === 'answer' ? response.choice : null;
                const timeout = response?.type === 'timeout';
                const omission = timeout || responseChoice === null;
                const actualMatch = (modeUsed === 'META' || modeUsed === 'COMPOUND_OPERATOR')
                    ? planMatch  // For operator modes, use planMatch directly
                    : Boolean(planMatch && certificate);  // For atomic modes, use equivalence engine
                let correct = null;
                if (!timeout && responseChoice !== null) {
                    correct = (responseChoice === 'match') === actualMatch;
                }

                if (timeout) {
                    this.omissions += 1;
                } else if (correct !== null) {
                    this.totalResponses += 1;
                    if (correct) {
                        this.score += 1;
                        this.correctResponses += 1;
                    }
                    this.recentAccuracy.push(correct ? 1 : 0);
                    if (this.recentAccuracy.length > this.M) {
                        this.recentAccuracy.shift();
                    }
                }

                const rt = (!timeout && responseChoice !== null) ? Date.now() - this.responseStartTime : null;
                const feedbackEl = document.getElementById('feedback');
                if (feedbackEl) {
                    if (timeout) {
                        feedbackEl.textContent = 'Response window expired.';
                        feedbackEl.className = 'feedback incorrect';
                    } else if (correct) {
                        feedbackEl.textContent = 'Correct';
                        feedbackEl.className = 'feedback correct';
                    } else if (correct === false) {
                        feedbackEl.textContent = 'Incorrect';
                        feedbackEl.className = 'feedback incorrect';
                    } else {
                        feedbackEl.textContent = '';
                        feedbackEl.className = 'feedback';
                    }
                }

                if (actualMatch && certificate) {
                    this.state.applyCooldown(Array.from(premise.getLetters()), currentIndex, this.n);
                }

                this.logTrial({
                    planMatch,
                    planType,
                    certificate,
                    featureSnapshot,
                    premise,
                    novelty,
                    satResult,
                    foilType,
                    responsePayload: {
                        choice: responseChoice,
                        correct,
                        rt,
                        omission,
                        timeout
                    },
                    modeUsed,
                    trialIndex: currentIndex,
                    passiveAdvance: false,
                    trialTokenAtStart: trialToken,
                    listenOnly: false
                });

                this.activePremise = null;
                this.updateUI();
            }

            logTrial({ planMatch, planType, certificate, featureSnapshot, premise, novelty, satResult, foilType, responsePayload, modeUsed, trialIndex, passiveAdvance, trialTokenAtStart, listenOnly }) {
                const { choice, correct, rt, omission, timeout } = responsePayload;
                const featureLog = {
                    lettersSet: Array.from(featureSnapshot.lettersSet).sort(),
                    degreeVector: {},
                    skeletonIsoSignature: featureSnapshot.skeletonIsoSignature,
                    atomAxisProfile: {}
                };
                featureSnapshot.degreeVector.forEach((vec, letter) => {
                    featureLog.degreeVector[letter] = [...vec];
                });
                featureSnapshot.atomAxisProfile.forEach((count, axis) => {
                    featureLog.atomAxisProfile[axis] = count;
                });

                const plannerFlip = this.pendingPlannerFlip || (this.planner && typeof this.planner.wasFlipped === 'function' ? this.planner.wasFlipped(trialIndex) : false);
                this.pendingPlannerFlip = false;

                const logEntry = {
                    seedSession: this.seedManager.sessionSeed,
                    trialIndex,
                    trialNumber: trialIndex + 1,
                    numTrials: this.session.numTrials,
                    n: this.n,
                    k: this.k,
                    letters: Array.from(premise.getLetters()).join(''),
                    atomsCanonical: premise.toKey(),
                    atomsMirrorCanonical: premise.mirrorKey(),
                    isoSignature: premise.isoSignature(),
                    plannedMatch: planMatch,
                    planType,
                    foilType: foilType || null,
                    certificate: certificate || null,
                    satStatus: satResult.ok,
                    midWindowDerivable: certificate ? certificate.midWindowDerivable : false,
                    noveltyScores: novelty?.noveltyScores || {},
                    response: { choice, correct, rtMs: rt, omission, timeout },
                    cooldownLetters: Array.from(this.state.getActiveCooldown(trialIndex + 1)),
                    plannerFlip,
                    modeUsed,
                    mode: listenOnly ? AdvancePolicy.LISTEN : AdvancePolicy.ACTIVE,
                    passiveAdvance,
                    ttsFallback: Boolean(this.lastSpokenFallback),
                    trialTokenAtStart,
                    features: featureLog
                };

                this.logger.add(logEntry);
                this.updateDebugPanel(logEntry);
            }

            updateDebugPanel(entry) {
                const debug = document.getElementById('debug-content');
                if (!debug) return;
                const el = document.createElement('div');
                el.className = 'debug-premise';
                el.textContent = `Trial ${entry.trialIndex}: ${entry.atomsCanonical} | Plan=${entry.planType} | Response=${entry.response.choice}`;
                debug.prepend(el);
                while (debug.childElementCount > 20) {
                    debug.removeChild(debug.lastChild);
                }
            }

            exportData() {
                const data = {
                    seedSession: this.seedManager.sessionSeed,
                    entries: this.logger.getEntriesSnapshot()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `imagi-world-session-${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        const DEBOUNCE_MS = 250;
        let lastBtn = 0;

        function debounce() {
            const now = performance.now();
            if (now - lastBtn < DEBOUNCE_MS) return false;
            lastBtn = now;
            return true;
        }

        function cancelSpeechImmediately() {
            try {
                window.speechSynthesis?.cancel();
            } catch (err) {
                console.warn('speechSynthesis.cancel immediate failed', err);
            }
        }

        function clearAllEngineTimers() {
            Timer.cancelAll();
            clearHeartbeat();
        }

        function stopSession() {
            if (!session) {
                console.log('stopSession called, but no active session');
                return;
            }

            // CRITICAL FIX: Add logging to track when and why stopSession is called
            console.log(`stopSession called: trial ${session.trialIndex}/${session.numTrials}, epoch ${session.epoch}`);
            console.trace('stopSession stack trace:');

            try {
                session.abort.abort();
            } catch (err) {
                console.warn('abort stop failed', err);
            }
            clearAllEngineTimers();
            cancelSpeechImmediately();
            SpeechGate.inFlight = false;
            SpeechGate.flightToken = null;
            engine.finalizeSession(session, true);
            window.__imagiActiveResponse = null;
            window.forceCurrentTrialTimeout = null;
            session = null;
        }

        async function runLoop(sess) {
            const signal = sess.abort.signal;
            console.log(`runLoop started: epoch ${sess.epoch}, numTrials ${sess.numTrials}`);

            // CRITICAL FIX: Wrap each trial in try-catch to prevent single trial errors from stopping entire session
            while (!signal.aborted && sess.trialIndex < sess.numTrials) {
                sess.trialToken += 1;
                sess.phaseToken = 0;

                try {
                    await engine.executeTrial(sess, sess.trialToken, signal);
                } catch (err) {
                    console.error(`runLoop: Error in executeTrial at trial ${sess.trialIndex}:`, err);
                    // DEFENSIVE: Log error but continue with next trial instead of stopping entire session
                    // This prevents transient errors (speech synthesis failures, DOM timing issues) from killing the session
                    console.warn(`Continuing to next trial despite error in trial ${sess.trialIndex}`);
                }

                if (signal.aborted) {
                    console.warn(`runLoop: aborted at trial ${sess.trialIndex}`);
                    break;
                }
                sess.trialIndex += 1;
            }

            if (!signal.aborted) {
                console.log(`runLoop: completed ${sess.trialIndex}/${sess.numTrials} trials normally`);
                await engine.finalizeSession(sess, false);
                clearAllEngineTimers();
                session = null;
            } else {
                console.warn(`runLoop: session aborted, completed ${sess.trialIndex}/${sess.numTrials} trials`);
                // Note: Don't call finalizeSession here - stopSession() already does it
            }
        }

        function startSession() {
            if (!debounce()) return;

            // CRITICAL FIX: Clean up old session first, then create new one atomically
            // This prevents race conditions between stopSession() and session creation
            stopSession();

            // Create new session and prepare engine BEFORE starting runLoop
            const newSess = newSession(engine);
            session = newSess;  // Set global session immediately to prevent epoch mismatches

            engine.prepareSession(newSess);
            wireHeartbeat(newSess);

            // CRITICAL FIX: Add better error handling that doesn't stop on transient errors
            runLoop(newSess).catch((err) => {
                console.error('runLoop encountered error:', err);
                // Only stop if session is still the one that errored (not already replaced)
                if (session && session.epoch === newSess.epoch) {
                    console.error('Stopping session due to unrecoverable error in runLoop');
                    stopSession();
                } else {
                    console.warn('runLoop error for stale session, ignoring');
                }
            });
        }

        function restartSession() {
            if (!debounce()) return;
            stopSession();
            startSession();
        }

        function formatPremiseForSpeech(premise) {
            if (!premise) return '';

            // Use premise's toNaturalSpeech() method which handles all types
            return premise.toNaturalSpeech();
        }

        function estimateUtteranceMs(text, rate = 0.9) {
            const cps = 12 * rate;
            return Math.max(900, Math.min(9000, Math.round((text.length / cps) * 1000) + 300));
        }

        async function speakPremiseSafe(sess, premise, trialToken, signal) {
            if (!valid(sess, trialToken)) {
                return { fallback: false, attempts: 0 };
            }

            return new Promise((resolve) => {
                const mySpeakId = SpeechGate.trialSpeakId;
                const myRepeatPhase = SpeechGate.explicitRepeatPhase;

                if (SpeechGate.inFlight) {
                    resolve({ fallback: false, attempts: 0 });
                    return;
                }

                const flightToken = Symbol('speech-flight');
                SpeechGate.inFlight = true;
                SpeechGate.flightToken = flightToken;

                try {
                    window.speechSynthesis?.cancel();
                } catch (err) {
                    console.warn('speechSynthesis.cancel before speak failed', err);
                }
                try {
                    window.speechSynthesis?.resume();
                } catch (err) {
                    console.warn('speechSynthesis.resume after cancel failed', err);
                }

                const text = formatPremiseForSpeech(premise);
                window.currentPremiseText = text;
                const utterance = new SpeechSynthesisUtterance(text);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // iOS CRITICAL FIX: Use VoiceSynthesis class's selected voice
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PROBLEM: Previous code used voices[0] which on iPhone = Reed (male)
                // SOLUTION: Use engine.voice.getFreshVoiceObject() for properly selected female voice
                // This matches the Voice Preview button behavior which works perfectly on iPhone

                const freshVoice = engine?.voice?.getFreshVoiceObject();
                if (freshVoice) {
                    utterance.voice = freshVoice;
                    utterance.lang = freshVoice.lang;
                    console.log(`‚úì speakPremiseSafe using selected voice: ${freshVoice.name} (${freshVoice.lang})`);
                } else {
                    console.error('‚úó speakPremiseSafe: getFreshVoiceObject() returned null - attempting fallback');
                    // Fallback: Try to get voices array directly (should not happen if voice initialized)
                    const voices = window.speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        // Last resort: use voices[0] (will be male on iPhone, but better than silence)
                        utterance.voice = voices[0];
                        utterance.lang = voices[0].lang;
                        console.warn(`‚ö† Using fallback voice: ${voices[0].name} (may be male on iPhone)`);
                    }
                }

                const pitch = engine?.voice?.pitch ?? 1.2;
                const rate = engine?.voice?.rate ?? 0.9;
                const volume = engine?.voice?.volume ?? 1.0;
                utterance.pitch = pitch;
                utterance.rate = rate;
                utterance.volume = volume;

                instrumentUtterance(utterance);

                let settled = false;

                const finish = (fallback) => {
                    if (settled) return;
                    settled = true;
                    if (SpeechGate.flightToken === flightToken) {
                        SpeechGate.inFlight = false;
                        SpeechGate.flightToken = null;
                    }
                    clearTimeout(fallbackTimer);
                    signal.removeEventListener('abort', onAbort);
                    resolve({ fallback, attempts: 1 });
                };

                const onAbort = () => finish(false);
                signal.addEventListener('abort', onAbort, { once: true });

                const fallbackTimer = setTimeout(() => {
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    finish(true);
                }, estimateUtteranceMs(text, rate) + 400);

                utterance.onend = () => finish(false);
                utterance.onerror = () => finish(true);

                setTimeout(() => {
                    if (settled) return;
                    if (signal.aborted) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.trialSpeakId !== mySpeakId) {
                        finish(true);
                        return;
                    }
                    if (SpeechGate.explicitRepeatPhase !== myRepeatPhase) {
                        finish(false);
                        return;
                    }
                    try {
                        window.speechSynthesis?.resume();
                    } catch (err) {
                        console.warn('speechSynthesis.resume failed', err);
                    }
                    try {
                        window.speechSynthesis?.speak(utterance);
                    } catch (err) {
                        console.warn('speechSynthesis.speak failed', err);
                        finish(true);
                    }
                }, 100);
            });
        }

        function secondsPerTrial() {
            return engine.secondsPerTrial;
        }

        async function dwellSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                let resolved = false;
                const safeResolve = () => {
                    if (!resolved) {
                        resolved = true;
                        resolve();
                    }
                };
                Timer.set('dwell', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, safeResolve);
                // Ensure promise resolves if signal aborts
                signal.addEventListener('abort', safeResolve, { once: true });
            });
        }

        function bindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.addEventListener('click', onMatch, { once: true });
            noMatchBtn?.addEventListener('click', onNo, { once: true });
        }

        function unbindTrialButtons(onMatch, onNo) {
            const matchBtn = document.getElementById('match-btn');
            const noMatchBtn = document.getElementById('no-match-btn');
            matchBtn?.removeEventListener('click', onMatch);
            noMatchBtn?.removeEventListener('click', onNo);
        }

        async function collectResponseSafe(seconds, trialToken, signal) {
            return new Promise((resolve) => {
                let settled = false;
                const settle = (payload) => {
                    if (settled) {
                        console.warn(`collectResponseSafe: settle() called multiple times for trial token ${trialToken} - IGNORING duplicate call. Payload:`, payload);
                        console.trace('Duplicate settle() call stack trace:');
                        return;
                    }
                    settled = true;
                    cleanup();
                    resolve(payload);
                };

                const onMatch = () => settle({ type: 'answer', choice: 'match' });
                const onNo = () => settle({ type: 'answer', choice: 'nomatch' });
                bindTrialButtons(onMatch, onNo);
                window.__imagiActiveResponse = (choice) => {
                    if (choice === 'match') {
                        onMatch();
                    } else {
                        onNo();
                    }
                };

                const timerId = Timer.set('resp', Math.max(0, Math.round(seconds * 1000)), trialToken, signal, () => settle({ type: 'timeout' }));

                const cleanup = () => {
                    unbindTrialButtons(onMatch, onNo);
                    Timer.clear(timerId);
                    window.__imagiActiveResponse = null;
                    // CRITICAL FIX: Clear forceCurrentTrialTimeout to prevent watchdog from calling stale timeout function
                    // BUG: If watchdog calls forceCurrentTrialTimeout after this trial ends but before next trial starts,
                    // it would call the OLD settle() function, causing undefined behavior and potential session stops
                    window.forceCurrentTrialTimeout = null;
                };

                signal.addEventListener('abort', () => settle({ type: 'timeout' }), { once: true });

                // CRITICAL FIX: Create timeout function with staleness check
                // This prevents watchdog from triggering stale settle() calls that could crash the session
                const timeoutToken = Symbol('timeout-token');
                window.forceCurrentTrialTimeout = () => {
                    // Only settle if this is still the active timeout function (not stale)
                    if (window.forceCurrentTrialTimeout?.timeoutToken === timeoutToken) {
                        console.log(`forceCurrentTrialTimeout called for trial token ${trialToken} - settling as timeout`);
                        settle({ type: 'timeout' });
                    } else {
                        console.warn(`forceCurrentTrialTimeout called but token is stale (expected ${timeoutToken.toString()}, current ${window.forceCurrentTrialTimeout?.timeoutToken?.toString()}) - IGNORING to prevent race condition`);
                    }
                };
                window.forceCurrentTrialTimeout.timeoutToken = timeoutToken;
            });
        }

        function wireHeartbeat(sess) {
            clearHeartbeat();
            let lastTick = performance.now();
            let lastTrial = -1;
            let nudgeCount = 0;  // Track consecutive nudges to prevent over-aggressive watchdog

            heartbeat = setInterval(() => {
                // CRITICAL FIX: More defensive session checks to prevent race conditions
                if (!session || !sess) {
                    clearHeartbeat();
                    return;
                }
                if (session.epoch !== sess.epoch) {
                    // Session has been replaced, this watchdog is stale
                    clearHeartbeat();
                    return;
                }
                if (sess.abort.signal.aborted) {
                    clearHeartbeat();
                    return;
                }

                const now = performance.now();

                // Reset nudge count when trial advances successfully
                if (sess.trialIndex !== lastTrial) {
                    lastTrial = sess.trialIndex;
                    lastTick = now;
                    nudgeCount = 0;  // Reset nudge counter on progress
                    return;
                }

                // CRITICAL FIX: More generous timeout calculation to reduce false positives
                // Add extra buffer for browser variability, tab switching, etc.
                const typical = estimateUtteranceMs(window.currentPremiseText || 'H is east of R; Y is north of X.', 0.90) + (secondsPerTrial() * 1000) + 3000;  // Increased from 1500ms to 3000ms buffer
                const elapsed = now - lastTick;

                if (elapsed > typical) {
                    nudgeCount++;
                    console.warn(`Watchdog nudge #${nudgeCount} (elapsed: ${Math.round(elapsed)}ms, typical: ${Math.round(typical)}ms)`);

                    // CRITICAL FIX: Only nudge if we haven't exceeded reasonable retry limit
                    // This prevents infinite nudge loops from stopping the session
                    if (nudgeCount <= 3) {  // Allow up to 3 nudges before giving up on this trial
                        cancelSpeechImmediately();
                        if (session?.policy === AdvancePolicy.ACTIVE) {
                            // CRITICAL FIX: Only call forceCurrentTrialTimeout if it exists and trial tokens match
                            // This prevents calling stale timeout functions that could cause session stops
                            if (typeof window.forceCurrentTrialTimeout === 'function') {
                                console.log(`Watchdog nudge #${nudgeCount}: Calling forceCurrentTrialTimeout for trial ${sess.trialIndex}`);
                                window.forceCurrentTrialTimeout();
                            } else {
                                console.warn(`Watchdog nudge #${nudgeCount}: No active forceCurrentTrialTimeout function (trial might be between states)`);
                            }
                        } else {
                            Timer.set('dwell-nudge', 50, session.trialToken, session.abort.signal, () => {});
                        }
                    } else {
                        console.error(`Watchdog: Trial ${sess.trialIndex} appears stuck after ${nudgeCount} nudges, but continuing session`);
                        // Don't abort the session - just reset the tick and hope next trial works
                        // This is better than stopping the entire session randomly
                    }

                    lastTick = now;  // Reset tick regardless of nudge count
                }
            }, 500);
        }

        function onRepeatPressed() {
            if (!session) return;
            const premise = engine.activePremise || engine.currentPremises[Math.max(0, session.trialIndex - 1)];
            if (!premise) return;
            noteExplicitRepeat();
            cancelSpeechImmediately();
            setTimeout(() => {
                if (!session || session.abort.signal.aborted) return;
                SpeechGate.inFlight = false;
                SpeechGate.flightToken = null;
                speakPremiseSafe(session, premise, session.trialToken, session.abort.signal);
            }, 120);
        }

        function shouldAutoStopForOmissions() {
            return session?.policy === AdvancePolicy.ACTIVE;
        }

        document.addEventListener('visibilitychange', () => {
            try {
                window.speechSynthesis?.resume();
            } catch (err) {
                console.warn('speechSynthesis.resume visibility failed', err);
            }
        });

        class InstructionsManager {
            constructor(engine) {
                this.engine = engine;
                this.voice = engine.voice;
                this.sections = TUTORIAL_SECTIONS;
                this.dialog = document.getElementById('dlgInstructions');
                this.openButton = document.getElementById('btnInstructions');
                this.closeButton = document.getElementById('instClose');
                this.nav = document.getElementById('instTabs');
                this.tabButtons = Array.from(this.nav.querySelectorAll('button'));
                this.content = document.getElementById('instContent');
                this.prevButton = document.getElementById('instPrev');
                this.nextButton = document.getElementById('instNext');
                this.readAloudCheckbox = document.getElementById('instReadAloud');
                this.currentIndex = 0;
                this.dialogOpen = false;
                this.previousFocus = null;
                this.visited = new Set();
                this.completed = false;
                this.readAloud = false;
                this.pendingSpeechToken = null;
                this.boundKeydown = (event) => this.handleKeydown(event);
                this.boundFocusIn = (event) => this.enforceFocus(event);
                this.nav.setAttribute('role', 'tablist');
                this.tabButtons.forEach(btn => {
                    btn.setAttribute('role', 'tab');
                    const isActive = this.sections[this.currentIndex] && this.sections[this.currentIndex].id === btn.dataset.tab;
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    btn.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                this.sandbox = {
                    premise: null,
                    mapping: {},
                    journal: []
                };
                this.sandboxElements = null;
            }

            initialize() {
                this.loadState();
                this.attachEvents();
                this.renderCurrentSection();
                this.updateCompletionState();
            }

            loadState() {
                const storedSection = localStorage.getItem('instSection');
                const storedIndex = this.sections.findIndex(section => section.id === storedSection);
                if (storedIndex >= 0) {
                    this.currentIndex = storedIndex;
                }

                const visitedRaw = localStorage.getItem('instVisited');
                if (visitedRaw) {
                    try {
                        const parsed = JSON.parse(visitedRaw);
                        if (Array.isArray(parsed)) {
                            parsed.forEach(id => this.visited.add(id));
                        }
                    } catch (err) {
                        console.warn('Failed to parse tutorial visited state', err);
                    }
                }

                const completed = localStorage.getItem('instCompleted');
                this.completed = completed === 'true';

                const readAloud = localStorage.getItem('instReadAloud');
                this.readAloud = readAloud === 'true';
                this.readAloudCheckbox.checked = this.readAloud;

                const journalRaw = localStorage.getItem('instPracticeJournal');
                if (journalRaw) {
                    try {
                        const parsed = JSON.parse(journalRaw);
                        if (Array.isArray(parsed)) {
                            this.sandbox.journal = parsed;
                        }
                    } catch (err) {
                        console.warn('Failed to parse sandbox journal', err);
                    }
                }
            }

            attachEvents() {
                this.openButton.addEventListener('click', () => this.openDialog());

                // Da Vinci Instructions button - opens dialog directly to Da Vinci tutorial tab
                const daVinciButton = document.getElementById('btnDaVinciInstructions');
                if (daVinciButton) {
                    daVinciButton.addEventListener('click', () => {
                        this.openDialog();
                        // Find the Da Vinci tab index
                        const daVinciIndex = this.sections.findIndex(section => section.id === 'davinci-method');
                        if (daVinciIndex !== -1) {
                            this.navigateTo(daVinciIndex);
                        }
                    });
                }

                this.closeButton.addEventListener('click', () => this.closeDialog());

                this.tabButtons.forEach((button) => {
                    const sectionId = button.dataset.tab;
                    const index = this.sections.findIndex(section => section.id === sectionId);
                    if (index === -1) return;
                    button.addEventListener('click', () => {
                        this.currentIndex = index;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    });
                });

                this.prevButton.addEventListener('click', () => {
                    if (this.currentIndex > 0) {
                        this.currentIndex -= 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.nextButton.addEventListener('click', () => {
                    if (this.currentIndex < this.sections.length - 1) {
                        this.currentIndex += 1;
                        this.renderCurrentSection();
                        if (this.dialogOpen && this.readAloud) {
                            this.queueSpeech();
                        }
                    }
                });

                this.readAloudCheckbox.addEventListener('change', (event) => {
                    this.readAloud = event.target.checked;
                    localStorage.setItem('instReadAloud', this.readAloud ? 'true' : 'false');
                    if (this.dialogOpen && this.readAloud) {
                        this.queueSpeech(true);
                    } else {
                        this.cancelSpeech();
                    }
                });
            }

            openDialog() {
                if (this.dialogOpen) return;
                this.dialogOpen = true;
                this.previousFocus = document.activeElement;
                this.dialog.hidden = false;
                document.body.classList.add('dialog-open');
                this.content.scrollTop = 0;
                this.markVisited(this.sections[this.currentIndex].id);
                this.focusInitialElement();
                document.addEventListener('keydown', this.boundKeydown, true);
                document.addEventListener('focusin', this.boundFocusIn, true);
                if (this.readAloud) {
                    this.queueSpeech(true);
                }
            }

            closeDialog() {
                if (!this.dialogOpen) return;
                this.dialogOpen = false;
                this.dialog.hidden = true;
                document.body.classList.remove('dialog-open');
                document.removeEventListener('keydown', this.boundKeydown, true);
                document.removeEventListener('focusin', this.boundFocusIn, true);
                this.cancelSpeech();
                if (this.previousFocus && typeof this.previousFocus.focus === 'function') {
                    this.previousFocus.focus();
                } else {
                    this.openButton.focus();
                }
            }

            handleKeydown(event) {
                if (!this.dialogOpen) return;
                if (event.key === 'Escape') {
                    event.preventDefault();
                    this.closeDialog();
                    return;
                }
                if (event.key === 'Tab') {
                    this.trapFocus(event);
                }
            }

            enforceFocus(event) {
                if (!this.dialogOpen) return;
                if (!this.dialog.contains(event.target)) {
                    const focusable = this.getFocusableElements();
                    if (focusable.length > 0) {
                        focusable[0].focus();
                    } else {
                        this.content.focus();
                    }
                }
            }

            trapFocus(event) {
                const focusable = this.getFocusableElements();
                if (focusable.length === 0) {
                    event.preventDefault();
                    this.content.focus();
                    return;
                }
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                const active = document.activeElement;

                if (event.shiftKey) {
                    if (active === first || !this.dialog.contains(active)) {
                        event.preventDefault();
                        last.focus();
                    }
                } else {
                    if (active === last) {
                        event.preventDefault();
                        first.focus();
                    }
                }
            }

            getFocusableElements() {
                const selectors = ['button', '[href]', 'input', 'select', 'textarea', '[tabindex]:not([tabindex="-1"])'];
                return Array.from(this.dialog.querySelectorAll(selectors.join(',')))
                    .filter(el => !el.hasAttribute('disabled') && el.tabIndex !== -1 && this.dialog.contains(el));
            }

            focusInitialElement() {
                const focusable = this.getFocusableElements();
                if (focusable.length > 0) {
                    focusable[0].focus();
                } else {
                    this.content.focus();
                }
            }

            renderCurrentSection() {
                const section = this.sections[this.currentIndex];
                if (!section) return;
                this.tabButtons.forEach((button) => {
                    const isActive = button.dataset.tab === section.id;
                    button.classList.toggle('active', isActive);
                    if (this.visited.has(button.dataset.tab)) {
                        button.classList.add('visited');
                    }
                    button.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    button.setAttribute('tabindex', isActive ? '0' : '-1');
                });
                if (typeof section.render === 'function') {
                    this.content.innerHTML = '';
                    section.render(this.content);
                } else {
                    this.content.innerHTML = section.html;
                    if (section.id === 'examples') {
                        renderGuidedExamples();
                    }
                }
                this.content.scrollTop = 0;
                localStorage.setItem('instSection', section.id);
                this.markVisited(section.id);
                this.updateNavButtons();
                if (section.id === 'practice') {
                    this.setupSandboxUI();
                } else {
                    this.sandboxElements = null;
                }
                if (this.dialogOpen && this.readAloud) {
                    this.queueSpeech();
                }
            }

            updateNavButtons() {
                this.prevButton.disabled = this.currentIndex === 0;
                this.nextButton.disabled = this.currentIndex === this.sections.length - 1;
            }

            markVisited(id) {
                if (!this.visited.has(id)) {
                    this.visited.add(id);
                    localStorage.setItem('instVisited', JSON.stringify(Array.from(this.visited)));
                }
                if (this.visited.size === this.sections.length) {
                    this.completed = true;
                    localStorage.setItem('instCompleted', 'true');
                }
                this.updateCompletionState();
            }

            updateCompletionState() {
                this.openButton.classList.toggle('completed', this.completed);
            }

            async queueSpeech(force = false) {
                if (!this.readAloud || !this.dialogOpen) return;
                if (!this.voice || !this.voice.voiceReady) return;
                const section = this.sections[this.currentIndex];
                if (!section || !section.speech) return;
                const token = Symbol('instSpeech');
                this.pendingSpeechToken = token;
                if (force) {
                    await this.voice.cancelAndWait();
                } else {
                    await this.voice.cancelAndWait();
                }
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!this.dialogOpen || !this.readAloud || this.pendingSpeechToken !== token) {
                    return;
                }
                await this.voice.speak(section.speech, this.voice.sessionToken);
            }

            cancelSpeech() {
                this.pendingSpeechToken = null;
                if (this.voice && typeof this.voice.cancelAndWait === 'function') {
                    this.voice.cancelAndWait();
                }
            }

            setupSandboxUI() {
                const panel = document.createElement('div');
                panel.className = 'sandbox-panel';

                const workspaceTitle = document.createElement('h4');
                workspaceTitle.textContent = 'Practice Workspace';
                panel.appendChild(workspaceTitle);

                const controls = document.createElement('div');
                controls.className = 'sandbox-controls';

                const loadBtn = this.createSandboxButton('Load current premise', () => this.loadCurrentPremise());
                const spawnBtn = this.createSandboxButton('Spawn practice premise', () => this.spawnPracticePremise());
                const applyBtn = this.createSandboxButton('Apply Relation Operations', () => this.applySandboxOperations());
                const commitBtn = this.createSandboxButton('Commit to Journal', () => this.commitSandboxJournal());

                controls.append(loadBtn, spawnBtn, applyBtn, commitBtn);
                panel.appendChild(controls);

                const status = document.createElement('div');
                status.className = 'hint';
                panel.appendChild(status);

                const atoms = document.createElement('div');
                atoms.className = 'sandbox-atom-list';
                panel.appendChild(atoms);

                const grid = document.createElement('div');
                grid.className = 'sandbox-letter-grid';
                panel.appendChild(grid);

                const journalTitle = document.createElement('h4');
                journalTitle.textContent = 'Journal';
                panel.appendChild(journalTitle);

                const journal = document.createElement('div');
                journal.className = 'sandbox-journal';
                panel.appendChild(journal);

                this.content.appendChild(panel);

                this.sandboxElements = {
                    status, atoms, grid, journal
                };

                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.renderSandboxJournal();
                this.updateSandboxStatus('Load the latest premise or spawn a fresh training premise to begin.');
            }

            createSandboxButton(label, handler) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'secondary';
                btn.textContent = label;
                btn.addEventListener('click', handler);
                return btn;
            }

            loadCurrentPremise() {
                const current = this.engine.currentPremises && this.engine.currentPremises.length > 0
                    ? this.engine.currentPremises[this.engine.currentPremises.length - 1]
                    : null;
                if (!current) {
                    this.updateSandboxStatus('No live premise available yet. Start a session or spawn practice.');
                    return;
                }
                this.sandbox.premise = {
                    atoms: current.atoms.map(atom => ({ axis: atom.axis, head: atom.head, tail: atom.tail }))
                };
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Loaded the latest live premise into the sandbox.');
            }

            spawnPracticePremise() {
                const practice = this.generatePracticePremise();
                this.sandbox.premise = practice;
                this.sandbox.mapping = {};
                this.renderSandboxPremise();
                this.renderSandboxInputs();
                this.updateSandboxStatus('Spawned a fresh training premise.');
            }

            generatePracticePremise() {
                const k = Math.max(2, Math.min(4, this.engine ? this.engine.k : 3));
                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                const usedPairs = new Set();
                const atoms = [];
                for (let i = 0; i < k; i++) {
                    let head = letters[Math.floor(Math.random() * letters.length)];
                    let tail = letters[Math.floor(Math.random() * letters.length)];
                    let attempts = 0;
                    while ((head === tail || usedPairs.has(`${head}-${tail}`)) && attempts < 40) {
                        head = letters[Math.floor(Math.random() * letters.length)];
                        tail = letters[Math.floor(Math.random() * letters.length)];
                        attempts += 1;
                    }
                    usedPairs.add(`${head}-${tail}`);
                    const axis = MATCH_AXES[Math.floor(Math.random() * MATCH_AXES.length)];
                    atoms.push({ axis, head, tail });
                }
                return { atoms };
            }

            applySandboxOperations() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before applying operations.');
                    return;
                }
                let changed = false;
                const mapping = this.sandbox.mapping;
                this.sandbox.premise.atoms.forEach(atom => {
                    const headKey = atom.head;
                    const tailKey = atom.tail;
                    const headValue = (mapping[headKey] || '').trim();
                    const tailValue = (mapping[tailKey] || '').trim();
                    const transform = SANDBOX_TRANSFORMS[atom.axis];
                    if (!transform) return;
                    if (tailValue && !headValue) {
                        mapping[headKey] = transform.forward(tailValue);
                        changed = true;
                    } else if (headValue && !tailValue) {
                        mapping[tailKey] = transform.reverse(headValue);
                        changed = true;
                    }
                });
                this.renderSandboxInputs();
                this.updateSandboxStatus(changed ? 'Applied relation operations. Tweak any concept as needed.' : 'No changes applied. Anchor at least one letter first.');
            }

            commitSandboxJournal() {
                if (!this.sandbox.premise) {
                    this.updateSandboxStatus('Load or spawn a premise before committing to the journal.');
                    return;
                }
                const entries = Object.entries(this.sandbox.mapping)
                    .map(([letter, value]) => [letter, value ? value.trim() : ''])
                    .filter(([, value]) => value.length > 0)
                    .sort((a, b) => a[0].localeCompare(b[0]));
                if (entries.length === 0) {
                    this.updateSandboxStatus('Add at least one mapped concept before committing.');
                    return;
                }
                const record = {
                    timestamp: new Date().toISOString(),
                    premise: this.sandbox.premise.atoms,
                    mapping: entries
                };
                this.sandbox.journal.unshift(record);
                this.sandbox.journal = this.sandbox.journal.slice(0, 20);
                localStorage.setItem('instPracticeJournal', JSON.stringify(this.sandbox.journal));
                this.renderSandboxJournal();
                this.updateSandboxStatus('Mapping committed to journal.');
            }

            renderSandboxPremise() {
                if (!this.sandboxElements) return;
                const atoms = this.sandbox.premise ? this.sandbox.premise.atoms : [];
                if (!atoms || atoms.length === 0) {
                    this.sandboxElements.atoms.textContent = 'No practice premise loaded yet.';
                } else {
                    this.sandboxElements.atoms.textContent = atoms
                        .map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`)
                        .join('; ');
                }
            }

            renderSandboxInputs() {
                if (!this.sandboxElements) return;
                const grid = this.sandboxElements.grid;
                grid.innerHTML = '';
                if (!this.sandbox.premise) return;
                const letters = new Set();
                this.sandbox.premise.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                Array.from(letters).sort().forEach(letter => {
                    const cell = document.createElement('div');
                    cell.className = 'sandbox-letter';
                    const label = document.createElement('label');
                    label.textContent = `${letter} concept`;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = this.sandbox.mapping[letter] || '';
                    input.addEventListener('input', (event) => {
                        this.sandbox.mapping[letter] = event.target.value;
                    });
                    cell.append(label, input);
                    grid.appendChild(cell);
                });
            }

            renderSandboxJournal() {
                if (!this.sandboxElements) return;
                const journal = this.sandboxElements.journal;
                journal.innerHTML = '';
                if (this.sandbox.journal.length === 0) {
                    const empty = document.createElement('p');
                    empty.className = 'hint';
                    empty.textContent = 'Your journal entries will appear here.';
                    journal.appendChild(empty);
                    return;
                }
                this.sandbox.journal.forEach(entry => {
                    const item = document.createElement('div');
                    item.className = 'sandbox-journal-entry';
                    const timestamp = document.createElement('div');
                    timestamp.innerHTML = `<strong>${new Date(entry.timestamp).toLocaleString()}</strong>`;
                    const premise = document.createElement('div');
                    premise.textContent = `Premise: ${entry.premise.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ')}`;
                    const mapping = document.createElement('div');
                    mapping.innerHTML = entry.mapping.map(([letter, value]) => `<code>${letter}</code>: ${value}`).join('; ');
                    item.append(timestamp, premise, mapping);
                    journal.appendChild(item);
                });
            }

            updateSandboxStatus(message) {
                if (!this.sandboxElements) return;
                this.sandboxElements.status.textContent = message;
            }
        }

        class TestHarness {
            constructor() {
                this.seedManager = new SeedManager();
            }

            async runAll() {
                return [
                    await this.testNovelty(),
                    await this.testContradictions(),
                    await this.testCertificate(),
                    await this.testInputGating(),
                    await this.testProofExamples()
                ];
            }

            async testNovelty() {
                const seeds = [];
                const firstPremises = new Set();
                for (let i = 0; i < 5; i++) {
                    const seed = this.seedManager.generateSessionSeed(false);
                    seeds.push(seed);
                    const state = new GameState(seed, { windowSize: 12 });
                    const solver = new ConstraintSolver();
                    const eq = new EquivalenceEngine(false);
                    const generator = new PremiseGenerator(state, solver, eq);
                    let unique = true;
                    for (let trial = 0; trial < FIRST_N_NOVELTY; trial++) {
                        const result = generator.generate({
                            trialIndex: trial,
                            k: 2,
                            n: 2,
                            plannedMatch: false,
                            nBackPremise: null,
                            middleAtoms: [],
                            avoidLetters: null,
                            allowOverride: false
                        });
                        if (!result) {
                            unique = false;
                            break;
                        }
                        const key = result.premise.toKey();
                        if (firstPremises.has(key)) {
                            unique = false;
                        }
                        firstPremises.add(key);
                        state.novelty.register(state.novelty.buildSignatures(result.premise));
                    }
                }
                return {
                    test: 'Novelty',
                    passed: firstPremises.size >= seeds.length * FIRST_N_NOVELTY,
                    details: 'First six premises differ across restarts'
                };
            }

            async testContradictions() {
                const state = new GameState(12345, { windowSize: 12 });
                const solver = new ConstraintSolver();
                const atoms = [new Atom('N', 'A', 'B'), new Atom('S', 'A', 'B')];
                const sat = solver.evaluate([], atoms);
                return {
                    test: 'Constraint contradictions',
                    passed: !sat.ok,
                    details: 'Opposite relations rejected by SAT core'
                };
            }

            async testCertificate() {
                const premiseA = new Premise([new Atom('N', 'A', 'B'), new Atom('W', 'A', 'C')]);
                const premiseB = new Premise([new Atom('S', 'B', 'A'), new Atom('E', 'C', 'A')]);
                const eq = new EquivalenceEngine(false);
                const certificate = eq.computeCertificate(premiseA, premiseB, []);
                return {
                    test: 'Certificate generation',
                    passed: certificate.match && certificate.certificate.mapping.length === 2,
                    details: 'Invertible mapping generated for 2-atom pair'
                };
            }

            async testInputGating() {
                const dummyEngine = new GameEngine();
                await dummyEngine.voice.initialize();
                const dummySession = {
                    ...newSession(dummyEngine),
                    abort: new AbortController(),
                    trialToken: 1
                };
                session = dummySession;
                const promise = collectResponseSafe(0.05, dummySession.trialToken, dummySession.abort.signal);
                dummySession.abort.abort();
                const result = await promise;
                session = null;
                return {
                    test: 'Input gating',
                    passed: result.type === 'timeout',
                    details: 'Abort resolves response promise as timeout'
                };
            }

            async testProofExamples() {
                const eq = new EquivalenceEngine(false);
                const p1 = new Premise([new Atom('N', 'A', 'B')]);
                const mid = [new Atom('N', 'B', 'C')];
                const p2 = new Premise([new Atom('N', 'A', 'C')]);
                const cert = eq.computeCertificate(p1, p2, mid);
                return {
                    test: 'Proof-based equivalence',
                    passed: !cert.match,
                    details: 'Mid-window derivable relation rejected when transitivity off'
                };
            }

            testDialecticalSATValidation() {
                console.log('=== TEST: Dialectical SAT Validation ===');
                const solver = new ConstraintSolver();

                // Test all 4 orthogonal combinations
                const testCases = [
                    { axes: ['N', 'W'], desc: 'North + West' },
                    { axes: ['N', 'E'], desc: 'North + East' },
                    { axes: ['S', 'W'], desc: 'South + West' },
                    { axes: ['S', 'E'], desc: 'South + East' }
                ];

                let allPassed = true;

                for (const testCase of testCases) {
                    const atoms = [
                        new Atom(testCase.axes[0], 'A', 'B'),
                        new Atom(testCase.axes[1], 'A', 'B')
                    ];

                    const result = solver.evaluate([], atoms);

                    if (!result.ok) {
                        console.error(`FAILED: ${testCase.desc} - SAT rejected with reason: ${result.reason}`);
                        allPassed = false;
                    } else {
                        const coordA = result.coordinates.get('A');
                        const coordB = result.coordinates.get('B');
                        console.log(`PASSED: ${testCase.desc} - A:(${coordA.x},${coordA.y}) B:(${coordB.x},${coordB.y})`);

                        // Verify coordinates satisfy relations
                        const [axis1, axis2] = testCase.axes;
                        let valid = true;

                        if (axis1 === 'N' && coordA.y <= coordB.y) valid = false;
                        if (axis1 === 'S' && coordA.y >= coordB.y) valid = false;
                        if (axis1 === 'E' && coordA.x <= coordB.x) valid = false;
                        if (axis1 === 'W' && coordA.x >= coordB.x) valid = false;

                        if (axis2 === 'N' && coordA.y <= coordB.y) valid = false;
                        if (axis2 === 'S' && coordA.y >= coordB.y) valid = false;
                        if (axis2 === 'E' && coordA.x <= coordB.x) valid = false;
                        if (axis2 === 'W' && coordA.x >= coordB.x) valid = false;

                        if (!valid) {
                            console.error(`FAILED: ${testCase.desc} - Coordinates don't satisfy relations`);
                            allPassed = false;
                        }
                    }
                }

                console.log(allPassed ? '‚úì All dialectical SAT tests PASSED' : '‚úó Some dialectical SAT tests FAILED');
                return allPassed;
            }
        }

        const engine = new GameEngine();
        const instructions = new InstructionsManager(engine);
        instructions.initialize();
        engine.initialize().then(() => {
            console.log('Game engine initialization complete');
            instructions.updateCompletionState();
            if (instructions.dialogOpen && instructions.readAloud) {
                instructions.queueSpeech(true);
            }
        }).catch((error) => {
            console.error('Game engine initialization failed:', error);
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = 'Voice initialization failed. Check console for details.';
            }
            alert('Voice system failed to initialize. Please check your browser settings and reload the page.\n\nError: ' + error.message);
        });
    </script>
</body>
</html>
